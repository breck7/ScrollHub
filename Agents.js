const { Anthropic } = require("@anthropic-ai/sdk")
const fs = require("fs")
const path = require("path")
const OpenAI = require("openai")
const { Particle } = require("scrollsdk/products/Particle.js")

class FolderPrompt {
  constructor(userPrompt, existingFolderNames, agent, whatKind, domainSuffix) {
    this.userPrompt = userPrompt
    this.existingNames = existingFolderNames
    this.agent = agent
    this.what = whatKind
    this.domainSuffix = domainSuffix
    this.systemPrompt = this.makePrompt(userPrompt, domainSuffix)
  }
  setResponse(response) {
    this.response = response
    return this
  }

  makePrompt(userPrompt, domainSuffix) {
    domainSuffix = "." + domainSuffix.replace(/^\./, "")
    const domainExpression = `(domain${domainSuffix} here)`
    const domainPrompt = `First suggest a short, memorable domain name ending in ${domainSuffix} that represents this website. Then provide the website files. Use this exact format:

---domain---
${domainExpression}`
    let basePrompt = fs.readFileSync(path.join(__dirname, "prompts", this.what + ".scroll"), "utf8")
    basePrompt = basePrompt.replace("USER_PROMPT", userPrompt)
    basePrompt = basePrompt.replace("DOMAIN_PROMPT", domainPrompt)
    basePrompt = basePrompt.replace("DOMAIN_EXPRESSION", domainSuffix)
    return basePrompt
  }

  setDebugLog(completion) {
    this.completion = completion
  }

  get parsedResponse() {
    const { response } = this
    const files = {}

    let currentFile = null
    let currentContent = []
    let suggestedDomain = ""

    for (const line of response.split("\n")) {
      if (line.startsWith("---") && line.endsWith("---")) {
        if (currentFile === "domain" && currentContent.length > 0) {
          suggestedDomain = currentContent.join("").trim()
        } else if (currentFile && currentContent.length > 0) {
          files[currentFile] = currentContent.join("\n")
        }
        currentContent = []
        const fileName = line.replace(/---/g, "")
        if (fileName === "end") break
        currentFile = fileName
      } else if (currentFile) {
        currentContent.push(line)
      }
    }

    if (!suggestedDomain) suggestedDomain = "error"

    // Ensure the suggested domain ends with .scroll.pub
    if (!suggestedDomain.endsWith(".scroll.pub")) {
      suggestedDomain = suggestedDomain.replace(/\.scroll\.pub.*$/, "") + ".scroll.pub"
    }

    // If domain is taken, add numbers until we find a free one
    let finalDomain = suggestedDomain
    let counter = 1
    while (this.existingNames.includes(finalDomain)) {
      const baseName = suggestedDomain.replace(".scroll.pub", "")
      finalDomain = `${baseName}${counter}.scroll.pub`
      counter++
    }

    // Add a default README
    files["readme.scroll"] = `# ${finalDomain}\n\n${this.what} generated by ${this.agent.name} from prompt: ${this.userPrompt}`

    return {
      folderName: finalDomain,
      files
    }
  }
}

class AbstractAgent {
  constructor(apiKey, hubFolder) {
    this.apiKey = apiKey
    this.hubFolder = hubFolder
  }
}

class Claude extends AbstractAgent {
  get client() {
    if (!this._client)
      this._client = new Anthropic({
        apiKey: this.apiKey
      })
    return this._client
  }
  name = "Claude"
  async do(prompt) {
    console.log("Sending prompt to claude")
    const { client } = this
    // Call Claude API
    const completion = await client.messages.create({
      model: "claude-3-5-sonnet-20241022",
      max_tokens: 4000,
      temperature: 0.7,
      messages: [{ role: "user", content: prompt.systemPrompt }]
    })
    // Parse Claude's response into domain and files
    const response = completion.content[0].text
    prompt.setDebugLog(completion)
    return prompt.setResponse(response)
  }
}

class OpenAIAgent extends AbstractAgent {}

class DeepSeek extends AbstractAgent {
  get client() {
    if (!this._client)
      this._client = new OpenAI({
        baseURL: "https://api.deepseek.com",
        apiKey: this.apiKey
      })
    return this._client
  }
  name = "DeepSeek"
  async do(prompt) {
    console.log("Sending prompt to deepseek")
    const completion = await this.client.chat.completions.create({
      messages: [{ role: "system", content: prompt.systemPrompt }],
      model: "deepseek-chat"
    })
    const response = completion.choices[0].message.content
    prompt.setDebugLog(completion)
    return prompt.setResponse(response)
  }
}

const AgentClasses = { claude: Claude, deepseek: DeepSeek, openai: OpenAIAgent }

class Agents {
  constructor(hub) {
    this.hubFolder = hub.hubFolder
    this.config = hub.config
    this.agents = {}
    this.availableAgents.forEach(agent => this.loadAgent(agent))
  }

  availableAgents = "claude deepseek".split(" ")

  loadAgent(name) {
    const { hubFolder } = this
    const apiKey = this.config.get(name)
    if (!apiKey) {
      console.log(`No ${name} API key found. Skipping ${name} agent`)
      return
    } else {
      console.log(`${name} agent loaded.`)
    }
    const agentConstructor = AgentClasses[name]
    this.agents[name] = new agentConstructor(apiKey, hubFolder)
  }

  get allAgents() {
    return Object.values(this.agents)
  }

  async createFolderNameAndFilesFromPrompt(userPrompt, existingNames, agentName, promptTemplate, domainSuffix) {
    const agent = this.agents[agentName] || this.allAgents[0]
    const prompt = new FolderPrompt(userPrompt, existingNames, agent, promptTemplate, domainSuffix)
    if (!agent) throw new Error(`Agent ${agentName} not found. Is API key set?`)
    await agent.do(prompt)
    return prompt
  }

  // todo: wire this up
  async createMultipleFoldersFromPrompt(userPrompt, existingNames) {
    return await Promise.all(
      this.allAgents.map(async agent => {
        const prompt = new SimpleCreationPrompt(userPrompt, existingNames)
        await agent.do(prompt)
        return prompt
      })
    )
  }
}

module.exports = { Agents }
