const AppConstants = {
	parsers:
		'wrapNameCell\n description Options to turn on some wraps.\n enum bold italics code katex none\nbuildCommandWordCell\n extends commandWordCell\n description Give build command words their own color.\n highlightScope constant\nblankCell\nanyCell\nenumCell\n highlightScope constant.language\nbooleanCell\n enum true false\n extends enumCell\nstringCell\n highlightScope string\nwordCell\n highlightScope string\n description A non-empty single word string.\n regex .+\nsemanticVersionCell\n highlightScope string\n description A 3 part sem version string like 1.2.1\ndateCell\n highlightScope string\nnumberCell\n highlightScope constant.numeric\nintegerCell\n extends numberCell\n highlightScope constant.numeric.integer\nfloatCell\n extends numberCell\n highlightScope constant.numeric.float\npercentCell\n highlightScope constant.numeric.float\n extends stringCell\n // todo: this currently extends from stringCell b/c scrollsdk needs to be fixed. seems like if extending from number then the hard coded number typescript regex takes precedence over a custom regex\ncountCell\n extends integerCell\nyearCell\n extends integerCell\ncommandWordCell\n description A word that indicates a certain parser to use.\n highlightScope keyword\npreBuildCommandWordCell\n extends commandWordCell\n description Give build command words their own color.\n highlightScope constant.character.escape\ncommentCell\n highlightScope comment\ndelimiterCell\n description String to use as a delimiter.\n highlightScope string\ncodeCell\n highlightScope comment\nbulletPointCell\n description Any token used as a bullet point such as "-" or "1." or ">"\n highlightScope keyword\npersonNameCell\n extends stringCell\nurlCell\n highlightScope constant.language\nabsoluteUrlCell\n highlightScope constant.language\n regex (ftp|https?)://.+\nemailAddressCell\n extends stringCell\npermalinkCell\n highlightScope string\n description A string that doesn\'t contain characters that might interfere with most filesystems. No slashes, for instance.\nfilePathCell\n extends stringCell\ntagOrUrlCell\n description An HTML tag or a url.\n highlightScope constant.language\nhtmlAttributesCell\n highlightScope comment\nhtmlTagCell\n highlightScope constant.language\n enum div span p a img ul ol li h1 h2 h3 h4 h5 h6 header nav section article aside main footer input button form label select option textarea table tr td th tbody thead tfoot br hr meta link script style title code\nclassNameCell\n highlightScope constant\nhtmlIdCell\n extends anyCell\ncssAnyCell\n extends anyCell\nhtmlAnyCell\n extends stringCell\nmeasureNameCell\n extends commandWordCell\n // A regex for column names for max compatibility with a broad range of data science tools:\n regex [a-zA-Z][a-zA-Z0-9]*\njavascriptCell\n extends stringCell\nmetaCommandWordCell\n extends commandWordCell\n description Give meta command words their own color.\n highlightScope constant.numeric\n // Obviously this is not numeric. But I like the green color for now.\n   We need a better design to replace this "highlightScope" concept\n   https://github.com/breck7/scrollsdk/issues/186\nscriptAnyCell\n extends anyCell\ntagCell\n extends permalinkCell\ntagWithOptionalFolderCell\n description A group name optionally combined with a folder path. Only used when referencing tags, not in posts.\n extends stringCell\nabstractScrollParser\n cells commandWordCell\n javascript\n  compileEmbeddedVersion(compileSettings) {\n   return this.compile(compileSettings)\n  }\n  compileTxt() {\n    return ""\n  }\n  getHtmlRequirements(compileSettings) {\n    const {requireOnce} = this\n    if (!requireOnce)\n      return ""\n    const set = compileSettings?.alreadyRequired || this.root.alreadyRequired\n    if (set.has(requireOnce))\n      return ""\n    \n    set.add(requireOnce)\n    return requireOnce + "\\n\\n"\n  }\nabstractAftertextParser\n description Text followed by markup commands.\n extends abstractScrollParser\n inScope abstractAftertextDirectiveParser abstractAftertextAttributeParser aftertextTagParser commentParser\n example\n  aftertext\n   Hello brave new world\n   link home.com new\n   bold brave new\n   underline new world\n   strike wor\n javascript\n  get markupInserts() {\n   const { originalTextPostLinkify } = this\n   return this.filter(node => node.isMarkup)\n    .map(node => node.getInserts(originalTextPostLinkify))\n    .filter(i => i)\n    .flat()\n  }\n  get originalText() {\n   return this.content ?? ""\n  }\n  get originalTextPostLinkify() {\n   const { originalText } = this\n   const shouldLinkify = this.get("linkify") === "false" || originalText.includes("<a ") ? false : true\n   return shouldLinkify ? this.replaceNotes(Utils.linkify(originalText)) : originalText\n  }\n  replaceNotes(originalText) {\n   // Skip the replacements if there are no footnotes or the text has none.\n   if (!this.root.footnotes.length || !originalText.includes("^")) return originalText\n   this.root.footnotes.forEach((note, index) => {\n    const needle = note.firstWord\n    const {linkBack} = note\n    if (originalText.includes(needle)) originalText = originalText.replace(new RegExp("\\\\" + needle + "\\\\b"), `<a href="#${note.anchorId}" class="scrollNoteLink" id="${linkBack}"><sup>${note.label}</sup></a>`)\n   })\n   return originalText\n  }\n  get text() {\n   const { originalTextPostLinkify, markupInserts } = this\n   let adjustment = 0\n   let newText = originalTextPostLinkify\n   // If multiple tags start at same index, the tag that closes first should start last. Otherwise HTML breaks.\n   markupInserts.sort((a, b) => (a.index === b.index ? b.endIndex - a.endIndex : a.index - b.index))\n   markupInserts.forEach(insertion => {\n    insertion.index += adjustment\n    const consumeStartCharacters = insertion.consumeStartCharacters ?? 0\n    const consumeEndCharacters = insertion.consumeEndCharacters ?? 0\n    newText = newText.slice(0, insertion.index - consumeEndCharacters) + insertion.string + newText.slice(insertion.index + consumeStartCharacters)\n    adjustment += insertion.string.length - consumeEndCharacters - consumeStartCharacters\n   })\n   return newText\n  }\n  tag = "p"\n  get className() {\n   if (this.get("classes"))\n     return this.get("classes")\n   const classLine = this.getNode("class")\n   if (classLine && classLine.applyToParentElement) return classLine.content\n   return this.defaultClassName\n  }\n  defaultClassName = "scrollParagraph"\n  get isHidden() {\n    return this.has("hidden")\n  }\n  compile(compileSettings) {\n   if (this.isHidden) return ""\n   this.compileSettings = compileSettings\n   const { className } = this\n   const classAttr = className ? `class="${this.className}"` : ""\n   const tag = this.get("tag") || this.tag\n   if (tag === "none") // Allow no tag for aftertext in tables\n     return this.text\n   return this.getHtmlRequirements(compileSettings) + `<${tag} ${this.divAttributes}${classAttr}>${this.text}</${tag}>`\n  }\n  get divAttributes() {\n   const attrs = this.filter(node => node.isAttribute)\n   return attrs.length ? attrs.map(node => node.divAttributes).join(" ") + " " : ""\n  }\nparagraphParser\n // todo Perhaps rewrite this from scratch and move out of aftertext.\n extends abstractAftertextParser\n catchAllCellType stringCell\n description A paragraph.\n boolean suggestInAutocomplete false\n cruxFromId\n javascript\n  compile(compileSettings) {\n   if (this.isHidden) return ""\n   // Hacky, I know.\n   const newLine = this.has("wrapsOn") ? undefined : this.appendLine("wrapsOn")\n   const compiled = super.compile(compileSettings)\n   if (newLine)\n    newLine.destroy()\n   return compiled\n  }\n  compileTxt() {\n    const children = this.filter(node => node.compileTxt).map(node => node.compileTxt()).filter(i => i).join("\\n")\n    const dateline = this.getNode("dateline")\n    return (dateline ? dateline.day + "\\n\\n" : "") + (this.originalText || "") + (children ? "\\n " + children.replace(/\\n/g, "\\n ") : "")\n  }\nauthorsParser\n // multiple authors delimited by " and "\n boolean isPopular true\n extends paragraphParser\n description Set author(s) name(s).\n example\n  authors Breck Yunits\n   https://breckyunits.com Breck Yunits\n // note: once we have mixins in Parsers, lets mixin the below from abstractTopLevelSingleMetaParser\n cells metaCommandWordCell\n javascript\n  isTopMatter = true\n  isSetterParser = true\n  compileHtmlForPrint() {\n    // hacky. todo: cleanup\n    const originalContent = this.content\n    this.setContent(`by ${originalContent}`)\n    const html = super.compile()\n    this.setContent(originalContent)\n    return html\n  }\n  compileTxtForPrint() {\n    return \'by \' + super.compileTxt()\n  }\n  compile() {\n   return ""\n  }\n  compileTxt() {\n    return ""\n  }\n  defaultClassName = "scrollByLine"\nblinkParser\n description Just for fun.\n extends paragraphParser\n crux blink\n javascript\n  compile() {\n   return `<span class="scrollBlink">${super.compile()}</span>\n    <script>setInterval(()=>{ Array.from(document.getElementsByClassName("scrollBlink")).forEach(el => el.style.visibility = el.style.visibility === "hidden" ? "visible" : "hidden") }, 2000)</script>`\n  }\ncatchAllParagraphParser\n description A paragraph.\n extends paragraphParser\n boolean suggestInAutocomplete false\n boolean isPopular true\n cells stringCell\n javascript\n  get originalText() {\n   return this.getLine() || ""\n  }\nabstractIndentableParagraphParser\n extends paragraphParser\n inScope abstractAftertextDirectiveParser abstractAftertextAttributeParser abstractIndentableParagraphParser\n javascript\n  compileChildren() {\n    return this.map(node => node.compile())\n     .join("\\n")\n     .trim()\n  }\n  compile() {\n   return super.compile() + this.compileChildren()\n  }\n  compileTxt() {\n    return this.getWord(0) + " " + super.compileTxt()\n  }\nchecklistTodoParser\n extends abstractIndentableParagraphParser\n example\n  [] Get milk\n description A task todo.\n crux []\n string checked \n javascript\n  get text() {\n   return `<div style="text-indent:${(this.getIndentLevel() - 1) * 20}px;"><input type="checkbox" ${this.checked} id="${this.id}"><label for="${this.id}">` + super.text + `</label></div>`\n  }\n  get id() {\n   return this.get("id") || "item" + this._getUid()\n  }\nchecklistDoneParser\n extends checklistTodoParser\n description A completed task.\n string checked checked\n crux [x]\n example\n  [x] get milk\nlistAftertextParser\n extends abstractIndentableParagraphParser\n example\n  - I had a _new_ thought.\n description A list item.\n crux -\n javascript\n  defaultClassName = ""\n  compile() {\n   const index = this.getIndex()\n   const parent = this.parent\n   const nodeClass = this.constructor\n   const isStartOfList = index === 0 || !(parent.nodeAt(index - 1) instanceof nodeClass)\n   const isEndOfList = parent.length === index + 1 || !(parent.nodeAt(index + 1) instanceof nodeClass)\n   const { listType } = this\n   return (isStartOfList ? `<${listType} ${this.attributes}>` : "") + `${super.compile()}` + (isEndOfList ? `</${listType}>` : "")\n  }\n  get attributes() {\n    return ""\n  }\n  tag = "li"\n  listType = "ul"\nabstractCustomListItemParser\n extends listAftertextParser\n javascript\n  get requireOnce() {\n    return `<style>\\n.${this.constructor.name} li::marker {content: "${this.firstWord} ";}\\n</style>`\n  }\n  get attributes() {\n    return `class="${this.constructor.name}"`\n  }\norderedListAftertextParser\n extends listAftertextParser\n description A list item.\n example\n  1. Hello world\n pattern ^\\d+\\. \n javascript\n  listType = "ol"\n  get attributes() { return ` start="${this.getWord(0)}"`}\nquickQuoteParser\n crux >\n boolean isPopular true\n extends abstractIndentableParagraphParser\n description A quote.\n javascript\n  defaultClassName = "scrollQuote"\n  tag = "blockquote"\nexpanderParser\n cruxFromId\n description An collapsible HTML details tag.\n extends paragraphParser\n javascript\n  compile() {\n   this.parent.sectionStack.push("</details>")\n   return `<details>${super.compile()}`\n  }\n  compileTxt() {\n    return this.content\n  }\n  tag = "summary"\n  defaultClassName = ""\nfootnoteDefinitionParser\n description A footnote. Can also be used as section notes.\n extends paragraphParser\n boolean isFootnote true\n pattern ^\\^.+$\n // We need to quickLinks back in scope because there is currently a bug in ScrollSDK/parsers where if a parser extending a parent class has a child parser defined, then any regex parsers in the parent class will not be tested unless explicitly included in scope again.\n inScope quickLinkParser\n labelParser\n  description If you want to show a custom label for a footnote. Default label is the note definition index.\n  cruxFromId\n  cells commandWordCell\n  catchAllCellType stringCell\n javascript\n  get divAttributes() {\n   return super.divAttributes + ` id="${this.anchorId}"`\n  }\n  get anchorId() {\n   return `note${this.noteDefinitionIndex}`\n  }\n  get label() {\n   // In the future we could allow common practices like author name\n   return this.get("label") || `[${this.noteDefinitionIndex}]`\n  }\n  get linkBack() {\n   return `noteUsage${this.noteDefinitionIndex}`\n  }\n  get text() {\n   return `<a class="scrollFootNoteUsageLink" href="#noteUsage${this.noteDefinitionIndex}">${this.label}</a> ${super.text}`\n  }\n  get noteDefinitionIndex() {\n   return this.parent.footnotes.indexOf(this) + 1\n  }\n  compileTxt() {\n    return this.getWord(0) + ": " + super.compileTxt()\n  }\nabstractHeaderParser\n extends paragraphParser\n javascript\n  compile(compileSettings) {\n   if (this.isHidden) return ""\n   this.parent.sectionStack.push("</div>")\n   return `<div class="scrollSection">` + super.compile(compileSettings)\n  }\n  compileTxt() {\n    const line = super.compileTxt()\n    return line + "\\n" + "=".repeat(line.length)\n  }\nh1Parser\n description An html h1 tag.\n extends abstractHeaderParser\n crux #\n boolean isPopular true\n javascript\n  tag = "h1"\nh2Parser\n description An html h2 tag.\n extends abstractHeaderParser\n crux ##\n boolean isPopular true\n javascript\n  tag = "h2"\nh3Parser\n description An html h3 tag.\n extends abstractHeaderParser\n crux ###\n javascript\n  tag = "h3"\nh4Parser\n description An html h4 tag.\n extends abstractHeaderParser\n crux ####\n javascript\n  tag = "h4"\nquestionAftertextParser\n description A question.\n extends h4Parser\n crux ?\n javascript\n  defaultClassName = "scrollQuestion"\nh5Parser\n description An html h5 tag.\n extends abstractHeaderParser\n crux #####\n javascript\n  tag = "h5"\nprintTitleParser\n description Print title.\n extends abstractHeaderParser\n boolean isPopular true\n cruxFromId\n javascript\n  compile(compileSettings) {\n   // Hacky, I know.\n   const {content} = this\n   if (content === undefined)\n    this.setContent(this.parent.file.title)\n   const { permalink } = this.parent.file\n   if (!permalink) {\n    this.setContent(content) // Restore it as it was.\n    return super.compile(compileSettings)\n   }\n   const newLine = this.appendLine(`link ${permalink}`)\n   const compiled = super.compile(compileSettings)\n   newLine.destroy()\n   this.setContent(content) // Restore it as it was.\n   return compiled\n  }\n  get originalText() {\n   return this.content ?? this.parent.file.title ?? ""\n  }\n  defaultClassName = "scrollTitle"\n  tag = "h1"\ncaptionAftertextParser\n description An image caption.\n crux caption\n extends paragraphParser\n boolean isPopular true\nquickParagraphParser\n crux *\n extends paragraphParser\n description A paragraph.\n example\n  * I had a _new_ idea.\nscrollCenteredParagraphParser\n // todo: does not work with gazette.\n crux center\n extends paragraphParser\n description A centered paragraph.\n example\n  center Hello world\n javascript\n  compile(compileSettings) {\n   return `<div style="text-align:center;">${super.compile(compileSettings)}</div>`\n  }\nthinColumnsParser\n extends abstractAftertextParser\n cruxFromId\n catchAllCellType integerCell\n description Thin columns.\n javascript\n  compileEmbeddedVersion() {\n   return ""\n  }\n  columnWidth = 35\n  columnGap = 20\n  compile() {\n   const {columnWidth, columnGap} = this\n   const maxColumns = parseInt(this.getWord(1) ?? 10)\n   const maxTotalWidth = maxColumns * columnWidth + (maxColumns - 1) * columnGap\n   // Starting the columns always first clears the section stack.\n   return this.parent.clearSectionStack() + `<div class="scrollColumns" style="column-width:${columnWidth}ch;column-count:${maxColumns};max-width:${maxTotalWidth}ch;">`\n  }\nwideColumnsParser\n extends thinColumnsParser\n description Wide columns.\n javascript\n  columnWidth = 90\nmediumColumnsParser\n extends thinColumnsParser\n description Medium width columns.\n javascript\n  columnWidth = 65\nendColumnsParser\n extends abstractAftertextParser\n cruxFromId\n description End columns.\n javascript\n  compile() {\n   return "</div>"\n  }\n  compileEmbeddedVersion() {\n   return ""\n  }\nabstractDinkusParser\n extends abstractAftertextParser\n string dinkus *\n boolean isDinkus true\n javascript\n  compile() {\n   return `<div class="dinkus"><span>${this.dinkus}</span></div>`\n  }\n  compileTxt() {\n    return this.getLine()\n  }\nhorizontalRuleParser\n crux ---\n description A horizontal rule.\n extends abstractDinkusParser\n javascript\n  compile() {\n   return `<hr>`\n  }\ndinkusParser\n crux ***\n description A dinkus. Breaks section.\n boolean isPopular true\n extends abstractDinkusParser\nendOfPostDinkusParser\n extends abstractDinkusParser\n description End of post dinkus.\n boolean isPopular true\n crux ****\n string dinkus ⁂\nloopParser\n extends abstractAftertextParser\n cells commandWordCell\n description Iterate over files+ to make HTML.\n cruxFromId\n inScope abstractItemsProviderParser\n joinParser\n  extends abstractLoopConfigParser\n  description HTML to use to join the items.\n limitParser\n  extends abstractLoopConfigParser\n  description HTML to use to join the items.\n javascriptParser\n  extends abstractLoopConfigParser\n  description Javascript to execute for each file in the loop.\n javascript\n  compile() {\n   const code = this.get("javascript")\n   const joinWith = this.get("join") ?? ""\n   try {\n    const limit = this.get("limit")\n    let items = this.items\n    if (limit) items = items.slice(0, parseInt(limit))\n    return items.map((item, index) => eval(code)).join(joinWith)\n   } catch (err) {\n    console.error(err)\n    return ""\n   } finally {\n    this.teardown()\n   }\n  }\n  get items() {\n   const provider = this.getChildInstancesOfParserId("abstractItemsProviderParser")[0]\n   return provider ? provider.items : []\n  }\n  teardown() {}\nloremIpsumParser\n extends abstractAftertextParser\n cruxFromId\n description Generate dummy text.\n catchAllCellType integerCell\n javascript\n  compile() {\n   const text = `Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.`\n   return text.repeat(this.getWord(1) ? parseInt(this.getWord(1)) : 1)\n  }\nprintSnippetsParser\n // todo: why are we extending AT here and not loops? Is it for class/id etc?\n extends abstractAftertextParser\n cruxFromId\n cells commandWordCell\n catchAllCellType tagWithOptionalFolderCell\n description Prints snippets in group(s).\n example\n  printSnippets index\n javascript\n  makeSnippet(file, compileSettings) {\n    const {scrollProgram, endSnippetIndex} = file\n    if (endSnippetIndex === -1) return scrollProgram.compileEmbeddedVersion(compileSettings) + file.viewSourceHtml\n    const linkRelativeToCompileTarget = compileSettings.relativePath + file.permalink\n    const joinChar = "\\n"\n    const html = scrollProgram\n        .map((child, index) => (index >= endSnippetIndex ? "" : child.compileEmbeddedVersion ? child.compileEmbeddedVersion(compileSettings) : child.compile(compileSettings)))\n        .filter(i => i)\n        .join(joinChar)\n        .trim() +\n      `<a class="scrollContinueReadingLink" href="${linkRelativeToCompileTarget}">Continue reading...</a>`\n    return html\n  }\n  get files() {\n   const thisFile = this.parent.file\n   return this.parent.file.getFilesWithTagsForEmbedding(this.getWordsFrom(1), this.has("limit") ? parseInt(this.get("limit")) : undefined).filter(file => file.file !== thisFile)\n  }\n  compile() {\n   const alreadyRequired = this.root.alreadyRequired\n   const snippets = this.files.map(file => {\n    const compileSettings = {relativePath: file.relativePath, alreadyRequired }\n    return `<div class="scrollSnippetContainer">${this.makeSnippet(file.file, compileSettings)}</div>`\n    }).join("\\n\\n")\n   return `<div class="scrollColumns" style="column-width:35ch;">${snippets}</div>`\n  }\n  compileTxt() {\n   return this.files.map(file =>  {\n    const title = file.file.title\n    const ruler = "=".repeat(title.length)\n    // Note: I tried to print the description here but the description generating code needs work.\n    return `${title}\\n${ruler}\\n${file.file.date}\\n${file.file.absoluteLink}`\n   }).join("\\n\\n")\n  }\nprintFullSnippetsParser\n extends printSnippetsParser\n cruxFromId\n description Print full pages in group(s).\n javascript\n  makeSnippet(file, compileSettings) {\n   return file.scrollProgram.compileEmbeddedVersion(compileSettings) + file.viewSourceHtml\n  }\nprintRelatedParser\n description Print links to related posts.\n extends printSnippetsParser\n cruxFromId\n javascript\n  makeSnippet(file, compileSettings) {\n    // get title, permalink, and year\n    const {title, permalink, year} = file\n    const node = this.appendSibling(`- ${title}${year ? " (" + year + ")" : ""}`, `link ${permalink}`)\n    // A hacky but simple way to do this for now.\n    const html = node.compile()\n    node.destroy()\n    return html\n  }\nprintViewSourceParser\n description Print "View source" link.\n extends abstractAftertextParser\n cruxFromId\n javascript\n  compileEmbeddedVersion() {\n   return ""\n  }\n  compile() {\n   const file = this.parent.file\n   const { viewSourceUrl } = file\n   return file.compileStumpCode(`p\n   class scrollViewSource doNotPrint\n   a View source\n    href ${viewSourceUrl}`)\n  }\nprintViewSourceBadgeParser\n description Print badge top right.\n extends abstractAftertextParser\n cruxFromId\n javascript\n  compileEmbeddedVersion() {\n   return ""\n  }\n  compile() {\n   const file = this.parent.file\n   const { viewSourceUrl, SVGS } = file\n   return file.compileStumpCode(`div\n   class scrollViewSourceBadge doNotPrint\n   a ${SVGS.git}\n    href ${viewSourceUrl}`)\n  }\nabstractPrintMetaParser\n extends abstractScrollParser\n cruxFromId\nprintAuthorsParser\n description Prints author(s) byline.\n boolean isPopular true\n extends abstractPrintMetaParser\n // todo: we need pattern matching added to sdk to support having no params or a url and personNameCell\n catchAllCellType anyCell\n example\n  // With Link:\n  printAuthors Breck Yunits\n   https://breckyunits.com\n javascript\n  compile() {\n   return this.parent.getNode("authors")?.compileHtmlForPrint()\n  }\n  compileTxt() {\n    return this.parent.getNode("authors")?.compileTxtForPrint()\n  }\nprintDateParser\n extends abstractPrintMetaParser\n // If not present computes the date from the file\'s ctime.\n description Print published date.\n boolean isPopular true\n javascript\n  compile() {\n   return `<div style="text-align: center;" class="scrollDateline">${this.day}</div>`\n  }\n  get day() {\n   let day = this.content || this.root.get("date") || this.root.file?.date\n   if (!day) return ""\n   try {\n    const dayjs = require("dayjs")\n    return dayjs(day).format(`MMMM D, YYYY`)\n   } catch (err) {\n    console.error(err)\n   }\n   return day || ""\n  }\n  compileTxt() {\n    return this.day\n  }\nprintFormatLinksParser\n description Prints links to other formats.\n extends abstractPrintMetaParser\n example\n  printFormatLinks\n javascript\n  compile() {\n   const permalink = this.root.file.permalink.replace(".html", "")\n   // hacky\n   const node = this.appendSibling(`HTML | TXT`, `class scrollDateline\\nlink ${permalink}.html HTML\\nlink ${permalink}.txt TXT\\nstyle text-align:center;`)\n   const html = node.compile()\n   node.destroy()\n   return html\n  }\n  compileTxt() {\n    const permalink = this.root.file.permalink.replace(".html", "")\n    return `HTML | TXT\\n link ${permalink}.html HTML\\n link ${permalink}.txt TXT`\n  }\nabstractBuildCommandParser\n extends abstractScrollParser\n cruxFromId\n cells buildCommandWordCell\n catchAllCellType filePathCell\n inScope slashCommentParser\n javascript\n  isTopMatter = true\n  compile() {\n   return ""\n  }\nloadConceptsParser\n // todo: clean this up. just add smarter imports with globs?\n // this currently removes any "import" statements.\n description Import all concepts in a folder.\n extends abstractBuildCommandParser\n cruxFromId\n cells preBuildCommandWordCell filePathCell\n javascript\n  build() {\n   const { Disk } = require("scrollsdk/products/Disk.node.js")\n   const path = require("path")\n   const {file} = this.parent\n   const folder = path.join(file.folderPath, this.getWord(1))\n   const ONE_BIG_FILE = Disk.getFiles(folder).filter(file => file.endsWith(".scroll")).map(Disk.read).filter(str => /^id /mg.test(str)).join("\\n\\n").replace(/import .+/g, "")\n    this.parent.concat(ONE_BIG_FILE)\n   //console.log(ONE_BIG_FILE)\n  }\n  compile() {\n    return ""\n  }\nbuildConceptsParser\n cruxFromId\n description Write concepts to csv+ files.\n extends abstractBuildCommandParser\n sortByParser\n  cruxFromId\n  cells commandWordCell anyCell\nbuildCssParser\n description Compile to CSS file.\n extends abstractBuildCommandParser\nbuildHtmlParser\n description Compile to HTML file.\n extends abstractBuildCommandParser\n boolean isPopular true\nbuildMeasuresParser\n cruxFromId\n description Write measures to csv+ files.\n extends abstractBuildCommandParser\n sortByParser\n  cruxFromId\n  cells commandWordCell anyCell\nbuildRssParser\n description Write RSS file.\n extends abstractBuildCommandParser\nbuildJsParser\n description Compile to JS file.\n extends abstractBuildCommandParser\nbuildTxtParser\n description Compile to TXT file.\n extends abstractBuildCommandParser\n boolean isPopular true\nchatParser\n description A faux text chat conversation.\n catchAllParser chatLineParser\n cruxFromId\n extends abstractScrollParser\n javascript\n  compile() {\n   return this.map((line, index) => `<div style="text-align: ${index % 2 ? "right" : "left"};" class="scrollChat ${index % 2 ? "scrollChatRight" : "scrollChatLeft"}"><span>${line.asString}</span></div>`).join("")\n  }\n  compileTxt() {\n    return this.childrenToString()\n  }\ncodeParser\n description A code block.\n catchAllParser lineOfCodeParser\n extends abstractScrollParser\n boolean isPopular true\n javascript\n  compile() {\n   return `<code class="scrollCodeBlock">${this.childrenToString().replace(/\\</g, "&lt;")}</code>`\n  }\n  compileTxt() {\n    return this.childrenToString()\n  }\n cruxFromId\ncodeWithHeaderParser\n cruxFromId\n catchAllCellType stringCell\n extends codeParser\n javascript\n  compile() {\n   return `<div class="codeWithHeader"><div class="codeHeader">${this.content}</div>${super.compile()}</div>`\n  }\ncodeWithLanguageParser\n description Use this to specify the language of the code block, such as csvCode or rustCode.\n extends codeParser\n pattern ^[a-zA-Z0-9_]+Code$\nabstractScrollWithRequirementsParser\n extends abstractScrollParser\n cruxFromId\n javascript\n  compile(compileSettings) {\n    return this.getHtmlRequirements(compileSettings) + this.compileInstance()\n  }\ncopyButtonsParser\n extends abstractScrollWithRequirementsParser\n description Copy code widget.\n javascript\n  compileInstance() {\n   return ""\n  }\n string requireOnce\n  <script>\n  document.addEventListener("DOMContentLoaded", () => document.querySelectorAll(".scrollCodeBlock").forEach(block =>\n   {\n    if (!navigator.clipboard) return\n    const button = document.createElement("span")\n    button.classList.add("scrollCopyButton")\n    block.appendChild(button)\n    button.addEventListener("click", async () => {\n      await navigator.clipboard.writeText(block.innerText)\n      button.classList.add("scrollCopiedButton")\n    })\n   }\n  ))\n  </script>\nkatexParser\n extends abstractScrollWithRequirementsParser\n catchAllCellType codeCell\n catchAllParser lineOfCodeParser\n description KaTex widget for typeset math.\n string copyFromExternal katex.min.css katex.min.js\n string requireOnce\n  <link rel="stylesheet" href="katex.min.css">\n  <script defer src="katex.min.js"></script>\n  <script>\n  document.addEventListener("DOMContentLoaded", () => document.querySelectorAll(".scrollKatex").forEach(el =>\n   {\n    katex.render(el.innerText, el, {\n        throwOnError: false\n    });\n   }\n  ))\n  </script>\n javascript\n  compileInstance() {\n   const id = this._getUid()\n   const content = this.content === undefined ? "" : this.content\n   return `<div class="scrollKatex" id="${id}">${content + this.childrenToString()}</div>`\n  }\n  compileTxt() {\n    return ( this.content ? this.content : "" )+ this.childrenToString()\n  }\nmapParser\n inScope latParser longParser\n zoomParser\n  cells commandWordCell integerCell\n  cruxFromId\n  single\n heightParser\n  cells commandWordCell floatCell\n  cruxFromId\n  single\n pointParser\n  cells commandWordCell\n  inScope latParser longParser\n  cruxFromId\n  titleParser\n   extends abstractPointConfigParser\n  descriptionParser\n   extends abstractPointConfigParser\n extends abstractScrollWithRequirementsParser\n description Map widget.\n string copyFromExternal leaflet.css leaflet.js\n string requireOnce\n  <link rel="stylesheet" href="leaflet.css">\n  <script src="leaflet.js"></script>\n javascript\n  compileInstance() {\n   const height = 500\n   const id = this._getUid()\n   return `<div id="map${id}" style="height: ${height}px;"></div>\n  <script>\n   {\n    const lat = ${this.get("lat") ?? 37.8}\n    const long = ${this.get("long") ?? 4}\n    const zoomLevel = ${this.get("zoom") ?? 4}\n    const points = ${JSON.stringify(this.findNodes("point").map(node => node.toObject()))}\n    const map = L.map("map${id}").setView([lat, long], zoomLevel)\n    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {\n     attribution: \'<a href="https://www.openstreetmap.org/">OpenStreetMap</a>\',\n     maxZoom: 18\n    }).addTo(map)\n    points.forEach(point => {\n     L.marker([point.lat, point.long])\n      .addTo(map)\n      .bindPopup("<b>" +point.title + "</b><br />" + point.description)\n    })\n   }\n  </script>`\n  }\nhelpfulNotFoundParser\n extends abstractScrollWithRequirementsParser\n catchAllCellType filePathCell\n string copyFromExternal helpfulNotFound.js\n description Helpful not found widget.\n javascript\n  compileInstance() {\n   return `<style>#helpfulNotFound{margin: 100px 0;}</style><h1 id="helpfulNotFound"></h1><script defer src="/helpfulNotFound.js"></script><script>document.addEventListener("DOMContentLoaded", () => new NotFoundApp(\'${this.content}\'))</script>`\n  }\nabstractPlotParser\n // Observablehq\n extends abstractScrollWithRequirementsParser\n string iris\n  sepal_length,sepal_width,petal_length,petal_width,species\n  6.1,3,4.9,1.8,virginica\n  5.6,2.7,4.2,1.3,versicolor\n  5.6,2.8,4.9,2,virginica\n  6.2,2.8,4.8,1.8,virginica\n  7.7,3.8,6.7,2.2,virginica\n  5.3,3.7,1.5,0.2,setosa\n  6.2,3.4,5.4,2.3,virginica\n  4.9,2.5,4.5,1.7,virginica\n  5.1,3.5,1.4,0.2,setosa\n  5,3.4,1.5,0.2,setosa\n string copyFromExternal d3.js plot.js\n string requireOnce\n  <script src="d3.js"></script>\n  <script src="plot.js"></script>\n example\n  plot\n javascript\n  compileInstance() {\n   const id = "plot" + this._getUid()\n   return `<div id="${id}"></div><script>\n   {\n    let loadChart = async () => {\n    const data = ${this.dataCode}\n    const get = (col, index ) => col !== "undefined" ? col : (index === undefined ? undefined : Object.keys(data[0])[index])\n    document.querySelector("#${id}").append(Plot.plot(${this.plotOptions}))\n    }\n    loadChart()\n    }\n    </script>`\n  }\n  get marks() {\n    // just for testing purposes\n    return `Plot.rectY({length: 10000}, Plot.binX({y: "count"}, {x: d3.randomNormal()}))`\n  }\n  get dataCode() {\n    return \'[]\'\n  }\n  get plotOptions() {\n    return `{\n      title: "${this.get("title") || ""}",\n      subtitle: "${this.get("subtitle") || ""}",\n      caption: "${this.get("caption") || ""}",\n      symbol: {legend: ${this.has("symbol")}},\n      color: {legend: ${this.has("fill")}},\n      grid: ${this.get("grid") !== "false"},\n      marks: [${this.marks}],\n    }`\n  }\nscatterplotParser\n extends abstractPlotParser\n description Scatterplot Widget.\n // todo: make copyFromExternal work with inheritance\n string copyFromExternal d3.js plot.js\n javascript\n  get dataCode() {\n    let data = this.iris\n    const dataset = this.getNode("data")\n    const datasetContent = dataset?.content\n    const isUrl = !!datasetContent?.match(/^https?:/)\n    const fileExtension = datasetContent ? datasetContent.split(".").pop() : "csv"\n    if (dataset?.length)\n      data = dataset.childrenToString()\n    else if (datasetContent && !isUrl) {\n      const { Disk } = require("scrollsdk/products/Disk.node.js")\n      const path = require("path")\n      const {file} = this.parent\n      data = Disk.read(path.join(file.folderPath, datasetContent))\n    }\n    let dataString = `d3.${fileExtension}Parse(\\`${data}\\`, d3.autoType)`\n    if (isUrl)\n      dataString = `await d3.${fileExtension}("${datasetContent}")`\n    return dataString\n  }\n  get marks() {\n    const x = this.get("x")\n    const y = this.get("y")\n    const text = this.get("label")\n    return `Plot.dot(data, {\n      x: get("${x}", 0),\n      y: get("${y}", 1),\n      r: get("${this.get("radius")}"),\n      fill: get("${this.get("fill")}"),\n      tip: true,\n      symbol: get("${this.get("symbol")}")} ), Plot.text(data, {x: get("${x}",0), y: get("${y}", 1), text: "${text}", dy: -6, lineAnchor: "bottom"})`\n  }\nslideshowParser\n // Left and right arrows navigate.\n description Slideshow widget. *** delimits slides.\n extends abstractScrollWithRequirementsParser\n string copyFromExternal jquery-3.7.1.min.js slideshow.js\n example\n  slideshow\n  Why did the cow cross the road?\n  ***\n  Because it wanted to go to the MOOOO-vies.\n  ***\n  THE END\n  ****\n javascript\n  compile() {\n   return `<style>html {font-size: var(--base-font-size, 28px);} body {margin: auto; width: 500px;}.slideshowNav{text-align: center; margin-bottom:20px; font-size: 14px;} a{text-decoration: none;</style><script defer src="jquery-3.7.1.min.js"></script><div class="slideshowNav"></div><script defer src="slideshow.js"></script>`\n  }\nsparklineParser\n description Sparkline widget.\n extends abstractScrollWithRequirementsParser\n example\n  sparkline 1 2 3 4 5\n string copyFromExternal sparkline.js\n string requireOnce <script src="sparkline.js"></script>\n catchAllCellType numberCell\n javascript\n  compileInstance() {\n   const id = "spark" + this._getUid()\n   const data = this.content.split(" ").map(str => parseFloat(str))\n   const start = this.has("start") ? parseInt(this.get("start")) : 0\n   const width = this.get("width") || 100\n   const height = this.get("height") || 30\n   const lineColor = this.get("color") || "black"\n   return `<span id="${id}"></span><script>new Sparkline(document.getElementById("${id}"), {dotRadius: 0, width: ${width}, height: ${height}, lineColor: "${lineColor}", tooltip: (value,index) => ${start} + index + ": " + value}).draw(${JSON.stringify(data)})</script>`\n  }\ntableSearchParser\n extends abstractScrollWithRequirementsParser\n string copyFromExternal jquery-3.7.1.min.js dataTables.dataTables.min.css dataTables.min.js tableSearch.js\n string requireOnce\n  <script defer src="jquery-3.7.1.min.js"></script>\n  <style>.dt-search{font-family: "SF Pro", "Helvetica Neue", "Segoe UI", "Arial";}</style>\n  <link rel="stylesheet" href="dataTables.dataTables.min.css">\n  <script defer src="dataTables.min.js"></script>\n  <script defer src="tableSearch.js"></script>\n // adds to all tables on page\n description Table search and sort widget.\n javascript\n  compileInstance() {\n   return ""\n  }\nabstractCommentParser\n description Prints nothing.\n catchAllCellType commentCell\n cells commentCell\n extends abstractScrollParser\n baseParser blobParser\n javascript\n  compile() {\n   return ``\n  }\n catchAllParser commentLineParser\ncommentParser\n extends abstractCommentParser\n cruxFromId\nslashCommentParser\n extends commentParser\n crux //\n boolean isPopular true\n description A comment. Prints nothing.\ncounterpointParser\n description A counterpoint. Prints nothing.\n extends commentParser\n crux !\nthanksToParser\n description Acknowledge reviewers. Prints nothing.\n extends abstractCommentParser\n cruxFromId\ntabularDataParser\n description Root lines with tabs are parsed as tsv data and printed as tables.\n pattern \\t\n extends abstractCommentParser\n javascript\n  compileTxt() {\n    return ""\n  }\n  get headerNode() {\n    return this.isFirst ? this : this.previous.headerNode\n  }\n  compile() {\n    return ""\n  }\n  get isFirst() {\n    return !this.previous.isTabularData\n  }\n  get lastNode() {\n    if (this.next.isTabularData && this.next.lineNumber)\n      return this.next.lastNode\n    return this\n  }\n  applyAftertext(aftertext) {\n    const node = this.parent.appendLineAndChildren("* " + this.getLine(), aftertext + "\\ntag none")\n    const html = node.compile()\n    node.destroy()\n    return html\n  }\n  isTabularData = true\n example\n  // The below lines will print a table\n  printTable\n  Index Name\n  1 Thermos\nprintConceptsParser\n description Print concepts to HTML table.\n cruxFromId\n extends abstractScrollParser\n javascript\n   compile() {\n   // A hacky but simple way to do this for now.\n   const node = this.appendSibling("table \\t", this.parent.file.compileConcepts("concepts.tsv", this.get("sortBy")))\n   const html = node.compile()\n   node.destroy()\n   return html\n   }\ncssParser\n extends abstractScrollParser\n description A style tag.\n cruxFromId\n catchAllParser cssLineParser\n catchAllCellType cssAnyCell\n javascript\n  compile() {\n   return `<style>${this.css}</style>`\n  }\n  get css() {\n    return this.content ?? this.childrenToString()\n  }\n  compileCss() {\n    return this.css\n  }\nabstractPostLoopParser\n description Do something with all posts. Takes an optional list of folder/group names.\n extends abstractScrollParser\n cruxFromId\n cells commandWordCell\n catchAllCellType tagWithOptionalFolderCell\n javascript\n  get files() {\n   return this.root.file.getFilesWithTagsForEmbedding(this.getWordsFrom(1))\n  }\nprintFeedParser\n description Print group to RSS.\n extends abstractPostLoopParser\n example\n  printFeed index\n  printFeed cars/index\n  buildRss feed.xml\n javascript\n  compile() {\n   const dayjs = require("dayjs")\n   const file = this.root.file\n   const files = this.files.map(file => file.file)\n   const { title, baseUrl, description } = file\n   return `<?xml version="1.0" encoding="ISO-8859-1" ?>\n  <rss version="2.0">\n  <channel>\n   <title>${title}</title>\n   <link>${baseUrl}</link>\n   <description>${description}</description>\n   <lastBuildDate>${dayjs().format("ddd, DD MMM YYYY HH:mm:ss ZZ")}</lastBuildDate>\n   <language>en-us</language>\n  ${files.map(file => file.toRss()).join("\\n")}\n  </channel>\n  </rss>`\n  }\n  compileTxt() {\n    return this.compile()\n  }\nprintCsvParser\n description Print group metadata to CSV.\n extends printFeedParser\n example\n  printCsv index\n  buildTxt posts.csv\n javascript\n  compile() {\n   const file = this.root.file\n   const files = file.getFilesWithTagsForEmbedding(this.getWordsFrom(1)).map(file => file.file)\n   const header = file.csvFields\n   return `${header.join(",")}\\n${files.map(file => file.toCsv()).join("\\n")}`\n  }\nprintSourceParser\n description Print source for files in group(s).\n extends printFeedParser\n example\n  printSource index\n  buildTxt source.txt\n javascript\n  compile() {\n   const file = this.root.file\n   const files = file.getFilesWithTagsForEmbedding(this.getWordsFrom(1)).map(file => file.file)\n   return `${files.map(file => file.filePath + "\\n " + file.originalScrollCode.replace(/\\n/g, "\\n ") ).join("\\n")}`\n  }\nprintSearchTableParser\n description Prints files to HTML table.\n extends abstractPostLoopParser\n example\n  printSearchTable\n  tableSearch\n javascript\n  compile() {\n   const file = this.root.file\n   const files = this.files\n   const data = files.map(file => file.file.toSearchTsvRow(file.relativePath)).join("\\n")\n   // A hacky but simple way to do this for now.\n   const node = this.appendSibling("table \\t", "title titleLink text date wordCount minutes".replace(/ /g, "\\t") + "\\n" + data)\n   const html = node.compile()\n   node.destroy()\n   return html\n  }\nprintSiteMapParser\n extends abstractPostLoopParser\n description Print text sitemap.\n example\n  baseUrl http://test.com\n  printSiteMap\n javascript\n  compile() {\n   const file = this.root.file\n   const { baseUrl } = file\n   return this.files.map(file => baseUrl + file.relativePath + file.file.permalink).join("\\n")\n  }\n  compileTxt() {\n    return this.compile()\n  }\ndashboardParser\n description Key stats in large font.\n catchAllParser rowParser\n cruxFromId\n extends abstractScrollParser\n example\n  dashboard\n   #2 Popularity\n   30 Years Old\n   $456 Revenue\n javascript\n  get tableBody() {\n   const items = this.topDownArray\n   let str = ""\n   for (let i = 0; i < items.length; i = i + 3) {\n    str += this.makeRow(items.slice(i, i + 3))\n   }\n   return str\n  }\n  makeRow(items) {\n   return `<tr>` + items.map(node => `<td>${node.firstWord}<span>${node.content}</span></td>`).join("\\n") + `</tr>\\n`\n  }\n  compile() {\n   return `<table class="scrollDashboard">${this.tableBody}</table>`\n  }\n  compileTxt() {\n    return this.childrenToString()\n  }\nabstractTopLevelSingleMetaParser\n description Use these keywords once per file.\n extends abstractScrollParser\n inScope slashCommentParser\n cruxFromId\n cells metaCommandWordCell\n javascript\n  isTopMatter = true\n  isSetterParser = true\n  compile() {\n   return ""\n  }\ndateParser\n catchAllCellType dateCell\n description Set published date.\n extends abstractTopLevelSingleMetaParser\n boolean isPopular true\nsiteOwnerEmailParser\n description Set email address for site contact.\n extends abstractTopLevelSingleMetaParser\n crux email\n cells metaCommandWordCell emailAddressCell\nimportOnlyParser\n // This line will be not be imported into the importing file.\n description Don\'t build this file.\n cruxFromId\n cells preBuildCommandWordCell\n extends abstractTopLevelSingleMetaParser\n javascript\n  compile() {\n   return ""\n  }\nabstractUrlSettingParser\n extends abstractTopLevelSingleMetaParser\n cells metaCommandWordCell urlCell\n cruxFromId\ncanonicalUrlParser\n description Override canonical URL.\n extends abstractUrlSettingParser\nopenGraphImageParser\n // https://ogp.me/\n // If not defined, Scroll will try to generate it\'s own using the first image tag on your page.\n description Override Open Graph Image.\n extends abstractUrlSettingParser\nbaseUrlParser\n description Required for RSS and OpenGraph.\n extends abstractUrlSettingParser\ndownloadUrlParser\n description Set link to Download Page.\n extends abstractUrlSettingParser\nhomeUrlParser\n // default homelink is "index.html"\n description Override home link.\n extends abstractUrlSettingParser\nrssFeedUrlParser\n description Set RSS feed URL.\n extends abstractUrlSettingParser\nviewSourceBaseUrlParser\n description Override source link baseUrl.\n extends abstractUrlSettingParser\nhtmlLangParser\n cells metaCommandWordCell stringCell\n // for the <html lang=""> tag. If not specified will be "en". See https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/lang\n description Override HTML lang attribute.\n extends abstractTopLevelSingleMetaParser\nopenGraphDescriptionParser\n catchAllCellType stringCell\n crux description\n description Override Open Graph Description.\n extends abstractTopLevelSingleMetaParser\npermalinkParser\n description Override output filename.\n extends abstractTopLevelSingleMetaParser\n cells metaCommandWordCell permalinkCell\nscrollTagsParser\n crux tags\n description Set tags.\n example\n  tags All\n extends abstractTopLevelSingleMetaParser\n catchAllCellType tagCell\npageTitleParser\n catchAllCellType personNameCell\n crux title\n description Set title.\n extends abstractTopLevelSingleMetaParser\n boolean isPopular true\nviewSourceUrlParser\n catchAllCellType urlCell\n description Override source link.\n extends abstractTopLevelSingleMetaParser\nbelowAsCodeParser\n description Print code below.\n extends abstractScrollParser\n catchAllCellType integerCell\n cruxFromId\n javascript\n  method = "next"\n  get code() {\n   const { method } = this\n   let code = ""\n   \n   let nodes = []\n   let next = this[method]\n   let {howMany} = this\n   while (howMany) {\n    nodes.push(next)\n    next = next[method]\n    howMany--\n   }\n   if (this.reverse) nodes.reverse()\n   return nodes.map(node => node.asString).join("\\n")\n  }\n  reverse = false\n  compile() {\n   return `<code class="scrollCodeBlock">${this.code.replace(/\\</g, "&lt;")}</code>`\n  }\n  get howMany() {\n    let howMany = parseInt(this.getWord(1))\n   if (!howMany || isNaN(howMany)) howMany = 1\n   return howMany\n  }\nbelowAsCodeUntilParser\n description Print code above until match.\n extends belowAsCodeParser\n catchAllCellType anyCell\n javascript\n  get howMany() {\n    let howMany = 1\n    const query = this.content\n    let node = this.next\n    while (node !== this) {\n      if (node.getLine().startsWith(query))\n        return howMany\n      node = node.next\n      howMany++\n    }\n    return howMany\n  }\naboveAsCodeParser\n description Print code above.\n extends belowAsCodeParser\n javascript\n  method = "previous"\n  reverse = true\nabstractThemeCssParser\n description Extend this to create a Scroll CSS theme.\n extends abstractScrollParser\n inScope themeTagsParser\n cruxFromId\n catchAllCellType stringCell\n string scrollStyles\n  figure\n   margin 0\n   padding 0\n  .dropcap:first-letter\n   font-size 3rem\n   line-height .9em\n   margin-right .125rem\n   display block\n   float left\n  .dinkus\n   text-align center\n   padding 1rem\n   span\n    vertical-align sub\n  details\n   margin-top 10px\n  summary\n   font-family "SF Pro", "Helvetica Neue", "Segoe UI", "Arial"\n   cursor pointer\n  .scrollCaptionedFigure\n   display block\n   break-inside avoid\n   max-width 100%\n   text-align center\n   img\n    max-width 100%\n    height auto\n    margin-top .1875rem\n   figcaption\n    font-family "SF Pro", "Helvetica Neue", "Segoe UI", "Arial"\n    font-size .8rem\n    .scrollParagraph\n     margin-top 0\n  .scrollCodeBlock\n   overflow auto\n   font-size .8rem\n   hyphens none\n   white-space pre\n   break-inside avoid\n   display block\n   margin .5rem 0\n   padding .5rem\n   border-radius 0\n   position relative\n  .codeWithHeader\n   break-inside avoid-column\n   margin 10px 0\n  .codeHeader\n   font-size 80%\n   text-align center\n   background rgba(224, 224, 224, 0.4)\n   border 1px solid rgba(204, 204, 204, 0.8)\n   border-bottom 0\n   margin-bottom -7px\n   padding 4px 2px\n   border-top-left-radius 3px\n   border-top-right-radius 3px\n  .scrollCodeBlock:hover\n   .scrollCopyButton\n    opacity .5\n   .scrollCopyButton:hover\n    opacity .8\n   .scrollCopyButton:active\n    opacity 1\n  .scrollCopyButton\n   position absolute\n   top .125rem\n   right .125rem\n   font-size .875rem\n   cursor pointer\n   opacity 0\n  .scrollCopyButton::after\n   content "[ ]"\n  .scrollCopiedButton::after\n   content "[✓]"\n javascript\n  compile() {\n   return `<style>\\n${this.css}\\n</style>`\n  }\n  compileTxt() {\n    return ""\n  }\n  compileCss() {\n    return this.css\n  }\n  compileEmbeddedVersion() {\n   return ""\n  }\n  get scrollCss() {\n    const hakonParser = this.root.hakonParser\n    return new hakonParser(this.scrollStyles).compile()\n  }\ngazetteCssParser\n description Default Scroll theme CSS.\n extends abstractThemeCssParser\n javascript\n  get css() {\n    if (this.constructor._cachedCss)\n      return this.constructor._cachedCss\n    const hakonParser = this.root.hakonParser\n    this.constructor._cachedCss = this.scrollCss + new hakonParser([this.hakonReset, this.hakonStandardStyles].join("\\n")).compile()\n    return this.constructor._cachedCss\n  }\n // CSS Reset\n string hakonReset\n  html,body,div,span,p,ol,ul,li,table,figure\n   margin 0\n   padding 0\n   border 0\n   vertical-align baseline\n   border-spacing 0\n  ol,ul\n   padding-left 1rem\n  li\n   margin-top .4rem\n   line-height 1.4\n  a\n   text-decoration-color transparent\n   color #36c\n  a:hover\n   text-decoration-color initial\n  sup,sub\n   vertical-align baseline\n   position relative\n   top -.375rem\n  sub\n   top .375rem\n  html\n   padding .25rem\n   background-color rgb(244,244,244)\n   font-family Exchange,Georgia,serif\n   color #000\n   font-size var(--base-font-size, 16px)\n   hyphens auto\n  p\n   margin-top .4rem\n   line-height 1.4rem\n  .scrollQuote\n   break-inside avoid\n   display block\n   margin .5rem 0\n   padding .5rem\n   background rgba(204,204,204,.5)\n   white-space pre-line\n   border-left .5rem solid rgba(204,204,204,.8)\n  code\n   font-size .9rem\n   background-color rgba(204,204,204,.5)\n   padding .125rem .25rem\n   border-radius .25rem\n // Styles for Scroll standard tags\n string hakonStandardStyles\n  comment Main body of both pages is similar\n  .scrollParagraph\n   text-align justify\n  center\n   .scrollParagraph\n    text-align center\n  .scrollColumns\n   column-count auto\n   column-fill balance\n   column-width 35ch\n   column-gap 1.5rem\n   padding-left 1.25rem\n   padding-right 1.25rem\n   margin auto\n  comment On group pages add some spacing around files\n  .scrollSnippetContainer\n   padding 1ch 0\n   break-inside avoid\n   text-align justify\n  h1,h2,h3,h4\n   margin .625rem 0\n  h1\n   font-size 1.25rem\n  h2\n   font-size 1.125rem\n  h3,h4\n   font-size 1rem\n  h1.scrollTitle\n   text-align center\n   margin auto\n   margin-bottom .15625rem\n   margin-top 0\n   font-size 1.75rem\n   comment On narrow browsers like phones make sure the title doesn\'t overlap with the icons buttons in top left and right.\n   max-width calc(100vw - 2 * (1.5625rem + 1.875rem))\n   a\n    color #000\n  .scrollDateline\n   font-style italic\n   line-height 1.4rem\n   comment Decrease font size to deemphasize dateline but keep the line height the same to not cause different line spacing.\n   font-size .75rem\n  .scrollSection\n   break-inside avoid\n   h1,h2,h3,h4\n    text-align center\n  h4.scrollQuestion\n   text-align left\n   margin 1.4rem 0 0 0\n  .scrollSection:first-child\n   h1,h2,h3,h4\n    margin-top 0\n   h4.scrollQuestion\n    margin-top 0\n  .scrollNoteLink\n   opacity .4\n   text-decoration none\n   &:hover\n    opacity 1\n  .scrollFootNoteUsageLink\n   opacity .7\n   text-decoration none\n   &:hover\n    opacity 1\n  \n  .scrollHoverNote\n   text-decoration underline dashed 1px rgba(0,0,0,.1)\n   cursor default\n  \n  .scrollCodeBlock\n   border-left .5rem solid rgba(204,204,204,.8)\n  \n  .scrollTable\n   table-layout fixed\n   font-family "SF Pro", "Helvetica Neue", "Segoe UI", "Arial"\n   margin .5rem 0\n   overflow hidden\n   font-size .8rem\n   width 100%\n   hyphens none\n   border 1px solid rgba(224,224,224,.8)\n   td,th\n    padding .1875rem\n    overflow hidden\n    white-space nowrap\n   th\n    text-transform capitalize\n    border-bottom 2px solid rgba(0,0,0,.6)\n    text-align left\n   td\n    cursor zoom-in\n   tr:nth-child(even)\n    background rgba(224,224,224,.6)\n  .scrollTable\n   pre\n    white-space nowrap\n    overflow hidden\n    margin 0\n  .scrollTable.expandedTable\n   pre\n    white-space unset\n    overflow unset\n   table-layout unset\n   background white\n   position relative\n   z-index 10\n   overflow unset\n   td,th\n    overflow unset\n    white-space unset\n   td\n    cursor zoom-out\n  \n  .scrollByLine\n   font-size .875rem\n   font-style italic\n   margin .25rem 0\n   text-align center\n  \n  comment View source badge\n  .scrollViewSourceBadge\n   text-align right\n   position absolute\n   display block\n   right 20px\n   top 8px\n   svg\n    width 24px\n    height 24px\n    fill rgba(204,204,204,0.8)\n   svg:hover\n    fill #333\n  comment Subtle "Article Source" link\n  .scrollViewSource\n   text-align center\n   font-family Verdana\n   font-weight 100\n   a\n    color rgba(204,204,204,.5)\n    &:hover\n     color #333\n  \n  .scrollContinueReadingLink\n   display block\n   text-align center\n  \n  .scrollDashboard\n   width 100%\n   font-size 1.875rem\n   text-align center\n   font-weight bold\n   break-inside avoid\n   margin-top .5rem\n   margin-bottom .5rem\n   td\n    width 33.3%\n    border 1px solid #e8e8e8\n   span\n    font-size 1.25rem\n    display block\n  .scrollChat\n   span\n    font-family Verdana\n    margin-top .3125rem\n    padding .3125rem 1.25rem\n    border-radius .9375rem\n    display inline-block\n  .scrollChatLeft\n   span\n    background rgba(204,204,204, .5)\n  .scrollChatRight\n   span\n    color white\n    background rgb(0,132,255)\n  .scrollYouTubeHolder\n   position relative\n   width 100%\n   height 0\n   padding-bottom 56.25%\n  .scrollYouTubeEmbed\n   position absolute\n   top 0\n   left 0\n   width 100%\n   height 100%\ntufteCssParser\n // https://github.com/edwardtufte/tufte-css\n description Theme from Tufte CSS.\n extends abstractThemeCssParser\n javascript\n  get css() {\n    return this.scrollCss + this.tufteCss\n  }\n  tufteCss = `html {\n     font-size: 15px;\n  }\n   body {\n       width: 87.5%;\n       margin-left: auto;\n       margin-right: auto;\n       padding-left: 12.5%;\n       font-family: Palatino, "Palatino Linotype", "Palatino LT STD", "Book Antiqua", Georgia, serif;\n       background-color: #fffff8;\n       color: #111;\n       max-width: 1400px;\n       counter-reset: sidenote-counter;\n  }\n  /* Adds dark mode */\n   @media (prefers-color-scheme: dark) {\n       body {\n           background-color: #151515;\n           color: #ddd;\n      }\n  }\n   h1 {\n       font-weight: 400;\n       margin-top: 3rem;\n       margin-bottom: 1.5rem;\n       font-size: 2.4rem;\n       line-height: 1;\n  }\n  .scrollTitle a { text-decoration: none; font-size: 3.2rem;}\n  .scrollParagraph { text-align: justify; hyphens: auto;}\n  a.scrollNoteLink { text-decoration: none;}\n   h2 {\n       font-style: italic;\n       font-weight: 400;\n       margin-top: 2.1rem;\n       margin-bottom: 1.4rem;\n       font-size: 2.2rem;\n       line-height: 1;\n  }\n   h3 {\n       font-style: italic;\n       font-weight: 400;\n       font-size: 1.7rem;\n       margin-top: 2rem;\n       margin-bottom: 1.4rem;\n       line-height: 1;\n  }\n   hr {\n       display: block;\n       height: 1px;\n       width: 55%;\n       border: 0;\n       border-top: 1px solid #ccc;\n       margin: 1em 0;\n       padding: 0;\n  }\n   p.subtitle {\n       font-style: italic;\n       margin-top: 1rem;\n       margin-bottom: 1rem;\n       font-size: 1.8rem;\n       display: block;\n       line-height: 1;\n  }\n   .numeral {\n       font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;\n  }\n   .danger {\n       color: red;\n  }\n   article {\n       padding: 5rem 0rem;\n  }\n   section {\n       padding-top: 1rem;\n       padding-bottom: 1rem;\n  }\n   p, dl, ol, ul {\n       font-size: 1.4rem;\n       line-height: 2rem;\n  }\n   p {\n       margin-top: 1.4rem;\n       margin-bottom: 1.4rem;\n       padding-right: 0;\n       vertical-align: baseline;\n  }\n  /* Chapter Epigraphs */\n   div.epigraph {\n       margin: 5em 0;\n  }\n   div.epigraph > blockquote {\n       margin-top: 3em;\n       margin-bottom: 3em;\n  }\n   div.epigraph > blockquote, div.epigraph > blockquote > p {\n       font-style: italic;\n  }\n   div.epigraph > blockquote > footer {\n       font-style: normal;\n  }\n   div.epigraph > blockquote > footer > cite {\n       font-style: italic;\n  }\n  /* end chapter epigraphs styles */\n   blockquote {\n       font-size: 1.4rem;\n  }\n   blockquote p {\n       width: 55%;\n       margin-right: 40px;\n  }\n   blockquote footer {\n       width: 55%;\n       font-size: 1.1rem;\n       text-align: right;\n  }\n   section > p, section > footer, section > table {\n       width: 55%;\n  }\n  /* 50 + 5 == 55, to be the same width as paragraph */\n   section > dl, section > ol, section > ul {\n       width: 50%;\n       -webkit-padding-start: 5%;\n  }\n   dt:not(:first-child), li:not(:first-child) {\n       margin-top: 0.25rem;\n  }\n  /* Links: replicate underline that clears descenders */\n   a:link, a:visited {\n       color: inherit;\n  }\n  /* Sidenotes, margin notes, figures, captions */\n   img {\n       max-width: 100%;\n  }\n   .sidenote, .marginnote {\n       float: right;\n       clear: right;\n       margin-right: -60%;\n       width: 50%;\n       margin-top: 0.3rem;\n       margin-bottom: 0;\n       font-size: 1.1rem;\n       line-height: 1.3;\n       vertical-align: baseline;\n       position: relative;\n  }\n   .sidenote-number {\n       counter-increment: sidenote-counter;\n  }\n   .sidenote-number:after, .sidenote:before {\n       font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;\n       position: relative;\n       vertical-align: baseline;\n  }\n   .sidenote-number:after {\n       content: counter(sidenote-counter);\n       font-size: 1rem;\n       top: -0.5rem;\n       left: 0.1rem;\n  }\n   .sidenote:before {\n       content: counter(sidenote-counter) " ";\n       font-size: 1rem;\n       top: -0.5rem;\n  }\n   blockquote .sidenote, blockquote .marginnote {\n       margin-right: -82%;\n       min-width: 59%;\n       text-align: left;\n  }\n   div.fullwidth, table.fullwidth {\n       width: 100%;\n  }\n   div.table-wrapper {\n       overflow-x: auto;\n       font-family: "Trebuchet MS", "Gill Sans", "Gill Sans MT", sans-serif;\n  }\n   .sans {\n       font-family: "Gill Sans", "Gill Sans MT", Calibri, sans-serif;\n       letter-spacing: 0.03em;\n  }\n   code, pre > code {\n       font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;\n       font-size: 1rem;\n       line-height: 1.42;\n       -webkit-text-size-adjust: 100%;\n      /* Prevent adjustments of font size after orientation changes in iOS. See https://github.com/edwardtufte/tufte-css/issues/81#issuecomment-261953409 */\n  }\n   .sans > code {\n       font-size: 1.2rem;\n  }\n   h1 > code, h2 > code, h3 > code {\n       font-size: 0.8em;\n  }\n   .marginnote > code, .sidenote > code {\n       font-size: 1rem;\n  }\n   pre > code {\n       font-size: 0.9rem;\n       width: 52.5%;\n       margin-left: 2.5%;\n       overflow-x: auto;\n       display: block;\n  }\n   pre.fullwidth > code {\n       width: 90%;\n  }\n   .fullwidth {\n       max-width: 90%;\n       clear: both;\n  }\n   span.newthought {\n       font-variant: small-caps;\n       font-size: 1.2em;\n  }\n   input.margin-toggle {\n       display: none;\n  }\n   label.sidenote-number {\n       display: inline-block;\n       max-height: 2rem;\n      /* should be less than or equal to paragraph line-height */\n  }\n   label.margin-toggle:not(.sidenote-number) {\n       display: none;\n  }\n   .iframe-wrapper {\n       position: relative;\n       padding-bottom: 56.25%;\n      /* 16:9 */\n       padding-top: 25px;\n       height: 0;\n  }\n   .iframe-wrapper iframe {\n       position: absolute;\n       top: 0;\n       left: 0;\n       width: 100%;\n       height: 100%;\n  }\n   @media (max-width: 760px) {\n       body {\n           width: 84%;\n           padding-left: 8%;\n           padding-right: 8%;\n      }\n       hr, section > p, section > footer, section > table {\n           width: 100%;\n      }\n       pre > code {\n           width: 97%;\n      }\n       section > dl, section > ol, section > ul {\n           width: 90%;\n      }\n       blockquote {\n           margin-left: 1.5em;\n           margin-right: 0em;\n      }\n       blockquote p, blockquote footer {\n           width: 100%;\n      }\n       label.margin-toggle:not(.sidenote-number) {\n           display: inline;\n      }\n       .sidenote, .marginnote {\n           display: none;\n      }\n       .margin-toggle:checked + .sidenote, .margin-toggle:checked + .marginnote {\n           display: block;\n           float: left;\n           left: 1rem;\n           clear: both;\n           width: 95%;\n           margin: 1rem 2.5%;\n           vertical-align: baseline;\n           position: relative;\n      }\n       label {\n           cursor: pointer;\n      }\n       div.table-wrapper, table {\n           width: 85%;\n      }\n       img {\n           width: 100%;\n      }\n  }`\nheatrixParser\n cruxFromId\n catchAllParser heatrixCatchAllParser\n extends abstractScrollParser\n description A heatmap matrix data visualization.\n example\n  heatrix\n   table\n     \n    %h10; @2007 @2008 @2009\n     12 4 323\n   scale\n    #ebedf0 0\n    #c7e9c0 100\n    #a1d99b 400\n    #74c476 1600\n javascript\n  compile() {\n  class Heatrix {\n    static HeatrixId = 0\n    uid = Heatrix.HeatrixId++\n    constructor(program) {\n      const tree = new TreeNode(program)\n      this.program = tree\n      const table = tree.getNode("table").childrenToString()\n      const scale = tree.getNode("scale")?.childrenToString() || "transparent 1"\n      const thresholds = []\n      const colors = []\n      scale.split("\\n").map((line) => {\n        const parts = line.split(" ")\n        thresholds.push(parseFloat(parts[1]))\n        colors.push(parts[0])\n      })\n      const colorCount = colors.length\n      const colorFunction = (value) => {\n        if (isNaN(value)) return "" // #ebedf0\n        for (let index = 0; index < colorCount; index++) {\n          const threshold = thresholds[index]\n          if (value <= threshold) return colors[index]\n        }\n        return colors[colorCount - 1]\n      }\n      const {globalStyles} = this\n      const directiveDelimiter = ";"\n      const getSize = (directives, prefix) =>\n        directives\n          .filter((directive) => directive.startsWith(prefix))\n          .map((dir) => dir.replace(prefix, "") + "px")[0] ?? ""\n      this.table = table.split("\\n").map((line) =>\n        line\n          .trimEnd()\n          .split(" ")\n          .map((cell) => {\n            const words = cell.split(directiveDelimiter).filter((word) => !word.startsWith("%"))\n            const directives = cell\n              .split(directiveDelimiter)\n              .filter((word) => word.startsWith("%"))\n            const value = parseFloat(words[0])\n            let label = ""\n            if (words[0]) {\n              label = words.join(" ").replace(/^@/, "") // Temporary way to force a string.\n            }\n            const alignment = directives.includes("%right")\n              ? "right"\n              : directives.includes("%left")\n              ? "left"\n              : ""\n            const color = colorFunction(value)\n            const width = getSize(directives, "%w") || globalStyles.width\n            const height = getSize(directives, "%h") || globalStyles.height\n            const fontSize = getSize(directives, "%fs") || globalStyles["font-size"]\n            const lineHeight = getSize(directives, "%lh") || height\n            const style = {\n              "background-color": color,\n              width,\n              height,\n              "font-size": fontSize,\n              "line-height": lineHeight,\n              "text-align": alignment,\n            }\n            Object.keys(style).filter(key => !style[key]).forEach((key) => delete style[key])\n            return {\n              value,\n              label,\n              style,\n            }\n          })\n      )\n    }\n    get globalStyles() {\n     return this.program.getNode("style")?.asObject || {}\n    }\n    get html() {\n      const { program } = this\n      const cssId = `#heatrix${this.uid}`\n      const {globalStyles} = this\n      \n      const defaultWidth = globalStyles.width || "40px"\n      const defaultHeight = globalStyles.height || "40px"\n      const fontSize = globalStyles["font-size"] || "10px"\n      const lineHeight = globalStyles["line-height"] || defaultHeight\n      const style = `<style>\n      .heatrixContainer {\n        margin: auto;\n      }.heatrixRow {white-space: nowrap;}\n  ${cssId} .heatrixCell {\n    font-family: arial;\n    border-radius: 2px;\n    border: 1px solid transparent;\n    display: inline-block;\n    margin: 1px;\n    text-align: center;\n    vertical-align: middle;\n    overflow: hidden;\n    text-overflow: ellipsis;\n  }\n  .heatrixCell a {\n    color: black;\n  }\n  ${cssId} .heatrixCell{\n   width: ${defaultWidth};\n   height: ${defaultHeight};\n   font-size: ${fontSize};\n   line-height: ${lineHeight};\n  }\n  </style>`\n      const firstRow = this.table[0]\n      return (\n        `<div class="heatrixContainer" id="heatrix${this.uid}">${style}` +\n        this.table\n          .map((row, rowIndex) => {\n            if (!rowIndex) return ""\n            const rowStyle = row[0].style\n            return `<div class="heatrixRow heatrixRow${rowIndex}">${row\n              .map((cell, columnIndex) => {\n                if (!columnIndex) return ""\n                const columnStyle = firstRow[columnIndex]?.style || {}\n                let { value, label, style } = cell\n                if (label === "0") label = "0"\n                const extendedStyle = Object.assign(\n                  {},\n                  rowStyle,\n                  columnStyle,\n                  style\n                )\n                const inlineStyle = Object.keys(extendedStyle)\n                  .map((key) => `${key}:${extendedStyle[key]};`)\n                  .join("")\n                let valueClass = value ? " valueCell" : ""\n                return `<div class="heatrixCell heatrixColumn${columnIndex}${valueClass}" style="${inlineStyle}"><span title="${label}">${label}</span></div>`\n              })\n              .join("")}</div>`\n          })\n          .join("\\n") +\n        "</div>"\n      ).replace(/\\n/g, "")\n    }\n  }\n    return new Heatrix(this.childrenToString().trim()).html\n  }\nabstractHtmlParser\n extends abstractScrollParser\n catchAllParser htmlLineParser\n catchAllCellType htmlAnyCell\n javascript\n  compile() {\n   return `${this.content ?? ""}${this.childrenToString()}`\n  }\n  compileTxt() {\n    return ""\n  }\nhtmlParser\n extends abstractHtmlParser\n description HTML one liners or blocks.\n cruxFromId\nhtmlInlineParser\n extends abstractHtmlParser\n cells htmlAnyCell\n pattern ^<\n description Inline HTML.\n boolean isPopular true\n javascript\n  compile() {\n   return `${this.getLine() ?? ""}${this.childrenToString()}`\n  }\nstumpParser\n cruxFromId\n extends abstractScrollParser\n description Compile Stump to HTML.\n catchAllParser stumpContentParser\n javascript\n  compile() {\n   const file = this.parent.file\n   return file.compileStumpCode(this.childrenToString())\n  }\nstumpNoSnippetParser\n // todo: make noSnippets an aftertext directive?\n extends stumpParser\n description Compile Stump unless snippet.\n cruxFromId\n javascript\n  compileEmbeddedVersion() {\n   return ""\n  }\nabstractCaptionedParser\n extends abstractScrollParser\n cells commandWordCell urlCell\n inScope captionAftertextParser slashCommentParser\n cruxFromId\n javascript\n  compile(compileSettings) {\n   const caption = this.getNode("caption")\n   const captionFig = caption ? `<figcaption>${caption.compile()}</figcaption>` : ""\n   const {figureWidth} = this\n   const widthStyle = figureWidth ? `width:${figureWidth}px; margin: auto;` : ""\n   const float = this.has("float") ? `margin: 20px; float: ${this.get("float")};` : ""\n   return `<figure class="scrollCaptionedFigure" style="${widthStyle + float}">${this.getFigureContent(compileSettings)}${captionFig}</figure>`\n  }\n  get figureWidth() {\n    return this.get("width")\n  }\nimageParser\n description An img tag.\n boolean isPopular true\n extends abstractCaptionedParser\n inScope classMarkupParser aftertextIdParser linkParser linkTargetParser\n openGraphParser\n  description Add this line to make this the open graph image.\n  cruxFromId\n  cells commandWordCell\n javascript\n  get dimensions() {\n    const width = this.get("width")\n    const height = this.get("height")\n    if (width || height)\n      return {width, height}\n    if (!this.isNodeJs())\n      return {}\n    const src = this.getWord(1)\n    // If its a local image, get the dimensions and put them in the HTML\n    // to avoid flicker\n   if (src.startsWith("http:") || src.startsWith("https:")) return {}\n   const file = this.root.file\n    if (this._dimensions)\n      return this._dimensions\n    try {\n     const sizeOf = require("image-size")\n     const path = require("path")\n     const fullImagePath = path.join(file.folderPath, src)\n     this._dimensions = sizeOf(fullImagePath)\n     return this._dimensions\n    } catch (err) {\n     console.error(err)\n    }\n    return {}\n  }\n  get figureWidth() {\n    return this.dimensions.width\n  }\n  getFigureContent(compileSettings) {\n   const file = this.root.file\n   const linkRelativeToCompileTarget = (compileSettings ? (compileSettings.relativePath ?? "") : "") + this.getWord(1)\n   const {width, height} = this.dimensions\n   let dimensionAttributes = width || height  ? `width="${width}" height="${height}" ` : ""\n   // Todo: can we reuse more code from aftertext?\n   const className = this.has("class") ? ` class="${this.get("class")}" ` : ""\n   const id = this.has("id") ? ` id="${this.get("id")}" ` : ""\n   const clickLink = this.get("link") || linkRelativeToCompileTarget\n   const target = this.has("target") ? this.get("target") : (this.has("link") ? "" : "_blank")\n   return `<a href="${clickLink}" target="${target}" ${className} ${id}><img src="${linkRelativeToCompileTarget}" ${dimensionAttributes}loading="lazy"></a>`\n  }\n  compileTxt() {\n    const children = this.filter(node => node.compileTxt).map(node => node.compileTxt()).filter(i => i).join("\\n")\n    return  "[Image Omitted]" + (children ? "\\n " + children.replace(/\\n/g, "\\n ") : "")\n  }\nyouTubeParser\n extends abstractCaptionedParser\n // Include the YouTube embed URL such as https://www.youtube.com/embed/CYPYZnVQoLg\n description A YouTube video widget.\n javascript\n  getFigureContent() {\n   const url = this.getWord(1).replace("youtube.com/watch?v=", "youtube.com/embed/")\n   return `<div class="scrollYouTubeHolder"><iframe class="scrollYouTubeEmbed" src="${url}" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>`\n  }\nimportParser\n description Import a file.\n cruxFromId\n boolean isPopular true\n cells preBuildCommandWordCell\n extends abstractScrollParser\n catchAllCellType filePathCell\n javascript\n  compile() {\n   return ""\n  }\n example\n  import header.scroll\nkeyboardNavParser\n description Make left and right navigate files.\n extends abstractScrollParser\n cruxFromId\n catchAllCellType urlCell\n javascript\n  compileEmbeddedVersion() {\n   return ""\n  }\n  compile() {\n   const file = this.root.file\n   const linkToPrevious = this.getWord(1) ?? file.linkToPrevious\n   const linkToNext = this.getWord(2) ?? file.linkToNext\n   const script = `<script>document.addEventListener(\'keydown\', function(event) {\n    if (document.activeElement !== document.body) return\n    const getLinks = () => document.getElementsByClassName("scrollKeyboardNav")[0].getElementsByTagName("a")\n    if (event.key === "ArrowLeft")\n      getLinks()[0].click()\n    else if (event.key === "ArrowRight")\n      getLinks()[1].click()\n   });</script>`\n   return `<div class="scrollKeyboardNav" style="display:none;"><a href="${linkToPrevious}">${linkToPrevious}</a> · ${file.permalink} · <a href="${linkToNext}">${linkToNext}</a>${script}</div>`\n  }\nprintUsageStatsParser\n // todo: if we include the word "Parser" in a crux, bad things seem to happen.\n description Print parser usage stats in folder.\n extends abstractScrollParser\n cruxFromId\n javascript\n  get stats() {\n   const input = this.root.file.allScrollFiles.map(file => file.parserIds.join("\\n")).join("\\n")\n   const result = input.split(\'\\n\').reduce((acc, word) => (acc[word] = (acc[word] || 0) + 1, acc), {})\n   return "parserId uses\\n" + Object.entries(result).map(([word, count]) => `${word} ${count}`).join(\'\\n\')\n  }\n  compile() {\n    // A hacky but simple way to do this for now.\n   const node = this.appendSibling("table  ", this.stats)\n   const html = node.compile()\n   node.destroy()\n   return html\n  }\n  compileTxt() {\n    return this.stats\n  }\nprintLeetSheetParser\n description Print Scroll parser leet sheet.\n extends abstractScrollParser\n cruxFromId\n javascript\n  get parsersToDocument() {\n    const clone = this.root.clone()\n    clone.setChildren("")\n    const words = clone.getAutocompleteResultsAt(0,0).matches.map(a => a.text)\n    words.push("blankline") // manually add blank line\n    words.push("Catch All Paragraph.") // manually add catch all paragraph\n    words.push("<h></h>") // manually add html\n    words.sort()\n    clone.setChildren(words.join("\\n").replace(/blankline/, "")) // insert blank line in right spot\n    return clone\n  }\n  sortDocs(docs) {\n    return docs.map(node => {\n      const {definition} = node\n      const {id, description, isPopular} = definition\n      return {id: definition.cruxIfAny || id, description, isPopular}\n     }).sort((a, b) => a.id.localeCompare(b.id))\n  }\n  docToHtml(doc) {\n   const css = `#scrollLeetSheet {color: grey;} #scrollLeetSheet a {color: #3498db; }`\n   return `<style>${css}</style><div id="scrollLeetSheet">` + doc.map(obj => `<div><a>${obj.isPopular ? "<b>" : ""}${obj.id}</a> ${obj.description}${obj.isPopular ? "</b>" : ""}</div>`).join("\\n") + "</div>"\n  }\n  compile() {\n    return this.docToHtml(this.sortDocs(this.parsersToDocument))\n  }\n  compileTxt() {\n   return this.sortDocs(this.parsersToDocument).map(obj => `${obj.id} - ${obj.description}`).join("\\n")\n  }\nprintAdvancedLeetSheetParser\n extends printLeetSheetParser\n description Print Parsers leet sheet.\n javascript\n  compile() {\n    return "<p><b>Line Parsers</b> match lines and parse them.</p><br>" + this.docToHtml(this.sortDocs(this.parsersToDocument)) + "<p><b>Cell Parsers</b> parse words in a line.</p><br>" + this.docToHtml(this.sortDocs(this.cellParsersToDocument))\n  }\n  get cellParsersToDocument() {\n    const parsersParser = require("scrollsdk/products/parsers.nodejs.js")\n    const clone = new parsersParser("anyCell\\n ").clone()\n    const parserNode = clone.getNode("anyCell")\n    const words = clone.getAutocompleteResultsAt(1,1).matches.map(a => a.text)\n    words.sort()\n    parserNode.setChildren(words.join("\\n"))\n    return parserNode\n  }\n  get parsersToDocument() {\n    const parsersParser = require("scrollsdk/products/parsers.nodejs.js")\n    const clone = new parsersParser("latinParser\\n ").clone()\n    const parserNode = clone.getNode("latinParser")\n    const words = clone.getAutocompleteResultsAt(1,1).matches.map(a => a.text)\n    words.sort()\n    parserNode.setChildren(words.join("\\n"))\n    return parserNode\n  }\nprintMeasuresParser\n description Print measure stats to HTML table.\n cruxFromId\n extends abstractScrollParser\n javascript\n   compile() {\n   // A hacky but simple way to do this for now.\n   const node = this.appendSibling("table \\t", this.parent.file.compileMeasures("tsv"))\n   const html = node.compile()\n   node.destroy()\n   return html\n   }\nabstractMeasureParser\n cells measureNameCell\n cruxFromId\n boolean isMeasure true\n float sortIndex 1.9\n boolean isComputed false\n string typeForCsvDocs unspecified\n extends abstractScrollParser\n javascript\n  compileEmbeddedVersion() {\n   return ""\n  }\n  compile() {\n   return ""\n  }\n  get measureValue() {\n    return this.content ?? ""\n  }\n  get measureName() {\n    return this.getFirstWordPath().replace(/ /g, "_")\n  }\nabstractWordMeasureParser\n description A measure that contains a single word.\n cells measureNameCell wordCell\n string typeForCsvDocs word\n extends abstractMeasureParser\nabstractUrlMeasureParser\n string typeForCsvDocs url\n cells measureNameCell urlCell\n extends abstractWordMeasureParser\nabstractStringMeasureParser\n string typeForCsvDocs string\n catchAllCellType stringCell\n extends abstractMeasureParser\nabstractIdParser\n crux id\n description What is the ID of this concept?\n extends abstractStringMeasureParser\n float sortIndex 1\n boolean isMeasureRequired true\n boolean isConceptDelimiter true\n javascript\n  getErrors() {\n    const errors = super.getErrors()\n    let requiredMeasureNames = this.parent.file.measures.filter(measure => measure.isMeasureRequired).map(measure => measure.Name).filter(name => name !== "id")\n    if (!requiredMeasureNames.length) return errors\n    let next = this.next\n    while (requiredMeasureNames.length && next.firstWord !== "id" && next.getIndex() !== 0) {\n      requiredMeasureNames = requiredMeasureNames.filter(i => i !== next.firstWord)\n      next = next.next\n    }\n    requiredMeasureNames.forEach(name => {\n      errors.push({toObject: () => {return { message: `Concept "${this.content}" is missing required measure "${name}".`}}})\n    })\n    return errors\n  }\nabstractNumericMeasureParser\n string typeForCsvDocs number\n extends abstractMeasureParser\n javascript\n  get measureValue() {\n    const {content} = this\n    return content === undefined ? "" : parseFloat(content)\n  }\nabstractIntegerMeasureParser\n string typeForCsvDocs integer\n cells measureNameCell integerCell\n extends abstractNumericMeasureParser\nabstractFloatMeasureParser\n cells measureNameCell floatCell\n extends abstractNumericMeasureParser\nabstractPercentageMeasureParser\n cells measureNameCell percentCell\n extends abstractNumericMeasureParser\n javascript\n  get measureValue() {\n    const {content} = this\n    return content === undefined ? "" : parseFloat(content)\n  }\nabstractEnumMeasureParser\n string typeForCsvDocs enum\n cells measureNameCell enumCell\n extends abstractMeasureParser\nabstractBooleanMeasureParser\n string typeForCsvDocs boolean\n cells measureNameCell booleanCell\n extends abstractMeasureParser\n javascript\n  get measureValue() {\n    const {content} = this\n    return content === undefined ? "" : content == "true"\n  }\nmetaTagsParser\n cruxFromId\n extends abstractScrollParser\n description Print meta tags including title.\n javascript\n  compileEmbeddedVersion() {\n   return ""\n  }\n  compile() {\n   const { file } = this.parent\n   const { title, description, openGraphImage, SCROLL_VERSION, canonicalUrl } = file\n   const rssFeedUrl = this.parent.get("rssFeedUrl")\n   let rssTag = ""\n   if (rssFeedUrl)\n    rssTag = `<link rel="alternate" type="application/rss+xml" title="${title}" href="${rssFeedUrl}">`\n   // todo: cleanup the head/body stuff.\n   return `<head>\n   <meta charset="utf-8">\n   <title>${title}</title>\n   <script>/* This HTML was generated by 📜 Scroll v${SCROLL_VERSION}. https://scroll.pub */</script>\n   <style>@media print {.doNotPrint {display: none !important;}}</style>\n   <link rel="canonical" href="${canonicalUrl}">\n   <meta name="viewport" content="width=device-width,initial-scale=1">\n   <meta name="description" content="${description}">\n   <meta name="generator" content="Scroll v${SCROLL_VERSION}">\n   <meta property="og:title" content="${title}">\n   <meta property="og:description" content="${description}">\n   <meta property="og:image" content="${openGraphImage}">\n   ${rssTag}\n   <meta name="twitter:card" content="summary_large_image">\n  </head>\n  <body>`\n  }\npageFooterParser\n cruxFromId\n description HTML footer.\n extends abstractScrollParser\n string hakon\n  .pageFooter\n   margin-top 8px\n   padding-top 8px\n   text-align center\n   svg\n    width 30px\n    height 30px\n    fill rgba(204,204,204, .5)\n    padding 0 7px\n    &:hover\n     fill #333\n  .pageFooterScrollLink\n   font-family Verdana\n   font-weight 100\n   margin .5em\n   a\n    color rgba(204,204,204,.5)\n    &:hover\n     color #333\n     text-decoration none\n javascript\n  compileEmbeddedVersion() {\n   return ""\n  }\n  get css() {\n    const hakonParser = this.root.hakonParser\n    return new hakonParser(this.hakon).compile()\n  }\n  compile() {\n   const file = this.parent.file\n   const { SVGS, SCROLL_VERSION, viewSourceUrl } = file\n   const closeContainerTag = "</div>"\n   const emailLink = file.email ? `a ${SVGS.email}\n    href mailto:${file.email}` : ""\n   const downloadLink = file.downloadUrl ? `a ${SVGS.download}\n    href ${file.downloadUrl}` : ""\n   const gitLink = file.viewSourceUrl ? `a ${SVGS.git}\n    title View Source\n    href ${file.viewSourceUrl}` : ""\n   return (\n    closeContainerTag + `<style>${this.css}</style>` +\n    file.compileStumpCode(`p\n   class scrollViewSource doNotPrint\n  div\n   class pageFooter doNotPrint\n   ${emailLink}\n   ${downloadLink}\n   ${gitLink}\n   div\n    class pageFooterScrollLink\n    a Built with Scroll v${SCROLL_VERSION}\n     href https://scroll.pub`)\n   )\n  }\npageHeaderParser\n cruxFromId\n description HTML footer.\n extends abstractScrollParser\n string hakon\n  .pageHeader\n   position absolute\n   top .25rem\n   right 0\n   left 0\n   svg\n    width 1.875rem\n    height 1.875rem\n    fill rgba(204,204,204,.8)\n    &:hover\n     fill #333\n   a\n    color rgba(204,204,204,.8)\n    position absolute\n    font-size 1.875rem\n    line-height 1.7rem\n    text-decoration none\n    &:hover\n     color #333\n javascript\n  compileEmbeddedVersion() {\n   return ""\n  }\n  get css() {\n    const hakonParser = this.root.hakonParser\n    return new hakonParser(this.hakon).compile()\n  }\n  compile() {\n   const file = this.parent.file\n   const { SVGS, linkToPrevious, linkToNext, viewSourceUrl } = file\n   let previousButton = ""\n   if (linkToPrevious)\n    previousButton = `a &lt;\n    style left:.1875rem;\n    href ${linkToPrevious}`\n   let nextButton = ""\n   if (linkToNext)\n    nextButton = `a &gt;\n    style right:.1875rem;\n    href ${linkToNext}`\n   const gitLink = file.viewSourceUrl ? `a ${SVGS.git}\n    style text-align:right;right: 1.5625rem;\n    title View Source\n    href ${file.viewSourceUrl}` : ""\n   return `<style>\\n${this.css}\\n</style>` + file.compileStumpCode(`div\n   class pageHeader doNotPrint\n   ${previousButton}\n   a ${SVGS.home}\n    style text-align:left;left:1.5625rem;\n    href ${file.get("homeUrl") || "index.html"}\n   ${gitLink}\n   ${nextButton}`)\n  }\nscrollParserDefinitionParser\n extends abstractScrollParser\n // todo Figure out best pattern for merging Scroll and Parsers?\n pattern ^[a-zA-Z0-9_]+Parser$\n description Define your own Parsers.\n baseParser blobParser\n javascript\n  compile() {\n   return ""\n  }\nquoteParser\n cruxFromId\n description A quote.\n catchAllParser quoteLineParser\n extends abstractScrollParser\n javascript\n  compile() {\n   return `<blockquote class="scrollQuote">${this.childrenToString()}</blockquote>`\n  }\n  compileTxt() {\n    return this.childrenToString()\n  }\nreadingListParser\n extends abstractScrollParser\n description Link list with titles and authors.\n cells commandWordCell\n cruxFromId\n catchAllParser readingListItemParser\n example\n  readingList\n   https://example.com/similar by Author Name\n javascript\n  compile() {\n   return `<br><ul>${this.map(child => child.compile()).join("\\n")}</ul>`\n  }\nredirectToParser\n description HTML redirect tag.\n extends abstractScrollParser\n cells commandWordCell urlCell\n cruxFromId\n example\n  redirectTo https://scroll.pub/releaseNotes.html\n javascript\n  compile() {\n   return `<meta http-equiv="Refresh" content="0; url=\'${this.getWord(1)}\'" />`\n  }\nabstractVariableParser\n extends abstractScrollParser\n catchAllCellType stringCell\n cells preBuildCommandWordCell\n cruxFromId\n javascript\n  isTopMatter = true\n  compile() {\n   return ""\n  }\nreplaceParser\n description Replace this with that.\n extends abstractVariableParser\n baseParser blobParser\n example\n  replace YEAR 2022\nreplaceJsParser\n description Replace this with evaled JS.\n extends replaceParser\n catchAllCellType javascriptCell\n example\n  replaceJs SUM 1+1\n  * 1+1 = SUM\nreplaceNodejsParser\n description Replace this with evaled Node.JS.\n extends abstractVariableParser\n catchAllCellType javascriptCell\n baseParser blobParser\n example\n  replaceNodejs\n   module.exports = {SCORE : 1 + 2}\n  * The score is SCORE\nscriptParser\n extends abstractScrollParser\n description Print script tag.\n cruxFromId\n catchAllParser scriptLineParser\n catchAllCellType scriptAnyCell\n javascript\n  compile() {\n   return `<script>${this.scriptContent}</script>`\n  }\n  get scriptContent() {\n    return this.content ?? this.childrenToString()\n  }\n  compileJs() {\n    return this.scriptContent\n  }\nendSnippetParser\n description Cut for snippet here.\n extends abstractScrollParser\n cruxFromId\n javascript\n  compile() {\n   return ""\n  }\nstampParser\n description Expand project template to disk.\n extends abstractScrollParser\n inScope stampFolderParser\n catchAllParser stampFileParser\n example\n  stamp\n   .gitignore\n    *.html\n   readme.scroll\n    # Hello world\n    <script src="scripts/nested/hello.js"></script>\n   scripts/\n    nested/\n     hello.js\n      console.log("Hello world")\n cruxFromId\n cells preBuildCommandWordCell\n javascript\n  build() {\n    const dir = this.root.file.folderPath\n    this.forEach(node => node.build(dir))\n  }\nabstractTableParser\n cruxFromId\n catchAllParser rowParser\n extends abstractScrollParser\n javascript\n  get tableHeader() {\n   return this.columns.filter(col => !col.isLink).map(column => `<th>${column.name}</th>\\n`)\n  }\n  get columnNames() {\n   const header = this.nodeAt(0)\n   return header ? header.getLine().split(this.delimiter) : []\n  }\n  get columns() {\n   const cols = this.columnNames\n   return cols.map((name, index) => {\n    const isLink = name.endsWith("Link")\n    const linkIndex = cols.indexOf(name + "Link")\n    return {\n     name,\n     isLink,\n     linkIndex\n    }\n   })\n  }\n  get tableBody() {\n   const { delimiter } = this\n   return this.topDownArray\n    .slice(1)\n    .map(node => `<tr>${node.toRow(this.columns, delimiter)}</tr>`)\n    .join("\\n")\n  }\n  compile() {\n   return `<table id="table${this._getUid()}" class="scrollTable">\n   <thead><tr>${this.tableHeader.join("\\n")}</tr></thead>\n   <tbody>${this.tableBody}</tbody>\n   </table>\n   <script>\n   document.querySelector(\'#table${this._getUid()}\').addEventListener(\'click\', e => {\n    if (window.getSelection().toString() || e.target.closest(\'a\') || !e.target.closest(\'tbody\')) return;\n    e.currentTarget.classList.toggle(\'expandedTable\');\n   });\n   </script>`\n  }\n  compileTxt() {\n    return this.childrenToString()\n  }\ntableParser\n description A table from a custom delimiter.\n extends abstractTableParser\n catchAllCellType anyCell\n javascript\n  get delimiter() {\n   return this.content ?? ""\n  }\ncommaTableParser\n description A table from CSV data.\n extends abstractTableParser\n string delimiter ,\npipeTableParser\n description A table from |SV data.\n extends abstractTableParser\n string delimiter |\nspaceTableParser\n description A table. Last column is catchall.\n extends abstractTableParser\n string delimiter  \ntabTableParser\n description A table from TSV data.\n extends abstractTableParser\n string delimiter \\t\ntreeTableParser\n // Useful when a column contains a text blob.\n description Table from Scroll Notation data.\n extends abstractTableParser\n catchAllParser treeRowParser\n javascript\n  get columnNames() {\n   return this._getUnionNames()\n  }\n  get tableBody() {\n   return this.map(node => `<tr>${node.toRow(this.columns)}</tr>`).join("\\n")\n  }\n example\n  treeTable\n   row\n    name Javascript\n    example\n     console.log("Hello world")\n   row\n    name Python\n    example\n     print "Hello world"\nprintTableParser\n description Print table from tabular data.\n cruxFromId\n catchAllCellType integerCell\n extends abstractScrollParser\n javascript\n   compile() {\n    const node = this.appendSibling("table \\t", this.tsv)\n    const html = node.compile()\n    node.destroy()\n    return html\n   }\n   getTableByIndex(index) {\n      const hit = this.root.file.tables[parseInt(index)]\n      if (!hit)\n        console.error(`Table "${index}" not found`)\n      return hit\n   }\n   get table() {\n     const index = this.getWord(1)\n     if (index !== undefined)\n        return this.getTableByIndex(index)\n     if (this.next.isTabularData)\n       return this.next\n     if (this.previous.isTabularData)\n       return this.previous.headerNode\n    return this.getTableByIndex(0)\n   }\n   get tsv() {\n    const firstNode = this.table\n    const lastNode = firstNode.lastNode\n    const aftertext = lastNode.childrenToString() // todo: we could be more specific and ignore comments\n    let tableNode = firstNode\n    let tsv = tableNode.getLine()\n    while (tableNode.next.isTabularData) {\n      tsv += "\\n" + (aftertext ? tableNode.next.applyAftertext(aftertext) : tableNode.next.getLine())\n      tableNode = tableNode.next\n      if (tableNode === firstNode)\n        break\n    }\n     return tsv\n   }\n   compileTxt() {\n     return this.tsv\n   }\nplainTextParser\n description Plain text oneliner or block.\n cruxFromId\n extends abstractScrollParser\n catchAllParser plainTextLineParser\n catchAllCellType stringCell\n javascript\n  compile() {\n   return this.compileTxt()\n  }\n  compileTxt() {\n    return `${this.content ?? ""}${this.childrenToString()}`\n  }\nplainTextOnlyParser\n extends plainTextParser\n description Only print for buildTxt.\n javascript\n  compile() {\n   return ""\n  }\nabstractAftertextAttributeParser\n cells commandWordCell\n boolean isAttribute true\n javascript\n  get divAttributes() {\n   return `${this.firstWord}="${this.content}"`\n  }\n  compile() {\n   return ""\n  }\naftertextIdParser\n crux id\n description Provide an ID to be output in the generated HTML tag.\n extends abstractAftertextAttributeParser\n cells commandWordCell htmlIdCell\n single\naftertextStyleParser\n crux style\n description Provide code for the generated HTML tag\'s "style" attribute.\n extends abstractAftertextAttributeParser\n cells commandWordCell\n catchAllCellType cssAnyCell\naftertextHiddenParser\n crux hidden\n cells commandWordCell\n description Do not compile this node to HTML.\n extends abstractAftertextAttributeParser\n single\naftertextTagParser\n cells commandWordCell htmlTagCell\n description Override the HTML tag that the compiled node will use.\n crux tag\n javascript\n  compile() {\n   return ""\n  }\nabstractAftertextDirectiveParser\n cells commandWordCell\n catchAllCellType stringCell\n javascript\n  isMarkup = true\n  compile() {\n   return ""\n  }\n  getErrors() {\n    const errors = super.getErrors()\n    if (!this.isMarkup || this.matchWholeLine) return errors\n    const inserts = this.getInserts(this.parent.originalTextPostLinkify)\n    // todo: make AbstractTreeError class exported by sdk to allow Parsers to define their own error types.\n    // todo: also need to be able to map lines back to their line in source (pre-imports)\n    if (!inserts.length)\n      errors.push({toObject: () => {return { message: `No match found for "${this.getLine()}".`}}})\n    return errors\n  }\n  get pattern() {\n   return this.getWordsFrom(1).join(" ")\n  }\n  get shouldMatchAll() {\n   return this.has("matchAll")\n  }\n  getMatches(text) {\n   const { pattern } = this\n   const escapedPattern = pattern.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, "\\\\$&")\n   return [...text.matchAll(new RegExp(escapedPattern, "g"))].map(match => {\n    const { index } = match\n    const endIndex = index + pattern.length\n    return [\n     { index, string: `<${this.openTag}${this.allAttributes}>`, endIndex },\n     { index: endIndex, endIndex, string: `</${this.closeTag}>` }\n    ]\n   })\n  }\n  getInserts(text) {\n   const matches = this.getMatches(text)\n   if (!matches.length) return false\n   if (this.shouldMatchAll) return matches.flat()\n   const match = this.getNode("match")\n   if (match)\n    return match.indexes\n     .map(index => matches[index])\n     .filter(i => i)\n     .flat()\n   return matches[0]\n  }\n  get allAttributes() {\n   const attr = this.attributes.join(" ")\n   return attr ? " " + attr : ""\n  }\n  get attributes() {\n   return []\n  }\n  get openTag() {\n   return this.tag\n  }\n  get closeTag() {\n   return this.tag\n  }\nabstractMarkupParser\n extends abstractAftertextDirectiveParser\n inScope abstractMarkupParameterParser\n javascript\n  get matchWholeLine() {\n    return this.getWordsFrom(this.patternStartsAtWord).length === 0\n  }\n  get pattern() {\n   return this.matchWholeLine ? this.parent.originalText : this.getWordsFrom(this.patternStartsAtWord).join(" ")\n  }\n  patternStartsAtWord = 1\nboldParser\n cruxFromId\n description Bold matching text.\n extends abstractMarkupParser\n javascript\n  tag = "b"\nitalicsParser\n cruxFromId\n description Italicize matching text.\n extends abstractMarkupParser\n javascript\n  tag = "i"\nunderlineParser\n description Underline matching text.\n cruxFromId\n extends abstractMarkupParser\n javascript\n  tag = "u"\nafterTextCenterParser\n description Center paragraph.\n crux center\n extends abstractMarkupParser\n javascript\n  tag = "center"\naftertextCodeParser\n description Wrap matching text in code span.\n crux code\n extends abstractMarkupParser\n javascript\n  tag = "code"\naftertextStrikeParser\n description Wrap matching text in s span.\n crux strike\n extends abstractMarkupParser\n javascript\n  tag = "s"\nclassMarkupParser\n description Add a custom class to the parent element instead. If matching text provided, a span with the class will be added around the matching text.\n extends abstractMarkupParser\n cells commandWordCell classNameCell\n crux class\n javascript\n  tag = "span"\n  get applyToParentElement() {\n   return this.words.length === 2\n  }\n  getInserts(text) {\n   // If no select text is added, set the class on the parent element.\n   if (this.applyToParentElement) return []\n   return super.getInserts(text)\n  }\n  get className() {\n   return this.getWord(1)\n  }\n  get attributes() {\n   return [`class="${this.className}"`]\n  }\n  get matchWholeLine() {\n    return this.applyToParentElement\n  }\n  get pattern() {\n   return this.matchWholeLine ? this.parent.content : this.getWordsFrom(2).join(" ")\n  }\nclassesMarkupParser\n extends classMarkupParser\n crux classes\n javascript\n  applyToParentElement = true\n  get className() {\n   return this.content\n  }\nhoverNoteParser\n description Add a caveat viewable on hover on matching text. When you want to be sure you\'ve thoroughly addressed obvious concerns but ones that don\'t warrant to distract from the main argument of the text.\n cruxFromId\n extends classMarkupParser\n catchAllParser lineOfTextParser\n cells commandWordCell\n javascript\n  get pattern() {\n   return this.getWordsFrom(1).join(" ")\n  }\n  get attributes() {\n   return [`class="scrollHoverNote"`, `title="${this.hoverNoteText}"`]\n  }\n  get hoverNoteText() {\n   return this.childrenToString().replace(/\\n/g, " ")\n  }\nlinkParser\n extends abstractMarkupParser\n description Put the matching text in an <a> tag.\n cells commandWordCell urlCell\n inScope linkTitleParser linkTargetParser commentParser\n programParser\n  description Anything here will be URI encoded and then appended to the link.\n  cruxFromId\n  cells commandWordCell\n  catchAllParser programLinkParser\n  javascript\n   get encoded() {\n    return encodeURIComponent(this.childrenToString())\n   }\n cruxFromId\n javascript\n  tag = "a"\n  compileTxt() {\n    return this.root.file.ensureAbsoluteLink(this.link) + " " + this.pattern\n  }\n  get link() {\n   const {baseLink} = this\n   if (this.has("program"))\n     return baseLink + this.getNode("program").encoded\n   return baseLink\n  }\n  get baseLink() {\n   const link = this.getWord(1)\n   const isAbsoluteLink = link.includes("://")\n   if (isAbsoluteLink) return link\n   const relativePath = this.parent.compileSettings?.relativePath || ""\n   return relativePath + link\n  }\n  get attributes() {\n   const attrs = [`href="${this.link}"`]\n   const options = ["title", "target"]\n   options.forEach(option => {\n    const node = this.getNode(option)\n    if (node) attrs.push(`${option}="${node.content}"`)\n   })\n   return attrs\n  }\n  patternStartsAtWord = 2\nemailLinkParser\n description A mailto link\n crux email\n extends linkParser\n javascript\n  get attributes() {\n   return [`href="mailto:${this.link}"`]\n  }\nquickLinkParser\n pattern ^https?\\:\n extends linkParser\n cells urlCell\n javascript\n  get link() {\n   return this.firstWord\n  }\n  patternStartsAtWord = 1\nwrapsOnParser\n cruxFromId\n description Only turn on named wraps.\n example\n  Hello *world*!\n   wrapsOn bold\n extends abstractAftertextDirectiveParser\n catchAllCellType wrapNameCell\n javascript\n  get shouldMatchAll() {\n   return true\n  }\n  get wraps() {\n    const wraps = [{delimiter: "`", tag: "code", exclusive: true, name: "code"},{delimiter: "*", tag: "strong", name: "bold"}, {delimiter: "_", tag: "em", name: "italics"}]\n    // only add katex wrap if the root doc has katex.\n    if (this.root.has("katex"))\n      wraps.unshift({delimiter: "$", tag: "span", attributes: \' class="scrollKatex"\', exclusive: true, name: "katex"})\n    if (this.content)\n      return wraps.filter(wrap => this.content.includes(wrap.name))\n    return wraps\n  }\n  matchWholeLine = true\n  getMatches(text) {\n   const exclusives = []\n   return this.wraps.map(wrap => this.runPattern(text, wrap, exclusives)).filter(i => i).flat()\n  }\n  runPattern(text, wrap, exclusives = []) {\n   const {delimiter, tag, attributes} = wrap\n   const escapedDelimiter = delimiter.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, "\\\\$&")\n   const pattern = new RegExp(`${escapedDelimiter}[^${escapedDelimiter}]+${escapedDelimiter}`, "g")\n   const delimiterLength = delimiter.length\n   return [...text.matchAll(pattern)].map(match => {\n    const { index } = match\n    const endIndex = index + match[0].length\n    // I\'m too lazy to clean up sdk to write a proper inline markup parser so doing this for now.\n    // The exclusive idea is to not try and apply bold or italic styles inside a TeX or code inline style.\n    // Note that the way this is currently implemented any TeX in an inline code will get rendered, but code\n    // inline of TeX will not. Seems like an okay tradeoff until a proper refactor and cleanup can be done.\n    if (exclusives.some(exclusive => index >= exclusive[0] && index <= exclusive[1]))\n      return undefined\n    if (wrap.exclusive)\n      exclusives.push([index, endIndex])\n    return [\n     { index, string: `<${tag + (attributes ? " " + attributes : "")}>`, endIndex, consumeStartCharacters: delimiterLength },\n     { index: endIndex, endIndex, string: `</${tag}>`, consumeEndCharacters: delimiterLength }\n    ]\n   }).filter(i => i)\n  }\nwrapParser\n cruxFromId\n cells commandWordCell delimiterCell tagOrUrlCell\n catchAllCellType htmlAttributesCell\n extends wrapsOnParser\n description Define a custom wrap, for example "wrap _ em" would support: _italics_.\n javascript\n  getMatches(text) {\n   try {\n    const delimiter = this.getWord(1)\n    const tag = this.getWord(2)\n    const attributes = this.getWordsFrom(3).join(" ")\n    if (tag.startsWith("https:")) return this.runPattern(text, {delimiter, tag: "a", attributes: `href="${tag}"` + attributes})\n    return this.runPattern(text, {delimiter, tag, attributes})\n   } catch (err) {\n    console.error(err)\n    return []\n   }\n   // Note: doubling up doesn\'t work because of the consumption characters.\n  }\ndatelineParser\n cruxFromId\n description Gives your paragraph a dateline like "December 15, 2021 — The..."\n extends abstractAftertextDirectiveParser\n javascript\n  getInserts() {\n   const {day} = this\n   if (!day) return false\n   return [{ index: 0, string: `<span class="scrollDateline">${day} — </span>` }]\n  }\n  matchWholeLine = true\n  get day() {\n   let day = this.content || this.root.get("date") || this.root.file?.date\n   if (!day) return ""\n   try {\n    const dayjs = require("dayjs")\n    return dayjs(day).format(`MMMM D, YYYY`)\n   } catch (err) {\n    console.error(err)\n   }\n   return day || ""\n  }\ndayjsParser\n description Advanced directive that evals some Javascript code in an environment including "dayjs".\n cruxFromId\n extends abstractAftertextDirectiveParser\n javascript\n  getInserts() {\n   const dayjs = require("dayjs")\n   const days = eval(this.content)\n   const index = this.parent.originalTextPostLinkify.indexOf("days")\n   return [{ index, string: `${days} ` }]\n  }\nlinkifyParser\n description Use this to disable linkify on the text.\n extends abstractAftertextDirectiveParser\n cruxFromId\n cells commandWordCell booleanCell\nabstractMarkupParameterParser\n cells commandWordCell\n cruxFromId\nmatchAllParser\n description Use this to match all occurrences of the text.\n extends abstractMarkupParameterParser\nmatchParser\n catchAllCellType integerCell\n description Use this to specify which index(es) to match.\n javascript\n  get indexes() {\n   return this.getWordsFrom(1).map(num => parseInt(num))\n  }\n example\n  aftertext\n   hello ello ello\n   bold ello\n    match 0 2\n extends abstractMarkupParameterParser\nabstractHtmlAttributeParser\n javascript\n  compile() {\n   return ""\n  }\nlinkTargetParser\n extends abstractHtmlAttributeParser\n description If you want to set the target of the link. To "_blank", for example.\n crux target\n cells commandWordCell anyCell\nblankLineParser\n description Print nothing. Break section.\n cells blankCell\n boolean isPopular true\n javascript\n  compile() {\n   return this.parent.clearSectionStack()\n  }\n pattern ^$\n tags doNotSynthesize\nchatLineParser\n catchAllCellType anyCell\n catchAllParser chatLineParser\nlineOfCodeParser\n catchAllCellType codeCell\n catchAllParser lineOfCodeParser\ncommentLineParser\n catchAllCellType commentCell\ncssLineParser\n catchAllCellType cssAnyCell\n catchAllParser cssLineParser\nerrorParser\n baseParser errorParser\nheatrixCatchAllParser\n // todo Fill this out\n catchAllCellType anyCell\nlineOfTextParser\n catchAllCellType stringCell\n boolean isTextParser true\nhtmlLineParser\n catchAllCellType htmlAnyCell\n catchAllParser htmlLineParser\nstumpContentParser\n catchAllCellType anyCell\nlinkTitleParser\n description If you want to set the title of the link.\n crux title\n cells commandWordCell\n catchAllCellType anyCell\n example\n  * This report showed the treatment had a big impact.\n   https://example.com/report This report.\n    title The average growth in the treatment group was 14.2x higher than the control group.\nprogramLinkParser\n catchAllCellType codeCell\nabstractLoopConfigParser\n cells commandWordCell\n cruxFromId\n catchAllCellType stringCell\nabstractItemsProviderParser\n cells commandWordCell\nloopLinesParser\n crux lines\n extends abstractItemsProviderParser\n description Iterate over the provided lines.\n catchAllParser loopLineParser\n loopLineParser\n  catchAllCellType stringCell\n javascript\n  get items() {\n   return this.map(node => node.asString)\n  }\nloopWordsParser\n crux words\n extends abstractItemsProviderParser\n catchAllCellType stringCell\n description Iterate over the provided words.\n javascript\n  get items() {\n   return this.getWordsFrom(1)\n  }\nloopTagsParser\n crux tags\n extends abstractItemsProviderParser\n catchAllCellType tagWithOptionalFolderCell\n description Set this to iterate over scroll files in a folder. Provide both the folder and group name like this: [folder]/[tag]\n javascript\n  get items() {\n   return this.root.file.getFilesWithTagsForEmbedding(this.getWordsFrom(1))\n  }\nabstractPointConfigParser\n // todo: scoped parsers should support abstract types\n cruxFromId\n cells commandWordCell\n catchAllCellType stringCell\n single\nlatParser\n cells commandWordCell floatCell\n cruxFromId\n single\nlongParser\n cells commandWordCell floatCell\n cruxFromId\n single\nquoteLineParser\n catchAllCellType anyCell\n catchAllParser quoteLineParser\nreadingListItemParser\n cells urlCell\n catchAllCellType stringCell\n javascript\n  compile() {\n   const url = this.firstWord\n   const [title, author] = this.content.split(" by ")\n   return `<li><a href="${url}">${title ?? url}</a>${author ? ` by ${author}` : ""}</li>`\n  }\nscrollParser\n extensions scroll\n description Scroll is a language for scientists of all ages. Refine, share and collaborate on ideas.\n root\n inScope abstractScrollParser blankLineParser\n catchAllParser catchAllParagraphParser\n compilesTo html\n javascript\n  setFile(file) {\n   this.file = file\n   return this\n  }\n  compile(compileSettings) {\n    this.sectionStack = []\n    return this.map(child => child.compile(compileSettings)).filter(i => i).join("\\n") + this.clearSectionStack()\n  }\n  sectionStack = []\n  clearSectionStack() {\n   const result = this.sectionStack.join("")\n   this.sectionStack = []\n   return result\n  }\n  get hakonParser() {\n    if (this.isNodeJs())\n      return require("scrollsdk/products/hakon.nodejs.js")\n    return hakonParser\n  }\n  alreadyRequired = new Set()\n  compileEmbeddedVersion(compileSettings) {\n   this.sectionStack = []\n   return this.map(child => (child.compileEmbeddedVersion ? child.compileEmbeddedVersion(compileSettings) : child.compile(compileSettings)))\n     .filter(i => i)\n     .join("\\n")\n     .trim() + this.clearSectionStack()\n  }\n  get footnotes() {\n   if (this._footnotes === undefined) this._footnotes = this.filter(node => node.isFootnote)\n   return this._footnotes\n  }\n  file = {}\n  get permalink() {\n   return this.get("permalink") || this.file.permalink || ""\n  }\n example\n  # Hello world\n  ## This is Scroll\n  * It compiles to HTML.\n  \n  code\n   // You can add code as well.\n   print("Hello world")\nscriptLineParser\n catchAllCellType scriptAnyCell\n catchAllParser scriptLineParser\nstampFileParser\n catchAllCellType stringCell\n description Create a file.\n javascript\n  build(parentDir) {\n   const fs = require("fs")\n   const path = require("path")\n   const fullPath = path.join(parentDir, this.getLine())\n   this.root.file.log(`Creating file ${fullPath}`)\n   fs.mkdirSync(path.dirname(fullPath), {recursive: true})\n   const content = this.childrenToString()\n   fs.writeFileSync(fullPath, content, "utf8")\n   const isExecutable = content.startsWith("#!")\n   if (isExecutable) fs.chmodSync(fullPath, "755")\n  }\nstampFolderParser\n catchAllCellType stringCell\n description Create a folder.\n inScope stampFolderParser\n catchAllParser stampFileParser\n pattern \\/$\n javascript\n  build(parentDir) {\n   const fs = require("fs")\n   const path = require("path")\n   const newPath = path.join(parentDir, this.getLine())\n   this.root.file.log(`Creating folder ${newPath}`)\n   fs.mkdirSync(newPath, {recursive: true})\n   this.forEach(node => node.build(newPath))\n  }\nrowParser\n catchAllCellType stringCell\n javascript\n  toRow(columns, delimiter) {\n   const words = this.getLine().split(delimiter)\n   let str = ""\n   let column = 0\n   const columnCount = columns.length\n   while (column < columnCount) {\n    const col = columns[column]\n    column++\n    const content = (columnCount === column ? words.slice(columnCount - 1).join(" ") : words[column - 1]) ?? ""\n    if (col.isLink) continue\n    let tagged = content\n    const link = words[col.linkIndex]\n    if (col.linkIndex > -1 && link) tagged = `<a href="${link}">${content}</a>`\n    else if (content.match(/^https?\\:[^ ]+$/)) tagged = `<a href="${content}">${content}</a>`\n    str += `<td>${tagged}</td>\\n`\n   }\n   return str\n  }\nplainTextLineParser\n catchAllCellType stringCell\n catchAllParser plainTextLineParser\ntreeRowContentParser\n description Any blob content in a cell.\n cells stringCell\n catchAllCellType stringCell\ntreeRowColumnParser\n catchAllParser treeRowContentParser\n description A columnName value pair, or just a columnName if the value is a text blob.\n cells anyCell\n catchAllCellType stringCell\ntreeRowParser\n cells anyCell\n description The root node of a row.\n catchAllParser treeRowColumnParser\n javascript\n  toRow(columns) {\n   let str = ""\n   columns.forEach(col => {\n    const node = this.getNode(col.name)\n    if (col.isLink) return\n    if (!node) {\n     str += "<td></td>\\n"\n     return\n    }\n    const content = (node.length ? node.childrenToString() : node.content) ?? ""\n    let tagged = ""\n    const link = this.get(col.name + "Link")\n    if (col.linkIndex > -1 && link) tagged = `<a href="${link}">${content}</a>`\n    else if (node.length) tagged = `<pre>${content}</pre>`\n    else tagged = content\n    str += `<td>${tagged}</td>\\n`\n   })\n   return str\n  }'
}
