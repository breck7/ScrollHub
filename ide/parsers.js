const AppConstants = {
	parsers:
		'// Related work:\n CSS is great for text selector ideas: https://www.w3schools.com/cssref/css_selectors.asp\n Roff has a lot of related markup ideas: https://www.systutorials.com/docs/linux/man/7-groff_man/\n// Basic cell types\n// Enum cell types\n// String cell types\n// Date cell types\n// Numeric cell types\n// Scroll cell types\n// Link cell types\n// File system cell types\n// HTML cell types\n// todo: copy the external library to folder so it works offline?\n// Extend this if you want to create a new provider\n// Some basic providers:\n// The main measure parser. All measures should extend from this.\n// String Measures\n// URL Parsers\n// Required ID measure which denotes a concept\n// Numeric Measures\n// Enum Measures\n// Boolean Measures\n// https://developers.google.com/search/docs/crawling-indexing/sitemaps/build-sitemap#text\n// A joint effort from:\n// - Breck Yunits https://github.com/breck7\n// - Guillaume Papin https://github.com/Sarcasm\n// Origin: https://github.com/breck7/scrollsdk/issues/120\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nwrapNameCell\n description What wraps are available to turn on?\n enum bold italics code katex\nblankCell\nanyCell\nenumCell\n highlightScope constant.language\nbooleanCell\n enum true false\n extends enumCell\nstringCell\n highlightScope string\nwordCell\n highlightScope string\n description A non-empty single word string.\n regex .+\nsemanticVersionCell\n highlightScope string\n description A 3 part sem version string like 1.2.1\ndateCell\n highlightScope string\nnumberCell\n highlightScope constant.numeric\nintegerCell\n extends numberCell\n highlightScope constant.numeric.integer\nfloatCell\n extends numberCell\n highlightScope constant.numeric.float\npercentCell\n highlightScope constant.numeric.float\n extends stringCell\n // todo: this currently extends from stringCell b/c scrollsdk needs to be fixed. seems like if extending from number then the hard coded number typescript regex takes precedence over a custom regex\ncountCell\n extends integerCell\nyearCell\n extends integerCell\nkeywordCell\n highlightScope keyword\ncommentCell\n highlightScope comment\ndelimiterCell\n description String to use as a delimiter.\n highlightScope string\ncodeCell\n highlightScope comment\nbulletPointCell\n description Any token used as a bullet point such as "-" or "1." or ">"\n highlightScope keyword\npersonNameCell\n extends stringCell\nurlCell\n highlightScope constant.language\nabsoluteUrlCell\n highlightScope constant.language\n regex (ftp|https?)://.+\nemailAddressCell\n extends stringCell\npermalinkCell\n highlightScope string\n description A string that doesn\'t contain characters that might interfere with most filesystems. No slashes, for instance.\nfilePathCell\n extends stringCell\ntagOrUrlCell\n description An HTML tag or a url.\n highlightScope constant.language\nhtmlAttributesCell\n highlightScope comment\nhtmlTagCell\n highlightScope constant.language\n enum div span p a img ul ol li h1 h2 h3 h4 h5 h6 header nav section article aside main footer input button form label select option textarea table tr td th tbody thead tfoot br hr meta link script style title code\nclassNameCell\n highlightScope constant\nhtmlIdCell\n extends anyCell\ncssAnyCell\n extends anyCell\ngroupNameCell\n extends permalinkCell\ngroupNameWithOptionalFolderCell\n description A group name optionally combined with a folder path. Only used when referencing groups, not in posts.\n extends stringCell\nhtmlAnyCell\n extends stringCell\nmeasureNameCell\n extends keywordCell\n // A regex for column names for max compatibility with a broad range of data science tools:\n regex [a-zA-Z][a-zA-Z0-9]*\njavascriptCell\n extends stringCell\nscriptAnyCell\n extends anyCell\nabstractScrollParser\n cells keywordCell\n javascript\n  compileEmbeddedVersion(compileSettings) {\n   return this.compile(compileSettings)\n  }\n  compileTxt() {\n    return ""\n  }\n  getHtmlRequirements(compileSettings) {\n    const {requireOnce} = this\n    if (!requireOnce)\n      return ""\n    const set = compileSettings?.alreadyRequired || this.root.alreadyRequired\n    if (set.has(requireOnce))\n      return ""\n    \n    set.add(requireOnce)\n    return requireOnce + "\\n\\n"\n  }\nabstractAftertextParser\n description Text followed by markup commands.\n extends abstractScrollParser\n inScope abstractAftertextDirectiveParser abstractAftertextAttributeParser aftertextTagParser commentParser\n example\n  aftertext\n   Hello brave new world\n   link home.com new\n   bold brave new\n   underline new world\n   strike wor\n javascript\n  get markupInserts() {\n   const { originalTextPostLinkify } = this\n   return this.filter(node => node.isMarkup)\n    .map(node => node.getInserts(originalTextPostLinkify))\n    .filter(i => i)\n    .flat()\n  }\n  get originalText() {\n   return this.content ?? ""\n  }\n  get originalTextPostLinkify() {\n   const { originalText } = this\n   const shouldLinkify = this.get("linkify") === "false" || originalText.includes("<a ") ? false : true\n   return shouldLinkify ? this.replaceNotes(Utils.linkify(originalText)) : originalText\n  }\n  replaceNotes(originalText) {\n   // Skip the replacements if there are no footnotes or the text has none.\n   if (!this.root.footnotes.length || !originalText.includes("^")) return originalText\n   this.root.footnotes.forEach((note, index) => {\n    const needle = note.firstWord\n    const {linkBack} = note\n    if (originalText.includes(needle)) originalText = originalText.replace(new RegExp("\\\\" + needle + "\\\\b"), `<a href="#${note.anchorId}" class="scrollNoteLink" id="${linkBack}"><sup>${note.label}</sup></a>`)\n   })\n   return originalText\n  }\n  get text() {\n   const { originalTextPostLinkify, markupInserts } = this\n   let adjustment = 0\n   let newText = originalTextPostLinkify\n   // If multiple tags start at same index, the tag that closes first should start last. Otherwise HTML breaks.\n   markupInserts.sort((a, b) => (a.index === b.index ? b.endIndex - a.endIndex : a.index - b.index))\n   markupInserts.forEach(insertion => {\n    insertion.index += adjustment\n    const consumeStartCharacters = insertion.consumeStartCharacters ?? 0\n    const consumeEndCharacters = insertion.consumeEndCharacters ?? 0\n    newText = newText.slice(0, insertion.index - consumeEndCharacters) + insertion.string + newText.slice(insertion.index + consumeStartCharacters)\n    adjustment += insertion.string.length - consumeEndCharacters - consumeStartCharacters\n   })\n   return newText\n  }\n  tag = "p"\n  get className() {\n   if (this.get("classes"))\n     return this.get("classes")\n   const classLine = this.getNode("class")\n   if (classLine && classLine.applyToParentElement) return classLine.content\n   return this.defaultClassName\n  }\n  defaultClassName = "scrollParagraph"\n  get isHidden() {\n    return this.has("hidden")\n  }\n  compile(compileSettings) {\n   if (this.isHidden) return ""\n   this.compileSettings = compileSettings\n   const { className } = this\n   const classAttr = className ? `class="${this.className}"` : ""\n   const tag = this.get("tag") || this.tag\n   if (tag === "none") // Allow no tag for aftertext in tables\n     return this.text\n   return this.getHtmlRequirements(compileSettings) + `<${tag} ${this.divAttributes}${classAttr}>${this.text}</${tag}>`\n  }\n  get divAttributes() {\n   const attrs = this.filter(node => node.isAttribute)\n   return attrs.length ? attrs.map(node => node.divAttributes).join(" ") + " " : ""\n  }\nparagraphParser\n // todo Perhaps rewrite this from scratch and move out of aftertext.\n extends abstractAftertextParser\n catchAllCellType stringCell\n description A paragraph.\n cruxFromId\n javascript\n  compile(compileSettings) {\n   if (this.isHidden) return ""\n   // Hacky, I know.\n   const newLine = this.has("wrapsOn") ? undefined : this.appendLine("wrapsOn")\n   const compiled = super.compile(compileSettings)\n   if (newLine)\n    newLine.destroy()\n   return compiled\n  }\n  compileTxt() {\n    const children = this.filter(node => node.compileTxt).map(node => node.compileTxt()).filter(i => i).join("\\n")\n    const dateline = this.getNode("dateline")\n    return (dateline ? dateline.day + "\\n\\n" : "") + (this.originalText || "") + (children ? "\\n " + children.replace(/\\n/g, "\\n ") : "")\n  }\nblinkParser\n description Useful when you have a client that always needs to find 1 thing they would like you to change.\n extends paragraphParser\n crux blink\n javascript\n  compile() {\n   return `<span class="scrollBlink">${super.compile()}</span>\n    <script>\n    setInterval(()=>{\n        Array.from(document.getElementsByClassName("scrollBlink")).forEach(el => \n        el.style.color = el.style.color === "white" ? "black" : "white"\n        )\n    }, 2000)\n    </script>`\n  }\ncatchAllParagraphParser\n description Any top level line that doesn\'t match a keyword is treated as a paragraph node.\n extends paragraphParser\n cells stringCell\n javascript\n  get originalText() {\n   return this.getLine() || ""\n  }\nindentableParagraphParser\n extends paragraphParser\n inScope abstractAftertextDirectiveParser abstractAftertextAttributeParser indentableParagraphParser\n javascript\n  compile() {\n   return (\n    super.compile() +\n    this.map(node => node.compile())\n     .join("\\n")\n     .trim()\n   )\n  }\n  compileTxt() {\n    return this.getWord(0) + " " + super.compileTxt()\n  }\nchecklistTodoParser\n extends indentableParagraphParser\n example\n  [] Get milk\n description An incomplete checklist item.\n crux []\n string checked \n javascript\n  get text() {\n   return `<div style="text-indent:${(this.getIndentLevel() - 1) * 20}px;"><input type="checkbox" ${this.checked} id="${this.id}"><label for="${this.id}">` + super.text + `</label></div>`\n  }\n  get id() {\n   return this.get("id") || "item" + this._getUid()\n  }\nchecklistDoneParser\n extends checklistTodoParser\n description A complete checklist list item.\n string checked checked\n crux [x]\n example\n  [x] get milk\nlistAftertextParser\n extends indentableParagraphParser\n example\n  - I had a _new_ thought.\n description A list item.\n crux -\n javascript\n  defaultClassName = ""\n  compile() {\n   const index = this.getIndex()\n   const parent = this.parent\n   const nodeClass = this.constructor\n   const isStartOfList = index === 0 || !(parent.nodeAt(index - 1) instanceof nodeClass)\n   const isEndOfList = parent.length === index + 1 || !(parent.nodeAt(index + 1) instanceof nodeClass)\n   const { listType } = this\n   return (isStartOfList ? `<${listType} ${this.attributes}>` : "") + `${super.compile()}` + (isEndOfList ? `</${listType}>` : "")\n  }\n  get attributes() {\n    return ""\n  }\n  tag = "li"\n  listType = "ul"\nabstractCustomListItemParser\n extends listAftertextParser\n javascript\n  get requireOnce() {\n    return `<style>\\n.${this.constructor.name} li::marker {content: "${this.firstWord} ";}\\n</style>`\n  }\n  get attributes() {\n    return `class="${this.constructor.name}"`\n  }\norderedListAftertextParser\n extends listAftertextParser\n description A list item.\n example\n  1. Hello world\n pattern ^\\d+\\. \n javascript\n  listType = "ol"\n  get attributes() { return ` start="${this.getWord(0)}"`}\nquickQuoteParser\n crux >\n extends indentableParagraphParser\n description A quote.\n javascript\n  defaultClassName = "scrollQuote"\n  tag = "blockquote"\nexpanderParser\n cruxFromId\n description Prints the section in an expandable html details and summary tag.\n extends paragraphParser\n javascript\n  compile() {\n   this.parent.sectionStack.push("</details>")\n   return `<details>${super.compile()}`\n  }\n  compileTxt() {\n    return this.content\n  }\n  tag = "summary"\n  defaultClassName = ""\nfootnoteDefinitionParser\n description A footnote. Can also be used as section notes.\n extends paragraphParser\n boolean isFootnote true\n pattern ^\\^.+$\n // We need to quickLinks back in scope because there is currently a bug in ScrollSDK/parsers where if a parser extending a parent class has a child parser defined, then any regex parsers in the parent class will not be tested unless explicitly included in scope again.\n inScope quickLinkParser\n labelParser\n  description If you want to show a custom label for a footnote. Default label is the note definition index.\n  cruxFromId\n  cells keywordCell\n  catchAllCellType stringCell\n javascript\n  get divAttributes() {\n   return super.divAttributes + ` id="${this.anchorId}"`\n  }\n  get anchorId() {\n   return `note${this.noteDefinitionIndex}`\n  }\n  get label() {\n   // In the future we could allow common practices like author name\n   return this.get("label") || `[${this.noteDefinitionIndex}]`\n  }\n  get linkBack() {\n   return `noteUsage${this.noteDefinitionIndex}`\n  }\n  get text() {\n   return `<a class="scrollFootNoteUsageLink" href="#noteUsage${this.noteDefinitionIndex}">${this.label}</a> ${super.text}`\n  }\n  get noteDefinitionIndex() {\n   return this.parent.footnotes.indexOf(this) + 1\n  }\n  compileTxt() {\n    return this.getWord(0) + ": " + super.compileTxt()\n  }\nabstractHeaderParser\n extends paragraphParser\n javascript\n  compile(compileSettings) {\n   if (this.isHidden) return ""\n   this.parent.sectionStack.push("</div>")\n   return `<div class="scrollSection">` + super.compile(compileSettings)\n  }\n  compileTxt() {\n    const line = super.compileTxt()\n    return line + "\\n" + "=".repeat(line.length)\n  }\nh1Parser\n description Compiles to an html h1 tag.\n extends abstractHeaderParser\n crux #\n javascript\n  tag = "h1"\nh2Parser\n description Compiles to an html h2 tag.\n extends abstractHeaderParser\n crux ##\n javascript\n  tag = "h2"\nh3Parser\n description Compiles to an html h3 tag.\n extends abstractHeaderParser\n crux ###\n javascript\n  tag = "h3"\nh4Parser\n description Compiles to an html h4 tag.\n extends abstractHeaderParser\n crux ####\n javascript\n  tag = "h4"\nquestionAftertextParser\n description A question.\n extends h4Parser\n crux ?\n javascript\n  defaultClassName = "scrollQuestion"\nh5Parser\n description Compiles to an html h5 tag.\n extends abstractHeaderParser\n crux #####\n javascript\n  tag = "h5"\nprintTitleParser\n description Print the page title.\n extends abstractHeaderParser\n cruxFromId\n javascript\n  compile(compileSettings) {\n   // Hacky, I know.\n   const {content} = this\n   if (content === undefined)\n    this.setContent(this.parent.file.title)\n   const { permalink } = this.parent.file\n   if (!permalink) {\n    this.setContent(content) // Restore it as it was.\n    return super.compile(compileSettings)\n   }\n   const newLine = this.appendLine(`link ${permalink}`)\n   const compiled = super.compile(compileSettings)\n   newLine.destroy()\n   this.setContent(content) // Restore it as it was.\n   return compiled\n  }\n  get originalText() {\n   return this.content ?? this.parent.file.title ?? ""\n  }\n  defaultClassName = "scrollTitle"\n  tag = "h1"\ncaptionAftertextParser\n description An optional caption to accompany the resource.\n crux caption\n extends paragraphParser\nquickParagraphParser\n crux *\n extends paragraphParser\n description A shorter alias for "paragraph".\n example\n  * I had a _new_ idea.\nthinColumnsParser\n extends abstractAftertextParser\n cruxFromId\n catchAllCellType integerCell\n description Start a multicolumn grid.\n javascript\n  compileEmbeddedVersion() {\n   return ""\n  }\n  columnWidth = 35\n  columnGap = 20\n  compile() {\n   const {columnWidth, columnGap} = this\n   const maxColumns = parseInt(this.getWord(1) ?? 10)\n   const maxTotalWidth = maxColumns * columnWidth + (maxColumns - 1) * columnGap\n   // Starting the columns always first clears the section stack.\n   return this.parent.clearSectionStack() + `<div class="scrollColumns" style="column-width:${columnWidth}ch;column-count:${maxColumns};max-width:${maxTotalWidth}ch;">`\n  }\nwideColumnsParser\n extends thinColumnsParser\n description Start a double wide column.\n javascript\n  columnWidth = 90\nmediumColumnsParser\n extends thinColumnsParser\n javascript\n  columnWidth = 65\nendColumnsParser\n extends abstractAftertextParser\n cruxFromId\n description End a multicolumn grid.\n javascript\n  compile() {\n   return "</div>"\n  }\n  compileEmbeddedVersion() {\n   return ""\n  }\nabstractDinkusParser\n extends abstractAftertextParser\n string dinkus *\n boolean isDinkus true\n javascript\n  compile() {\n   return `<div class="dinkus"><span>${this.dinkus}</span></div>`\n  }\n  compileTxt() {\n    return this.getLine()\n  }\nhorizontalRuleParser\n crux ---\n description Prints an html <hr> tag\n extends abstractDinkusParser\n javascript\n  compile() {\n   return `<hr>`\n  }\ndinkusParser\n crux ***\n description Prints a centered *\n extends abstractDinkusParser\nendOfPostDinkusParser\n extends abstractDinkusParser\n description Prints a centered ⁂.\n crux ****\n string dinkus ⁂\nloopParser\n extends abstractAftertextParser\n cells keywordCell\n description Iterate over files, lines or words, evaluating code and joining the resulting HTML.\n cruxFromId\n inScope abstractItemsProviderParser\n joinParser\n  extends abstractLoopConfigParser\n  description HTML to use to join the items.\n limitParser\n  extends abstractLoopConfigParser\n  description HTML to use to join the items.\n javascriptParser\n  extends abstractLoopConfigParser\n  description Javascript to execute for each file in the loop.\n javascript\n  compile() {\n   const code = this.get("javascript")\n   const joinWith = this.get("join") ?? ""\n   try {\n    const limit = this.get("limit")\n    let items = this.items\n    if (limit) items = items.slice(0, parseInt(limit))\n    return items.map((item, index) => eval(code)).join(joinWith)\n   } catch (err) {\n    console.error(err)\n    return ""\n   } finally {\n    this.teardown()\n   }\n  }\n  get items() {\n   const provider = this.getChildInstancesOfParserId("abstractItemsProviderParser")[0]\n   return provider ? provider.items : []\n  }\n  teardown() {}\nloremIpsumParser\n extends abstractAftertextParser\n cruxFromId\n description Generate dummy text.\n catchAllCellType integerCell\n javascript\n  compile() {\n   const text = `Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.`\n   return text.repeat(this.getWord(1) ? parseInt(this.getWord(1)) : 1)\n  }\nprintSnippetsParser\n // todo: why are we extending AT here and not loops? Is it for class/id etc?\n extends abstractAftertextParser\n cruxFromId\n cells keywordCell\n catchAllCellType groupNameWithOptionalFolderCell\n description Prints the snippets of all files in the named group(s).\n example\n  printSnippets index\n javascript\n  makeSnippet(file, compileSettings) {\n    const {scrollProgram, endSnippetIndex} = file\n    if (endSnippetIndex === -1) return scrollProgram.compileEmbeddedVersion(compileSettings) + file.viewSourceHtml\n    const linkRelativeToCompileTarget = compileSettings.relativePath + file.permalink\n    const joinChar = "\\n"\n    const html = scrollProgram\n        .map((child, index) => (index >= endSnippetIndex ? "" : child.compileEmbeddedVersion ? child.compileEmbeddedVersion(compileSettings) : child.compile(compileSettings)))\n        .filter(i => i)\n        .join(joinChar)\n        .trim() +\n      `<a class="scrollContinueReadingLink" href="${linkRelativeToCompileTarget}">Continue reading...</a>`\n    return html\n  }\n  get files() {\n   return this.parent.file.getFilesInGroupsForEmbedding(this.getWordsFrom(1), this.has("limit") ? parseInt(this.get("limit")) : undefined)\n  }\n  compile() {\n   const alreadyRequired = this.root.alreadyRequired\n   const snippets = this.files.map(file => {\n    const compileSettings = {relativePath: file.relativePath, alreadyRequired }\n    return `<div class="scrollSnippetContainer">${this.makeSnippet(file.file, compileSettings)}</div>`\n    }).join("\\n\\n")\n   return `<div class="scrollColumns" style="column-width:35ch;">${snippets}</div>`\n  }\n  compileTxt() {\n   return this.files.map(file =>  {\n    const title = file.file.title\n    const ruler = "=".repeat(title.length)\n    // Note: I tried to print the description here but the description generating code needs work.\n    return `${title}\\n${ruler}\\n${file.file.date}\\n${file.file.absoluteLink}`\n   }).join("\\n\\n")\n  }\nprintFullSnippetsParser\n extends printSnippetsParser\n cruxFromId\n description Prints the full contents of files that are in the named group.\n javascript\n  makeSnippet(file, compileSettings) {\n   return file.scrollProgram.compileEmbeddedVersion(compileSettings) + file.viewSourceHtml\n  }\nprintViewSourceParser\n description Print a "View source" link.\n extends abstractAftertextParser\n cruxFromId\n javascript\n  compileEmbeddedVersion() {\n   return ""\n  }\n  compile() {\n   const file = this.parent.file\n   const { viewSourceUrl } = file\n   return file.compileStumpCode(`p\n   class scrollViewSource doNotPrint\n   a View source\n    href ${viewSourceUrl}`)\n  }\nprintViewSourceBadgeParser\n description Print a "View source" badge in top right.\n extends abstractAftertextParser\n cruxFromId\n javascript\n  compileEmbeddedVersion() {\n   return ""\n  }\n  compile() {\n   const file = this.parent.file\n   const { viewSourceUrl, SVGS } = file\n   return file.compileStumpCode(`div\n   class scrollViewSourceBadge doNotPrint\n   a ${SVGS.git}\n    href ${viewSourceUrl}`)\n  }\nprintAuthorParser\n description Prints a byline with the author\'s name and optionally a link to them.\n extends abstractScrollParser\n cruxFromId\n // todo: we need pattern matching added to sdk to support having no params or a url and personNameCell\n cells keywordCell\n catchAllCellType anyCell\n example\n  // With Link:\n  printAuthor https://breckyunits.com Breck Yunits\n  // No link:\n  printAuthor  Breck Yunits\n javascript\n  compile() {\n   const {link, name} = this\n   return `<div class="scrollByLine">by <a ${link ? `href="${link}"` : ""}>${name}</a></div>`\n  }\n  get link() {\n    return this.getWord(1) || this.parent.getNode("author")?.getWord(1)\n  }\n  get name() {\n    return this.getWordsFrom(2).join(" ") || this.parent.getNode("author")?.getWordsFrom(2).join(" ")\n  }\n  compileTxt() {\n    return `by ${this.name}`\n  }\nabstractTopLevelSingleMetaParser\n description Use these keywords once per file.\n extends abstractScrollParser\n inScope slashCommentParser\n cruxFromId\n cells keywordCell\n javascript\n  isTopMatter = true\n  isSetterParser = true\n  compile() {\n   return ""\n  }\nauthorParser\n cells keywordCell urlCell\n catchAllCellType personNameCell\n description Set the author(s) for a post. Prints nothing by itself, but is printed with the title in text mode and in various metadata outputs.\n extends abstractTopLevelSingleMetaParser\ndateParser\n catchAllCellType dateCell\n description Date this file was first published.\n extends abstractTopLevelSingleMetaParser\nabstractFileSettingParser\n extends abstractTopLevelSingleMetaParser\n cells keywordCell\n javascript\n  compile() {\n   return ""\n  }\nemailParser\n description Email address for the site owner.\n extends abstractFileSettingParser\n cruxFromId\n cells keywordCell emailAddressCell\nabstractUrlSettingParser\n extends abstractFileSettingParser\n cells keywordCell urlCell\n cruxFromId\ngitParser\n description A link to the web Git UI for this site.\n extends abstractUrlSettingParser\ncanonicalUrlParser\n description Canonical URL for SEO. If undefined Scroll generates this from the baseUrl and permalink.\n extends abstractUrlSettingParser\nopenGraphImageParser\n description URL for Open Graph Image. https://ogp.me/. If not defined, Scroll will try to generate it\'s own using the first image tag on your page.\n extends abstractUrlSettingParser\nbaseUrlParser\n description Root url of this published site on the web. Must be provided for RSS Feeds and OpenGraph tags to work, but has no effect locally.\n extends abstractUrlSettingParser\ndownloadUrlParser\n description In the default Scroll theme the download button will link to this.\n extends abstractUrlSettingParser\nhomeUrlParser\n description In the default Scroll theme the home button will link to "index.html". You can override this with this setting.\n extends abstractUrlSettingParser\nrssFeedUrlParser\n description URL for RSS feed, if any.\n extends abstractUrlSettingParser\nviewSourceBaseUrlParser\n description The base link to be used to generate all of the git "View source" links. If not provided, the scroll filename will be used.\n extends abstractUrlSettingParser\nabstractSiteStringSettingParser\n extends abstractFileSettingParser\n catchAllCellType stringCell\n cruxFromId\ngroupsParser\n description Add this file to zero or more groups.\n cruxFromId\n example\n  groups index.html\n extends abstractTopLevelSingleMetaParser\n cells keywordCell\n catchAllCellType groupNameCell\nimportOnlyParser\n description Mark a file as not one to build. This line will be not be imported into the importing file.\n cruxFromId\n extends abstractTopLevelSingleMetaParser\n javascript\n  compile() {\n   return ""\n  }\nhtmlLangParser\n cells keywordCell stringCell\n description The lang attribute for the <html lang=""> tag. If not specified will be "en". See https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/lang\n extends abstractTopLevelSingleMetaParser\nopenGraphDescriptionParser\n catchAllCellType stringCell\n crux description\n description Description for Open Graph. https://ogp.me/. If not defined, Scroll will try to generate it\'s own.\n extends abstractTopLevelSingleMetaParser\npermalinkParser\n description When compiling, Scroll will save this file to {permalink}\n extends abstractTopLevelSingleMetaParser\n cells keywordCell permalinkCell\nrelatedScrollFilesParser\n extends abstractTopLevelSingleMetaParser\n catchAllCellType permalinkCell\n crux related\n description Set any related posts. Prints nothing by itself.\n example\n  ...\n  That\'s all I have to say about hiking.\n  related fishing camping\n  # Related Posts\n  printRelatedList\npageTitleParser\n catchAllCellType personNameCell\n crux title\n description Title of the page for meta tags. Prints nothing by itself. Use "printTitle" to print this title in a big HTML tag.\n extends abstractTopLevelSingleMetaParser\nviewSourceUrlParser\n catchAllCellType urlCell\n description Use this to override the link to the source code for a scroll file.\n extends abstractTopLevelSingleMetaParser\nabstractBuildCommandParser\n extends abstractScrollParser\n cruxFromId\n cells keywordCell\n catchAllCellType filePathCell\n inScope slashCommentParser\n javascript\n  isTopMatter = true\n  compile() {\n   return ""\n  }\nbuildConceptsParser\n cruxFromId\n description Compiles concepts to a data format(s) and save to disk.\n extends abstractBuildCommandParser\n sortByParser\n  cruxFromId\n  cells keywordCell anyCell\nbuildCssParser\n description Compile document to CSS and save to disk.\n extends abstractBuildCommandParser\nbuildHtmlParser\n description Compile document to html and save to disk.\n extends abstractBuildCommandParser\nbuildMeasuresParser\n cruxFromId\n description Compile measure metadata to a data format(s) and save to disk.\n extends abstractBuildCommandParser\n sortByParser\n  cruxFromId\n  cells keywordCell anyCell\nbuildRssParser\n description Compile metadata on a group(s) of documents to RSS and save to disk.\n extends abstractBuildCommandParser\nbuildJsParser\n description Compile document to JS and save to disk.\n extends abstractBuildCommandParser\nbuildTxtParser\n description Compile document to plain text and save to disk.\n extends abstractBuildCommandParser\nchatParser\n description A dialogue between two people.\n catchAllParser chatLineParser\n cruxFromId\n extends abstractScrollParser\n javascript\n  compile() {\n   return this.map((line, index) => `<div style="text-align: ${index % 2 ? "right" : "left"};" class="scrollChat ${index % 2 ? "scrollChatRight" : "scrollChatLeft"}"><span>${line.asString}</span></div>`).join("")\n  }\n  compileTxt() {\n    return this.childrenToString()\n  }\ncodeParser\n description A code block.\n catchAllParser lineOfCodeParser\n extends abstractScrollParser\n javascript\n  compile() {\n   return `<code class="scrollCodeBlock">${this.childrenToString().replace(/\\</g, "&lt;")}</code>`\n  }\n  compileTxt() {\n    return this.childrenToString()\n  }\n cruxFromId\ncodeWithLanguageParser\n description Use this to specify the language of the code block, such as csvCode or rustCode.\n extends codeParser\n pattern ^[a-zA-Z0-9_]+Code$\nabstractScrollWithRequirementsParser\n extends abstractScrollParser\n cruxFromId\n javascript\n  compile(compileSettings) {\n    return this.getHtmlRequirements(compileSettings) + this.compileInstance()\n  }\ncopyButtonsParser\n extends abstractScrollWithRequirementsParser\n description Make code snippets copyable.\n javascript\n  compileInstance() {\n   return ""\n  }\n string requireOnce\n  <script>\n  document.addEventListener("DOMContentLoaded", () => document.querySelectorAll(".scrollCodeBlock").forEach(block =>\n   {\n    if (!navigator.clipboard) return\n    const button = document.createElement("span")\n    button.classList.add("scrollCopyButton")\n    block.appendChild(button)\n    button.addEventListener("click", async () => {\n      await navigator.clipboard.writeText(block.innerText)\n      button.classList.add("scrollCopiedButton")\n    })\n   }\n  ))\n  </script>\nkatexParser\n extends abstractScrollWithRequirementsParser\n catchAllCellType codeCell\n catchAllParser lineOfCodeParser\n description Use the KaTex library to typeset math.\n string copyFromExternal katex.min.css katex.min.js\n string requireOnce\n  <link rel="stylesheet" href="katex.min.css">\n  <script defer src="katex.min.js"></script>\n  <script>\n  document.addEventListener("DOMContentLoaded", () => document.querySelectorAll(".scrollKatex").forEach(el =>\n   {\n    katex.render(el.innerText, el, {\n        throwOnError: false\n    });\n   }\n  ))\n  </script>\n javascript\n  compileInstance() {\n   const id = this._getUid()\n   const content = this.content === undefined ? "" : this.content\n   return `<div class="scrollKatex" id="${id}">${content + this.childrenToString()}</div>`\n  }\n  compileTxt() {\n    return ( this.content ? this.content : "" )+ this.childrenToString()\n  }\nmapParser\n inScope latParser longParser\n zoomParser\n  cells keywordCell integerCell\n  cruxFromId\n  single\n heightParser\n  cells keywordCell floatCell\n  cruxFromId\n  single\n pointParser\n  cells keywordCell\n  inScope latParser longParser\n  cruxFromId\n  titleParser\n   extends abstractPointConfigParser\n  descriptionParser\n   extends abstractPointConfigParser\n extends abstractScrollWithRequirementsParser\n description Uses LeafletJs\n string copyFromExternal leaflet.css leaflet.js\n string requireOnce\n  <link rel="stylesheet" href="leaflet.css">\n  <script src="leaflet.js"></script>\n javascript\n  compileInstance() {\n   const height = 500\n   const id = this._getUid()\n   return `<div id="map${id}" style="height: ${height}px;"></div>\n  <script>\n   {\n    const lat = ${this.get("lat") ?? 37.8}\n    const long = ${this.get("long") ?? 4}\n    const zoomLevel = ${this.get("zoom") ?? 4}\n    const points = ${JSON.stringify(this.findNodes("point").map(node => node.toObject()))}\n    const map = L.map("map${id}").setView([lat, long], zoomLevel)\n    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {\n     attribution: \'<a href="https://www.openstreetmap.org/">OpenStreetMap</a>\',\n     maxZoom: 18\n    }).addTo(map)\n    points.forEach(point => {\n     L.marker([point.lat, point.long])\n      .addTo(map)\n      .bindPopup("<b>" +point.title + "</b><br />" + point.description)\n    })\n   }\n  </script>`\n  }\nhelpfulNotFoundParser\n extends abstractScrollWithRequirementsParser\n catchAllCellType filePathCell\n string copyFromExternal helpfulNotFound.js\n description Add a helpful not found element to the page.\n javascript\n  compileInstance() {\n   return `<style>#helpfulNotFound{margin: 100px 0;}</style><h1 id="helpfulNotFound"></h1><script defer src="/helpfulNotFound.js"></script><script>document.addEventListener("DOMContentLoaded", () => new NotFoundApp(\'${this.content}\'))</script>`\n  }\nabstractPlotParser\n description Use Plot from observablehq.\n extends abstractScrollWithRequirementsParser\n string iris\n  sepal_length,sepal_width,petal_length,petal_width,species\n  6.1,3,4.9,1.8,virginica\n  5.6,2.7,4.2,1.3,versicolor\n  5.6,2.8,4.9,2,virginica\n  6.2,2.8,4.8,1.8,virginica\n  7.7,3.8,6.7,2.2,virginica\n  5.3,3.7,1.5,0.2,setosa\n  6.2,3.4,5.4,2.3,virginica\n  4.9,2.5,4.5,1.7,virginica\n  5.1,3.5,1.4,0.2,setosa\n  5,3.4,1.5,0.2,setosa\n string copyFromExternal d3.js plot.js\n string requireOnce\n  <script src="d3.js"></script>\n  <script src="plot.js"></script>\n example\n  plot\n javascript\n  compileInstance() {\n   const id = "plot" + this._getUid()\n   return `<div id="${id}"></div><script>\n   {\n    let loadChart = async () => {\n    const data = ${this.dataCode}\n    const get = (col, index ) => col !== "undefined" ? col : (index === undefined ? undefined : Object.keys(data[0])[index])\n    document.querySelector("#${id}").append(Plot.plot(${this.plotOptions}))\n    }\n    loadChart()\n    }\n    </script>`\n  }\n  get marks() {\n    // just for testing purposes\n    return `Plot.rectY({length: 10000}, Plot.binX({y: "count"}, {x: d3.randomNormal()}))`\n  }\n  get dataCode() {\n    return \'[]\'\n  }\n  get plotOptions() {\n    return `{\n      title: "${this.get("title") || ""}",\n      subtitle: "${this.get("subtitle") || ""}",\n      caption: "${this.get("caption") || ""}",\n      symbol: {legend: ${this.has("symbol")}},\n      color: {legend: ${this.has("fill")}},\n      grid: ${this.get("grid") !== "false"},\n      marks: [${this.marks}],\n    }`\n  }\nscatterplotParser\n extends abstractPlotParser\n // todo: make copyFromExternal work with inheritance\n string copyFromExternal d3.js plot.js\n javascript\n  get dataCode() {\n    let data = this.iris\n    const dataset = this.getNode("data")\n    const datasetContent = dataset?.content\n    const isUrl = !!datasetContent?.match(/^https?:/)\n    const fileExtension = datasetContent ? datasetContent.split(".").pop() : "csv"\n    if (dataset?.length)\n      data = dataset.childrenToString()\n    else if (datasetContent && !isUrl) {\n      const { Disk } = require("scrollsdk/products/Disk.node.js")\n      const path = require("path")\n      const {file} = this.parent\n      data = Disk.read(path.join(file.folderPath, datasetContent))\n    }\n    let dataString = `d3.${fileExtension}Parse(\\`${data}\\`, d3.autoType)`\n    if (isUrl)\n      dataString = `await d3.${fileExtension}("${datasetContent}")`\n    return dataString\n  }\n  get marks() {\n    const x = this.get("x")\n    const y = this.get("y")\n    const text = this.get("label")\n    return `Plot.dot(data, {\n      x: get("${x}", 0),\n      y: get("${y}", 1),\n      r: get("${this.get("radius")}"),\n      fill: get("${this.get("fill")}"),\n      tip: true,\n      symbol: get("${this.get("symbol")}")} ), Plot.text(data, {x: get("${x}",0), y: get("${y}", 1), text: "${text}", dy: -6, lineAnchor: "bottom"})`\n  }\nslideshowParser\n description Turns a page into a slideshow. A dinkus (***) separates slides. Left and right arrows navigate.\n extends abstractScrollWithRequirementsParser\n string copyFromExternal jquery-3.7.1.min.js slideshow.js\n example\n  slideshow\n  Why did the cow cross the road?\n  ***\n  Because it wanted to go to the MOOOO-vies.\n  ***\n  THE END\n  ****\n javascript\n  compile() {\n   return `<style>html {font-size: var(--base-font-size, 28px);} body {margin: auto; width: 500px;}.slideshowNav{text-align: center; margin-bottom:20px; font-size: 14px;} a{text-decoration: none;</style><script defer src="jquery-3.7.1.min.js"></script><div class="slideshowNav"></div><script defer src="slideshow.js"></script>`\n  }\nsparklineParser\n description Generate a sparkline.\n extends abstractScrollWithRequirementsParser\n example\n  sparkline 1 2 3 4 5\n string copyFromExternal sparkline.js\n string requireOnce <script src="sparkline.js"></script>\n catchAllCellType numberCell\n javascript\n  compileInstance() {\n   const id = "spark" + this._getUid()\n   const data = this.content.split(" ").map(str => parseFloat(str))\n   const start = this.has("start") ? parseInt(this.get("start")) : 0\n   const width = this.get("width") || 100\n   const height = this.get("height") || 30\n   const lineColor = this.get("color") || "black"\n   return `<span id="${id}"></span><script>new Sparkline(document.getElementById("${id}"), {dotRadius: 0, width: ${width}, height: ${height}, lineColor: "${lineColor}", tooltip: (value,index) => ${start} + index + ": " + value}).draw(${JSON.stringify(data)})</script>`\n  }\ntableSearchParser\n extends abstractScrollWithRequirementsParser\n string copyFromExternal jquery-3.7.1.min.js dataTables.dataTables.min.css dataTables.min.js tableSearch.js\n string requireOnce\n  <script defer src="jquery-3.7.1.min.js"></script>\n  <style>.dt-search{font-family: "SF Pro", "Helvetica Neue", "Segoe UI", "Arial";}</style>\n  <link rel="stylesheet" href="dataTables.dataTables.min.css">\n  <script defer src="dataTables.min.js"></script>\n  <script defer src="tableSearch.js"></script>\n description Add table search and sort to all tables on the page.\n javascript\n  compileInstance() {\n   return ""\n  }\nabstractCommentParser\n description Comments do not appear in the compiled HTML.\n catchAllCellType commentCell\n cells commentCell\n extends abstractScrollParser\n baseParser blobParser\n javascript\n  compile() {\n   return ``\n  }\n catchAllParser commentLineParser\ncommentParser\n extends abstractCommentParser\n cruxFromId\nslashCommentParser\n extends commentParser\n crux //\ncounterpointParser\n description A counterpoint. Will not show up in the compiled HTML.\n extends commentParser\n crux !\nprintConceptsParser\n description Print the concepts in a page into an HTML table.\n cruxFromId\n extends abstractCommentParser\n javascript\n   compile() {\n   // A hacky but simple way to do this for now.\n   const node = this.appendSibling("table \\t", this.parent.file.compileConcepts("concepts.tsv", this.get("sortBy")))\n   const html = node.compile()\n   node.destroy()\n   return html\n   }\nthanksToParser\n description A place to store data on reviewers who helped improve a post (and a reminder to seek feedback!). Does not appear in compiled HTML.\n extends abstractCommentParser\n cruxFromId\nprintMeasuresParser\n description Print measures statistics in a page into an HTML table.\n cruxFromId\n extends abstractCommentParser\n javascript\n   compile() {\n   // A hacky but simple way to do this for now.\n   const node = this.appendSibling("table \\t", this.parent.file.compileMeasures("tsv"))\n   const html = node.compile()\n   node.destroy()\n   return html\n   }\ntabularDataParser\n description Root lines with tabs are parsed as tsv data and printed as tables.\n pattern \\t\n extends abstractCommentParser\n javascript\n  compileTxt() {\n    return ""\n  }\n  get headerNode() {\n    return this.isFirst ? this : this.previous.headerNode\n  }\n  compile() {\n    return ""\n  }\n  get isFirst() {\n    return !this.previous.isTabularData\n  }\n  get lastNode() {\n    if (this.next.isTabularData && this.next.lineNumber)\n      return this.next.lastNode\n    return this\n  }\n  applyAftertext(aftertext) {\n    const node = this.parent.appendLineAndChildren("* " + this.getLine(), aftertext + "\\ntag none")\n    const html = node.compile()\n    node.destroy()\n    return html\n  }\n  isTabularData = true\n example\n  // The below lines will print a table\n  printTable\n  Index Name\n  1 Thermos\nloadConceptsParser\n description Load all concepts in all scroll files in a folder and remove any "import" statements.\n extends abstractScrollParser\n cruxFromId\n cells keywordCell filePathCell\n javascript\n  build() {\n   const { Disk } = require("scrollsdk/products/Disk.node.js")\n   const path = require("path")\n   const {file} = this.parent\n   const folder = path.join(file.folderPath, this.getWord(1))\n   const ONE_BIG_FILE = Disk.getFiles(folder).filter(file => file.endsWith(".scroll")).map(Disk.read).filter(str => /^id /mg.test(str)).join("\\n\\n").replace(/import .+/g, "")\n    this.parent.concat(ONE_BIG_FILE)\n   //console.log(ONE_BIG_FILE)\n  }\n  compile() {\n    return ""\n  }\ncssParser\n extends abstractScrollParser\n description Prints CSS content wrapped in a style tag.\n cruxFromId\n catchAllParser cssLineParser\n catchAllCellType cssAnyCell\n javascript\n  compile() {\n   return `<style>${this.css}</style>`\n  }\n  get css() {\n    return this.content ?? this.childrenToString()\n  }\n  compileCss() {\n    return this.css\n  }\nabstractPostLoopParser\n description Do something with all posts. Takes an optional list of folder/group names.\n extends abstractScrollParser\n cruxFromId\n cells keywordCell\n catchAllCellType groupNameWithOptionalFolderCell\n javascript\n  get files() {\n   return this.root.file.getFilesInGroupsForEmbedding(this.getWordsFrom(1))\n  }\nprintFeedParser\n description Prints out the RSS feed for a group.\n extends abstractPostLoopParser\n example\n  printFeed index\n  printFeed cars/index\n  buildRss feed.xml\n javascript\n  compile() {\n   const dayjs = require("dayjs")\n   const file = this.root.file\n   const files = this.files.map(file => file.file)\n   const { title, baseUrl, description } = file\n   return `<?xml version="1.0" encoding="ISO-8859-1" ?>\n  <rss version="2.0">\n  <channel>\n   <title>${title}</title>\n   <link>${baseUrl}</link>\n   <description>${description}</description>\n   <lastBuildDate>${dayjs().format("ddd, DD MMM YYYY HH:mm:ss ZZ")}</lastBuildDate>\n   <language>en-us</language>\n  ${files.map(file => file.toRss()).join("\\n")}\n  </channel>\n  </rss>`\n  }\n  compileTxt() {\n    return this.compile()\n  }\nprintCsvParser\n description Prints out a group as a CSV.\n extends printFeedParser\n example\n  printCsv index\n  buildTxt posts.csv\n javascript\n  compile() {\n   const file = this.root.file\n   const files = file.getFilesInGroupsForEmbedding(this.getWordsFrom(1)).map(file => file.file)\n   const header = file.csvFields\n   return `${header.join(",")}\\n${files.map(file => file.toCsv()).join("\\n")}`\n  }\nprintSourceParser\n description Prints out the source code for each file in a group.\n extends printFeedParser\n example\n  printSource index\n  buildTxt source.txt\n javascript\n  compile() {\n   const file = this.root.file\n   const files = file.getFilesInGroupsForEmbedding(this.getWordsFrom(1)).map(file => file.file)\n   return `${files.map(file => file.filePath + "\\n " + file.originalScrollCode.replace(/\\n/g, "\\n ") ).join("\\n")}`\n  }\nprintSearchTableParser\n description Prints out all pages into an HTML table that can be searched.\n extends abstractPostLoopParser\n example\n  printSearchTable\n  tableSearch\n javascript\n  compile() {\n   const file = this.root.file\n   const files = this.files\n   const data = files.map(file => file.file.toSearchTsvRow(file.relativePath)).join("\\n")\n   // A hacky but simple way to do this for now.\n   const node = this.appendSibling("table \\t", "title titleLink text date wordCount minutes".replace(/ /g, "\\t") + "\\n" + data)\n   const html = node.compile()\n   node.destroy()\n   return html\n  }\nprintSiteMapParser\n extends abstractPostLoopParser\n description Prints out a plain text sitemap.\n example\n  baseUrl http://test.com\n  printSiteMap\n javascript\n  compile() {\n   const file = this.root.file\n   const { baseUrl } = file\n   return this.files.map(file => baseUrl + file.relativePath + file.file.permalink).join("\\n")\n  }\n  compileTxt() {\n    return this.compile()\n  }\ndashboardParser\n description Display key stats in a big font.\n catchAllParser rowParser\n cruxFromId\n extends abstractScrollParser\n example\n  dashboard\n   #2 Popularity\n   30 Years Old\n   $456 Revenue\n javascript\n  get tableBody() {\n   const items = this.topDownArray\n   let str = ""\n   for (let i = 0; i < items.length; i = i + 3) {\n    str += this.makeRow(items.slice(i, i + 3))\n   }\n   return str\n  }\n  makeRow(items) {\n   return `<tr>` + items.map(node => `<td>${node.firstWord}<span>${node.content}</span></td>`).join("\\n") + `</tr>\\n`\n  }\n  compile() {\n   return `<table class="scrollDashboard">${this.tableBody}</table>`\n  }\n  compileTxt() {\n    return this.childrenToString()\n  }\nprintDateParser\n extends abstractScrollParser\n description Prints the date set in the file. If not present computes the date from the file\'s ctime.\n cruxFromId\n cells keywordCell\n javascript\n  compile() {\n   return `<div style="text-align: center;" class="scrollDateline">${this.day}</div>`\n  }\n  get day() {\n   let day = this.content || this.root.get("date") || this.root.file?.date\n   if (!day) return ""\n   try {\n    const dayjs = require("dayjs")\n    return dayjs(day).format(`MMMM D, YYYY`)\n   } catch (err) {\n    console.error(err)\n   }\n   return day || ""\n  }\n  compileTxt() {\n    return this.day\n  }\nbelowAsCodeParser\n description Print the Scroll code of the next node.\n extends abstractScrollParser\n catchAllCellType integerCell\n cruxFromId\n javascript\n  method = "next"\n  get code() {\n   const { method } = this\n   let code = ""\n   \n   let nodes = []\n   let next = this[method]\n   let {howMany} = this\n   while (howMany) {\n    nodes.push(next)\n    next = next[method]\n    howMany--\n   }\n   if (this.reverse) nodes.reverse()\n   return nodes.map(node => node.asString).join("\\n")\n  }\n  reverse = false\n  compile() {\n   return `<code class="scrollCodeBlock">${this.code.replace(/\\</g, "&lt;")}</code>`\n  }\n  get howMany() {\n    let howMany = parseInt(this.getWord(1))\n   if (!howMany || isNaN(howMany)) howMany = 1\n   return howMany\n  }\nbelowAsCodeUntilParser\n description Same as belowAsCode, except you can provide a search string to find the line where printing should stop.\n extends belowAsCodeParser\n catchAllCellType anyCell\n javascript\n  get howMany() {\n    let howMany = 1\n    const query = this.content\n    let node = this.next\n    while (node !== this) {\n      if (node.getLine().startsWith(query))\n        return howMany\n      node = node.next\n      howMany++\n    }\n    return howMany\n  }\naboveAsCodeParser\n description Print the Scroll code for the previous node.\n extends belowAsCodeParser\n javascript\n  method = "previous"\n  reverse = true\nabstractThemeCssParser\n description Extend this to create a Scroll CSS theme.\n extends abstractScrollParser\n inScope themeTagsParser\n cruxFromId\n catchAllCellType stringCell\n string scrollStyles\n  figure\n   margin 0\n   padding 0\n  .dropcap:first-letter\n   font-size 3rem\n   line-height .9em\n   margin-right .125rem\n   display block\n   float left\n  .dinkus\n   text-align center\n   padding 1rem\n   span\n    vertical-align sub\n  details\n   margin-top 10px\n  summary\n   font-family "SF Pro", "Helvetica Neue", "Segoe UI", "Arial"\n   cursor pointer\n  .scrollCaptionedFigure\n   display block\n   break-inside avoid\n   text-align center\n   img\n    max-width 100%\n    height auto\n    margin-top .1875rem\n   figcaption\n    font-family "SF Pro", "Helvetica Neue", "Segoe UI", "Arial"\n    font-size .8rem\n    .scrollParagraph\n     margin-top 0\n  .scrollCodeBlock\n   overflow auto\n   font-size .8rem\n   hyphens none\n   white-space pre\n   break-inside avoid\n   display block\n   margin .5rem 0\n   padding .5rem\n   border-radius 0\n   position relative\n  .scrollCodeBlock:hover\n   .scrollCopyButton\n    opacity .5\n   .scrollCopyButton:hover\n    opacity .8\n   .scrollCopyButton:active\n    opacity 1\n  .scrollCopyButton\n   position absolute\n   top .125rem\n   right .125rem\n   font-size .875rem\n   cursor pointer\n   opacity 0\n  .scrollCopyButton::after\n   content "[ ]"\n  .scrollCopiedButton::after\n   content "[✓]"\n javascript\n  compile() {\n   return `<style>\\n${this.css}\\n</style>`\n  }\n  compileTxt() {\n    return ""\n  }\n  compileCss() {\n    return this.css\n  }\n  compileEmbeddedVersion() {\n   return ""\n  }\n  get scrollCss() {\n    const hakonParser = this.root.hakonParser\n    return new hakonParser(this.scrollStyles).compile()\n  }\ngazetteCssParser\n description The default Scroll theme.\n extends abstractThemeCssParser\n javascript\n  get css() {\n    if (this.constructor._cachedCss)\n      return this.constructor._cachedCss\n    const hakonParser = this.root.hakonParser\n    this.constructor._cachedCss = this.scrollCss + new hakonParser([this.hakonReset, this.hakonStandardStyles].join("\\n")).compile()\n    return this.constructor._cachedCss\n  }\n // CSS Reset\n string hakonReset\n  html,body,div,span,p,ol,ul,li,table,figure\n   margin 0\n   padding 0\n   border 0\n   vertical-align baseline\n   border-spacing 0\n  ol,ul\n   padding-left 1rem\n  li\n   margin-top .4rem\n   line-height 1.4\n  a\n   text-decoration-color transparent\n  a:hover\n   text-decoration-color initial\n  sup,sub\n   vertical-align baseline\n   position relative\n   top -.375rem\n  sub\n   top .375rem\n  html\n   padding .25rem\n   background-color rgb(244,244,244)\n   font-family Exchange,Georgia,serif\n   color #000\n   font-size var(--base-font-size, 16px)\n   hyphens auto\n  p\n   margin-top .4rem\n   line-height 1.4rem\n  .scrollQuote\n   break-inside avoid\n   display block\n   margin .5rem 0\n   padding .5rem\n   background rgba(204,204,204,.5)\n   white-space pre-line\n   border-left .5rem solid rgba(204,204,204,.8)\n  code\n   font-size .9rem\n   background-color rgba(204,204,204,.5)\n   padding .125rem .25rem\n   border-radius .25rem\n // Styles for Scroll standard tags\n string hakonStandardStyles\n  comment Main body of both pages is similar\n  .scrollParagraph\n   text-align justify\n  .scrollColumns\n   column-count auto\n   column-fill balance\n   column-width 35ch\n   column-gap 1.5rem\n   padding-left 1.25rem\n   padding-right 1.25rem\n   margin auto\n  comment On group pages add some spacing around files\n  .scrollSnippetContainer\n   padding 1ch 0\n   break-inside avoid\n   text-align justify\n  h1,h2,h3,h4\n   margin .625rem 0\n  h1\n   font-size 1.25rem\n  h2\n   font-size 1.125rem\n  h3,h4\n   font-size 1rem\n  h1.scrollTitle\n   text-align center\n   margin auto\n   margin-bottom .15625rem\n   margin-top 0\n   font-size 1.75rem\n   comment On narrow browsers like phones make sure the title doesn\'t overlap with the icons buttons in top left and right.\n   max-width calc(100vw - 2 * (1.5625rem + 1.875rem))\n   a\n    color #000\n  .scrollDateline\n   font-style italic\n   line-height 1.4rem\n   comment Decrease font size to deemphasize dateline but keep the line height the same to not cause different line spacing.\n   font-size .75rem\n  .scrollSection\n   break-inside avoid\n   h1,h2,h3,h4\n    text-align center\n  h4.scrollQuestion\n   text-align left\n   margin 1.4rem 0 0 0\n  .scrollSection:first-child\n   h1,h2,h3,h4\n    margin-top 0\n   h4.scrollQuestion\n    margin-top 0\n  .scrollNoteLink\n   opacity .4\n   text-decoration none\n   &:hover\n    opacity 1\n  .scrollFootNoteUsageLink\n   opacity .7\n   text-decoration none\n   &:hover\n    opacity 1\n  \n  .scrollHoverNote\n   text-decoration underline dashed 1px rgba(0,0,0,.1)\n   cursor default\n  \n  .scrollCodeBlock\n   border-left .5rem solid rgba(204,204,204,.8)\n  \n  .scrollTable\n   table-layout fixed\n   font-family "SF Pro", "Helvetica Neue", "Segoe UI", "Arial"\n   margin .5rem 0\n   overflow hidden\n   font-size .8rem\n   width 100%\n   hyphens none\n   border 1px solid rgba(224,224,224,.8)\n   td,th\n    padding .1875rem\n    overflow hidden\n    white-space nowrap\n   th\n    text-transform capitalize\n    border-bottom 2px solid rgba(0,0,0,.6)\n    text-align left\n   td\n    cursor zoom-in\n   tr:nth-child(even)\n    background rgba(224,224,224,.6)\n  .scrollTable.expandedTable\n   table-layout unset\n   background white\n   position relative\n   z-index 10\n   overflow unset\n   td,th\n    overflow unset\n    white-space unset\n   td\n    cursor zoom-out\n  \n  .scrollByLine\n   font-size .875rem\n   font-style italic\n   margin .25rem 0\n   text-align center\n  \n  comment View source badge\n  .scrollViewSourceBadge\n   text-align right\n   position absolute\n   display block\n   right 20px\n   top 8px\n   svg\n    width 24px\n    height 24px\n    fill rgba(204,204,204,0.8)\n   svg:hover\n    fill #333\n  comment Subtle "Article Source" link\n  .scrollViewSource\n   text-align center\n   font-family Verdana\n   font-weight 100\n   a\n    color rgba(204,204,204,.5)\n    &:hover\n     color #333\n  \n  .scrollContinueReadingLink\n   display block\n   text-align center\n  \n  .scrollDashboard\n   width 100%\n   font-size 1.875rem\n   text-align center\n   font-weight bold\n   break-inside avoid\n   margin-top .5rem\n   margin-bottom .5rem\n   td\n    width 33.3%\n    border 1px solid #e8e8e8\n   span\n    font-size 1.25rem\n    display block\n  .scrollChat\n   span\n    font-family Verdana\n    margin-top .3125rem\n    padding .3125rem 1.25rem\n    border-radius .9375rem\n    display inline-block\n  .scrollChatLeft\n   span\n    background rgba(204,204,204, .5)\n  .scrollChatRight\n   span\n    color white\n    background rgb(0,132,255)\n  .scrollYouTubeHolder\n   position relative\n   width 100%\n   height 0\n   padding-bottom 56.25%\n  .scrollYouTubeEmbed\n   position absolute\n   top 0\n   left 0\n   width 100%\n   height 100%\ntufteCssParser\n description A theme built using Tufte CSS. https://github.com/edwardtufte/tufte-css\n extends abstractThemeCssParser\n javascript\n  get css() {\n    return this.scrollCss + this.tufteCss\n  }\n  tufteCss = `html {\n     font-size: 15px;\n  }\n   body {\n       width: 87.5%;\n       margin-left: auto;\n       margin-right: auto;\n       padding-left: 12.5%;\n       font-family: Palatino, "Palatino Linotype", "Palatino LT STD", "Book Antiqua", Georgia, serif;\n       background-color: #fffff8;\n       color: #111;\n       max-width: 1400px;\n       counter-reset: sidenote-counter;\n  }\n  /* Adds dark mode */\n   @media (prefers-color-scheme: dark) {\n       body {\n           background-color: #151515;\n           color: #ddd;\n      }\n  }\n   h1 {\n       font-weight: 400;\n       margin-top: 3rem;\n       margin-bottom: 1.5rem;\n       font-size: 2.4rem;\n       line-height: 1;\n  }\n  .scrollTitle a { text-decoration: none; font-size: 3.2rem;}\n  .scrollParagraph { text-align: justify; hyphens: auto;}\n  a.scrollNoteLink { text-decoration: none;}\n   h2 {\n       font-style: italic;\n       font-weight: 400;\n       margin-top: 2.1rem;\n       margin-bottom: 1.4rem;\n       font-size: 2.2rem;\n       line-height: 1;\n  }\n   h3 {\n       font-style: italic;\n       font-weight: 400;\n       font-size: 1.7rem;\n       margin-top: 2rem;\n       margin-bottom: 1.4rem;\n       line-height: 1;\n  }\n   hr {\n       display: block;\n       height: 1px;\n       width: 55%;\n       border: 0;\n       border-top: 1px solid #ccc;\n       margin: 1em 0;\n       padding: 0;\n  }\n   p.subtitle {\n       font-style: italic;\n       margin-top: 1rem;\n       margin-bottom: 1rem;\n       font-size: 1.8rem;\n       display: block;\n       line-height: 1;\n  }\n   .numeral {\n       font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;\n  }\n   .danger {\n       color: red;\n  }\n   article {\n       padding: 5rem 0rem;\n  }\n   section {\n       padding-top: 1rem;\n       padding-bottom: 1rem;\n  }\n   p, dl, ol, ul {\n       font-size: 1.4rem;\n       line-height: 2rem;\n  }\n   p {\n       margin-top: 1.4rem;\n       margin-bottom: 1.4rem;\n       padding-right: 0;\n       vertical-align: baseline;\n  }\n  /* Chapter Epigraphs */\n   div.epigraph {\n       margin: 5em 0;\n  }\n   div.epigraph > blockquote {\n       margin-top: 3em;\n       margin-bottom: 3em;\n  }\n   div.epigraph > blockquote, div.epigraph > blockquote > p {\n       font-style: italic;\n  }\n   div.epigraph > blockquote > footer {\n       font-style: normal;\n  }\n   div.epigraph > blockquote > footer > cite {\n       font-style: italic;\n  }\n  /* end chapter epigraphs styles */\n   blockquote {\n       font-size: 1.4rem;\n  }\n   blockquote p {\n       width: 55%;\n       margin-right: 40px;\n  }\n   blockquote footer {\n       width: 55%;\n       font-size: 1.1rem;\n       text-align: right;\n  }\n   section > p, section > footer, section > table {\n       width: 55%;\n  }\n  /* 50 + 5 == 55, to be the same width as paragraph */\n   section > dl, section > ol, section > ul {\n       width: 50%;\n       -webkit-padding-start: 5%;\n  }\n   dt:not(:first-child), li:not(:first-child) {\n       margin-top: 0.25rem;\n  }\n  /* Links: replicate underline that clears descenders */\n   a:link, a:visited {\n       color: inherit;\n  }\n  /* Sidenotes, margin notes, figures, captions */\n   img {\n       max-width: 100%;\n  }\n   .sidenote, .marginnote {\n       float: right;\n       clear: right;\n       margin-right: -60%;\n       width: 50%;\n       margin-top: 0.3rem;\n       margin-bottom: 0;\n       font-size: 1.1rem;\n       line-height: 1.3;\n       vertical-align: baseline;\n       position: relative;\n  }\n   .sidenote-number {\n       counter-increment: sidenote-counter;\n  }\n   .sidenote-number:after, .sidenote:before {\n       font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;\n       position: relative;\n       vertical-align: baseline;\n  }\n   .sidenote-number:after {\n       content: counter(sidenote-counter);\n       font-size: 1rem;\n       top: -0.5rem;\n       left: 0.1rem;\n  }\n   .sidenote:before {\n       content: counter(sidenote-counter) " ";\n       font-size: 1rem;\n       top: -0.5rem;\n  }\n   blockquote .sidenote, blockquote .marginnote {\n       margin-right: -82%;\n       min-width: 59%;\n       text-align: left;\n  }\n   div.fullwidth, table.fullwidth {\n       width: 100%;\n  }\n   div.table-wrapper {\n       overflow-x: auto;\n       font-family: "Trebuchet MS", "Gill Sans", "Gill Sans MT", sans-serif;\n  }\n   .sans {\n       font-family: "Gill Sans", "Gill Sans MT", Calibri, sans-serif;\n       letter-spacing: 0.03em;\n  }\n   code, pre > code {\n       font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;\n       font-size: 1rem;\n       line-height: 1.42;\n       -webkit-text-size-adjust: 100%;\n      /* Prevent adjustments of font size after orientation changes in iOS. See https://github.com/edwardtufte/tufte-css/issues/81#issuecomment-261953409 */\n  }\n   .sans > code {\n       font-size: 1.2rem;\n  }\n   h1 > code, h2 > code, h3 > code {\n       font-size: 0.8em;\n  }\n   .marginnote > code, .sidenote > code {\n       font-size: 1rem;\n  }\n   pre > code {\n       font-size: 0.9rem;\n       width: 52.5%;\n       margin-left: 2.5%;\n       overflow-x: auto;\n       display: block;\n  }\n   pre.fullwidth > code {\n       width: 90%;\n  }\n   .fullwidth {\n       max-width: 90%;\n       clear: both;\n  }\n   span.newthought {\n       font-variant: small-caps;\n       font-size: 1.2em;\n  }\n   input.margin-toggle {\n       display: none;\n  }\n   label.sidenote-number {\n       display: inline-block;\n       max-height: 2rem;\n      /* should be less than or equal to paragraph line-height */\n  }\n   label.margin-toggle:not(.sidenote-number) {\n       display: none;\n  }\n   .iframe-wrapper {\n       position: relative;\n       padding-bottom: 56.25%;\n      /* 16:9 */\n       padding-top: 25px;\n       height: 0;\n  }\n   .iframe-wrapper iframe {\n       position: absolute;\n       top: 0;\n       left: 0;\n       width: 100%;\n       height: 100%;\n  }\n   @media (max-width: 760px) {\n       body {\n           width: 84%;\n           padding-left: 8%;\n           padding-right: 8%;\n      }\n       hr, section > p, section > footer, section > table {\n           width: 100%;\n      }\n       pre > code {\n           width: 97%;\n      }\n       section > dl, section > ol, section > ul {\n           width: 90%;\n      }\n       blockquote {\n           margin-left: 1.5em;\n           margin-right: 0em;\n      }\n       blockquote p, blockquote footer {\n           width: 100%;\n      }\n       label.margin-toggle:not(.sidenote-number) {\n           display: inline;\n      }\n       .sidenote, .marginnote {\n           display: none;\n      }\n       .margin-toggle:checked + .sidenote, .margin-toggle:checked + .marginnote {\n           display: block;\n           float: left;\n           left: 1rem;\n           clear: both;\n           width: 95%;\n           margin: 1rem 2.5%;\n           vertical-align: baseline;\n           position: relative;\n      }\n       label {\n           cursor: pointer;\n      }\n       div.table-wrapper, table {\n           width: 85%;\n      }\n       img {\n           width: 100%;\n      }\n  }`\nhtmlParser\n description A catch all block to drop in any loose html. Use for HTML one liners and/or blocks of HTML.\n cruxFromId\n extends abstractScrollParser\n catchAllParser htmlLineParser\n catchAllCellType htmlAnyCell\n javascript\n  compile() {\n   return `${this.content ?? ""}${this.childrenToString()}`\n  }\n  compileTxt() {\n    return ""\n  }\nquickHtmlParser\n extends htmlParser\n cells htmlAnyCell\n pattern ^<\n description Start a line with a less than sign to immediately write HTML\n javascript\n  compile() {\n   return `${this.getLine() ?? ""}${this.childrenToString()}`\n  }\nstumpParser\n cruxFromId\n extends abstractScrollParser\n description Stump is a Tree Language that compiles to HTML.\n catchAllParser stumpContentParser\n javascript\n  compile() {\n   const file = this.parent.file\n   return file.compileStumpCode(this.childrenToString())\n  }\nstumpNoSnippetParser\n extends stumpParser\n description Useful for headers and footers when you have something you don\'t want included in snippets.\n cruxFromId\n javascript\n  compileEmbeddedVersion() {\n   return ""\n  }\nabstractCaptionedParser\n extends abstractScrollParser\n cells keywordCell urlCell\n inScope captionAftertextParser slashCommentParser\n cruxFromId\n javascript\n  compile(compileSettings) {\n   const caption = this.getNode("caption")\n   const captionFig = caption ? `<figcaption>${caption.compile()}</figcaption>` : ""\n   return `<figure class="scrollCaptionedFigure">${this.getFigureContent(compileSettings)}${captionFig}</figure>`\n  }\nimageParser\n description An img tag.\n extends abstractCaptionedParser\n inScope classMarkupParser aftertextIdParser linkParser linkTargetParser\n openGraphParser\n  description Add this line to make this the open graph image.\n  cruxFromId\n  cells keywordCell\n javascript\n  getFigureContent(compileSettings) {\n   const file = this.root.file\n   const src = this.getWord(1)\n   const linkRelativeToCompileTarget = (compileSettings ? (compileSettings.relativePath ?? "") : "") + src\n   let dimensionAttributes = ""\n   // If its a local image, get the dimensions and put them in the HTML\n   // to avoid flicker\n   if (!src.startsWith("http:") && !src.startsWith("https:")) {\n    try {\n     const sizeOf = require("image-size")\n     const path = require("path")\n     const fullImagePath = path.join(file.folderPath, src)\n     const dimensions = sizeOf(fullImagePath)\n     const width = dimensions.width\n     const height = dimensions.height\n     dimensionAttributes = `width="${width}" height="${height}" `\n    } catch (err) {\n     console.error(err)\n    }\n   }\n   // Todo: can we reuse more code from aftertext?\n   const className = this.has("class") ? ` class="${this.get("class")}" ` : ""\n   const id = this.has("id") ? ` id="${this.get("id")}" ` : ""\n   const clickLink = this.get("link") || linkRelativeToCompileTarget\n   const target = this.has("target") ? this.get("target") : (this.has("link") ? "" : "_blank")\n   return `<a href="${clickLink}" target="${target}" ${className} ${id}><img src="${linkRelativeToCompileTarget}" ${dimensionAttributes}loading="lazy"></a>`\n  }\n  compileTxt() {\n    const children = this.filter(node => node.compileTxt).map(node => node.compileTxt()).filter(i => i).join("\\n")\n    return  "[Image Omitted]" + (children ? "\\n " + children.replace(/\\n/g, "\\n ") : "")\n  }\nyouTubeParser\n extends abstractCaptionedParser\n description Embed a YouTube video. Include the YouTube embed URL such as https://www.youtube.com/embed/CYPYZnVQoLg\n javascript\n  getFigureContent() {\n   const url = this.getWord(1).replace("youtube.com/watch?v=", "youtube.com/embed/")\n   return `<div class="scrollYouTubeHolder"><iframe class="scrollYouTubeEmbed" src="${url}" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>`\n  }\nimportParser\n description Import one file into another.\n cruxFromId\n extends abstractScrollParser\n catchAllCellType filePathCell\n javascript\n  compile() {\n   return ""\n  }\n example\n  import header.scroll\nkeyboardNavParser\n description Makes left go to previous file and right go to next file.\n extends abstractScrollParser\n cruxFromId\n catchAllCellType urlCell\n javascript\n  compileEmbeddedVersion() {\n   return ""\n  }\n  compile() {\n   const file = this.root.file\n   const linkToPrevious = this.getWord(1) ?? file.linkToPrevious\n   const linkToNext = this.getWord(2) ?? file.linkToNext\n   const script = `<script>document.addEventListener(\'keydown\', function(event) {\n    if (document.activeElement !== document.body) return\n    const getLinks = () => document.getElementsByClassName("scrollKeyboardNav")[0].getElementsByTagName("a")\n    if (event.key === "ArrowLeft")\n      getLinks()[0].click()\n    else if (event.key === "ArrowRight")\n      getLinks()[1].click()\n   });</script>`\n   return `<div class="scrollKeyboardNav" style="display:none;"><a href="${linkToPrevious}">${linkToPrevious}</a> · ${file.permalink} · <a href="${linkToNext}">${linkToNext}</a>${script}</div>`\n  }\nabstractMeasureParser\n cells measureNameCell\n cruxFromId\n boolean isMeasure true\n float sortIndex 1.9\n boolean isComputed false\n string typeForCsvDocs unspecified\n extends abstractScrollParser\n javascript\n  compileEmbeddedVersion() {\n   return ""\n  }\n  compile() {\n   return ""\n  }\n  get measureValue() {\n    return this.content ?? ""\n  }\n  get measureName() {\n    return this.getFirstWordPath().replace(/ /g, "_")\n  }\nabstractWordMeasureParser\n description A measure that contains a single word.\n cells measureNameCell wordCell\n string typeForCsvDocs word\n extends abstractMeasureParser\nabstractUrlMeasureParser\n string typeForCsvDocs url\n cells measureNameCell urlCell\n extends abstractWordMeasureParser\nabstractStringMeasureParser\n string typeForCsvDocs string\n catchAllCellType stringCell\n extends abstractMeasureParser\nabstractIdParser\n crux id\n description What is the ID of this concept?\n extends abstractStringMeasureParser\n float sortIndex 1\n boolean isMeasureRequired true\n boolean isConceptDelimiter true\n javascript\n  getErrors() {\n    const errors = super.getErrors()\n    let requiredMeasureNames = this.parent.file.measures.filter(measure => measure.isMeasureRequired).map(measure => measure.Name).filter(name => name !== "id")\n    if (!requiredMeasureNames.length) return errors\n    let next = this.next\n    while (requiredMeasureNames.length && next.firstWord !== "id" && next.getIndex() !== 0) {\n      requiredMeasureNames = requiredMeasureNames.filter(i => i !== next.firstWord)\n      next = next.next\n    }\n    requiredMeasureNames.forEach(name => {\n      errors.push({toObject: () => {return { message: `Concept "${this.content}" is missing required measure "${name}".`}}})\n    })\n    return errors\n  }\nabstractNumericMeasureParser\n string typeForCsvDocs number\n extends abstractMeasureParser\n javascript\n  get measureValue() {\n    const {content} = this\n    return content === undefined ? "" : parseFloat(content)\n  }\nabstractIntegerMeasureParser\n string typeForCsvDocs integer\n cells measureNameCell integerCell\n extends abstractNumericMeasureParser\nabstractFloatMeasureParser\n cells measureNameCell floatCell\n extends abstractNumericMeasureParser\nabstractPercentageMeasureParser\n cells measureNameCell percentCell\n extends abstractNumericMeasureParser\n javascript\n  get measureValue() {\n    const {content} = this\n    return content === undefined ? "" : parseFloat(content)\n  }\nabstractEnumMeasureParser\n string typeForCsvDocs enum\n cells measureNameCell enumCell\n extends abstractMeasureParser\nabstractBooleanMeasureParser\n string typeForCsvDocs boolean\n cells measureNameCell booleanCell\n extends abstractMeasureParser\n javascript\n  get measureValue() {\n    const {content} = this\n    return content === undefined ? "" : content == "true"\n  }\nmetaTagsParser\n cruxFromId\n extends abstractScrollParser\n description Prints meta tags like title, description, et cetera.\n javascript\n  compileEmbeddedVersion() {\n   return ""\n  }\n  compile() {\n   const { file } = this.parent\n   const { title, description, openGraphImage, SCROLL_VERSION, canonicalUrl } = file\n   const rssFeedUrl = this.parent.get("rssFeedUrl")\n   let rssTag = ""\n   if (rssFeedUrl)\n    rssTag = `<link rel="alternate" type="application/rss+xml" title="${title}" href="${rssFeedUrl}">`\n   // todo: cleanup the head/body stuff.\n   return `<head>\n   <meta charset="utf-8">\n   <title>${title}</title>\n   <script>/* This HTML was generated by 📜 Scroll v${SCROLL_VERSION}. https://scroll.pub */</script>\n   <style>@media print {.doNotPrint {display: none !important;}}</style>\n   <link rel="canonical" href="${canonicalUrl}">\n   <meta name="viewport" content="width=device-width,initial-scale=1">\n   <meta name="description" content="${description}">\n   <meta name="generator" content="Scroll v${SCROLL_VERSION}">\n   <meta property="og:title" content="${title}">\n   <meta property="og:description" content="${description}">\n   <meta property="og:image" content="${openGraphImage}">\n   ${rssTag}\n   <meta name="twitter:card" content="summary_large_image">\n  </head>\n  <body>`\n  }\npageFooterParser\n cruxFromId\n description A footer for your page.\n extends abstractScrollParser\n string hakon\n  .pageFooter\n   margin-top 8px\n   padding-top 8px\n   text-align center\n   svg\n    width 30px\n    height 30px\n    fill rgba(204,204,204, .5)\n    padding 0 7px\n    &:hover\n     fill #333\n  .pageFooterScrollLink\n   font-family Verdana\n   font-weight 100\n   margin .5em\n   a\n    color rgba(204,204,204,.5)\n    &:hover\n     color #333\n     text-decoration none\n javascript\n  compileEmbeddedVersion() {\n   return ""\n  }\n  get css() {\n    const hakonParser = this.root.hakonParser\n    return new hakonParser(this.hakon).compile()\n  }\n  compile() {\n   const file = this.parent.file\n   const { SVGS, SCROLL_VERSION, viewSourceUrl } = file\n   const closeContainerTag = "</div>"\n   const emailLink = file.email ? `a ${SVGS.email}\n    href mailto:${file.email}` : ""\n   const downloadLink = file.downloadUrl ? `a ${SVGS.download}\n    href ${file.downloadUrl}` : ""\n   const gitLink = file.viewSourceUrl ? `a ${SVGS.git}\n    title View Source\n    href ${file.viewSourceUrl}` : ""\n   return (\n    closeContainerTag + `<style>${this.css}</style>` +\n    file.compileStumpCode(`p\n   class scrollViewSource doNotPrint\n  div\n   class pageFooter doNotPrint\n   ${emailLink}\n   ${downloadLink}\n   ${gitLink}\n   div\n    class pageFooterScrollLink\n    a Built with Scroll v${SCROLL_VERSION}\n     href https://scroll.pub`)\n   )\n  }\npageHeaderParser\n cruxFromId\n description A header for your page.\n extends abstractScrollParser\n string hakon\n  .pageHeader\n   position absolute\n   top .25rem\n   right 0\n   left 0\n   svg\n    width 1.875rem\n    height 1.875rem\n    fill rgba(204,204,204,.8)\n    &:hover\n     fill #333\n   a\n    color rgba(204,204,204,.8)\n    position absolute\n    font-size 1.875rem\n    line-height 1.7rem\n    text-decoration none\n    &:hover\n     color #333\n javascript\n  compileEmbeddedVersion() {\n   return ""\n  }\n  get css() {\n    const hakonParser = this.root.hakonParser\n    return new hakonParser(this.hakon).compile()\n  }\n  compile() {\n   const file = this.parent.file\n   const { SVGS, linkToPrevious, linkToNext, viewSourceUrl } = file\n   let previousButton = ""\n   if (linkToPrevious)\n    previousButton = `a &lt;\n    style left:.1875rem;\n    href ${linkToPrevious}`\n   let nextButton = ""\n   if (linkToNext)\n    nextButton = `a &gt;\n    style right:.1875rem;\n    href ${linkToNext}`\n   const gitLink = file.viewSourceUrl ? `a ${SVGS.git}\n    style text-align:right;right: 1.5625rem;\n    title View Source\n    href ${file.viewSourceUrl}` : ""\n   return `<style>\\n${this.css}\\n</style>` + file.compileStumpCode(`div\n   class pageHeader doNotPrint\n   ${previousButton}\n   a ${SVGS.home}\n    style text-align:left;left:1.5625rem;\n    href ${file.get("homeUrl") || "index.html"}\n   ${gitLink}\n   ${nextButton}`)\n  }\nscrollParserDefinitionParser\n extends abstractScrollParser\n // todo Figure out best pattern for merging Scroll and Parsers?\n pattern ^[a-zA-Z0-9_]+Parser$\n description Define your own Parsers.\n baseParser blobParser\n javascript\n  compile() {\n   return ""\n  }\nquoteParser\n cruxFromId\n description A quote.\n catchAllParser quoteLineParser\n extends abstractScrollParser\n javascript\n  compile() {\n   return `<blockquote class="scrollQuote">${this.childrenToString()}</blockquote>`\n  }\n  compileTxt() {\n    return this.childrenToString()\n  }\nreadingListParser\n extends abstractScrollParser\n description Easily create a reading list with links, titles, and author names.\n cells keywordCell\n cruxFromId\n catchAllParser readingListItemParser\n example\n  readingList\n   https://example.com/similar by Author Name\n javascript\n  compile() {\n   return `<br><ul>${this.map(child => child.compile()).join("\\n")}</ul>`\n  }\nredirectToParser\n description Prints an HTML redirect tag. In the future might also emit nginx config.\n extends abstractScrollParser\n cells keywordCell urlCell\n cruxFromId\n example\n  redirectTo https://scroll.pub/releaseNotes.html\n javascript\n  compile() {\n   return `<meta http-equiv="Refresh" content="0; url=\'${this.getWord(1)}\'" />`\n  }\nprintRelatedListParser\n description Prints a list of related posts with years.\n extends abstractScrollParser\n cruxFromId\n cells keywordCell\n javascript\n  compile() {\n   const file = this.root.file\n   const ids = this.root.get("related")?.split(" ") || []\n   return ids.map(id => {\n    // get title, permalink, and year\n    const {title, permalink, year} = file.getFileFromId(id)\n    const node = this.appendSibling(`- ${title}${year ? " (" + year + ")" : ""}`, `link ${permalink}`)\n    // A hacky but simple way to do this for now.\n    const html = node.compile()\n    node.destroy()\n    return html\n   }).join("\\n")\n  }\n  compileTxt() {\n   // Todo: reuse code between these 2 methods.\n   const file = this.root.file\n   const ids = this.root.get("related")?.split(" ") || []\n   return ids.map(id => {\n    // get title, permalink, and year\n    const {title, permalink, year} = file.getFileFromId(id)\n    const link = file.ensureAbsoluteLink(permalink)\n    return `- ${title}${year ? " (" + year + ")" : ""}\\n ${link}`\n  }).join("\\n")\n  }\nabstractVariableParser\n extends abstractScrollParser\n catchAllCellType stringCell\n cruxFromId\n javascript\n  isTopMatter = true\n  compile() {\n   return ""\n  }\nreplaceParser\n description Define a variable token and replacement that will be applied to all lines before and after this one.\n extends abstractVariableParser\n baseParser blobParser\n example\n  replace YEAR 2022\nreplaceJsParser\n description Define a variable token and replacement that will be applied to all lines before and after this one.\n extends replaceParser\n catchAllCellType javascriptCell\n example\n  replaceJs SUM 1+1\n  * 1+1 = SUM\nreplaceNodejsParser\n description Write nodejs code inside a Scroll file. Sort of like PHP.\n extends abstractVariableParser\n catchAllCellType javascriptCell\n baseParser blobParser\n example\n  replaceNodejs\n   module.exports = {SCORE : 1 + 2}\n  * The score is SCORE\nscriptParser\n extends abstractScrollParser\n description Prints Javascript content wrapped in script tags.\n cruxFromId\n catchAllParser scriptLineParser\n catchAllCellType scriptAnyCell\n javascript\n  compile() {\n   return `<script>${this.scriptContent}</script>`\n  }\n  get scriptContent() {\n    return this.content ?? this.childrenToString()\n  }\n  compileJs() {\n    return this.scriptContent\n  }\nendSnippetParser\n description Insert one of these where you want to cut the file for a snippet.\n extends abstractScrollParser\n cruxFromId\n javascript\n  compile() {\n   return ""\n  }\nstampParser\n description Share entire folders as plain text.\n extends abstractScrollParser\n inScope stampFolderParser\n catchAllParser stampFileParser\n example\n  stamp\n   .gitignore\n    *.html\n   readme.scroll\n    # Hello world\n    <script src="scripts/nested/hello.js"></script>\n   scripts/\n    nested/\n     hello.js\n      console.log("Hello world")\n cruxFromId\n cells keywordCell\n javascript\n  build() {\n    const dir = this.root.file.folderPath\n    this.forEach(node => node.build(dir))\n  }\nabstractTableParser\n cruxFromId\n catchAllParser rowParser\n extends abstractScrollParser\n javascript\n  get tableHeader() {\n   return this.columns.filter(col => !col.isLink).map(column => `<th>${column.name}</th>\\n`)\n  }\n  get columnNames() {\n   const header = this.nodeAt(0)\n   return header ? header.getLine().split(this.delimiter) : []\n  }\n  get columns() {\n   const cols = this.columnNames\n   return cols.map((name, index) => {\n    const isLink = name.endsWith("Link")\n    const linkIndex = cols.indexOf(name + "Link")\n    return {\n     name,\n     isLink,\n     linkIndex\n    }\n   })\n  }\n  get tableBody() {\n   const { delimiter } = this\n   return this.topDownArray\n    .slice(1)\n    .map(node => `<tr>${node.toRow(this.columns, delimiter)}</tr>`)\n    .join("\\n")\n  }\n  compile() {\n   return `<table id="table${this._getUid()}" class="scrollTable">\n   <thead><tr>${this.tableHeader.join("\\n")}</tr></thead>\n   <tbody>${this.tableBody}</tbody>\n   </table>\n   <script>\n   document.querySelector(\'#table${this._getUid()}\').addEventListener(\'click\', e => {\n    if (window.getSelection().toString() || e.target.closest(\'a\') || !e.target.closest(\'tbody\')) return;\n    e.currentTarget.classList.toggle(\'expandedTable\');\n   });\n   </script>`\n  }\n  compileTxt() {\n    return this.childrenToString()\n  }\ntableParser\n description A table with a custom delimiter.\n extends abstractTableParser\n catchAllCellType anyCell\n javascript\n  get delimiter() {\n   return this.content ?? ""\n  }\ncommaTableParser\n description Comma separated values table.\n extends abstractTableParser\n string delimiter ,\npipeTableParser\n description Pipe separated values table.\n extends abstractTableParser\n string delimiter |\nspaceTableParser\n description Space separated values table. Last column is a catch all.\n extends abstractTableParser\n string delimiter  \ntabTableParser\n description Tab separated values table.\n extends abstractTableParser\n string delimiter \\t\ntreeTableParser\n description A table of data written in Scroll Notation form. Useful when a column contains a text blob.\n extends abstractTableParser\n catchAllParser treeRowParser\n javascript\n  get columnNames() {\n   return this._getUnionNames()\n  }\n  get tableBody() {\n   return this.map(node => `<tr>${node.toRow(this.columns)}</tr>`).join("\\n")\n  }\n example\n  treeTable\n   row\n    name Javascript\n    example\n     console.log("Hello world")\n   row\n    name Python\n    example\n     print "Hello world"\nprintTableParser\n description Print a tabular table in a page into an HTML table.\n cruxFromId\n catchAllCellType integerCell\n extends abstractScrollParser\n javascript\n   compile() {\n    const node = this.appendSibling("table \\t", this.tsv)\n    const html = node.compile()\n    node.destroy()\n    return html\n   }\n   getTableByIndex(index) {\n      const hit = this.root.file.tables[parseInt(index)]\n      if (!hit)\n        console.error(`Table "${index}" not found`)\n      return hit\n   }\n   get table() {\n     const index = this.getWord(1)\n     if (index !== undefined)\n        return this.getTableByIndex(index)\n     if (this.next.isTabularData)\n       return this.next\n     if (this.previous.isTabularData)\n       return this.previous.headerNode\n    return this.getTableByIndex(0)\n   }\n   get tsv() {\n    const firstNode = this.table\n    const lastNode = firstNode.lastNode\n    const aftertext = lastNode.childrenToString() // todo: we could be more specific and ignore comments\n    let tableNode = firstNode\n    let tsv = tableNode.getLine()\n    while (tableNode.next.isTabularData) {\n      tsv += "\\n" + (aftertext ? tableNode.next.applyAftertext(aftertext) : tableNode.next.getLine())\n      tableNode = tableNode.next\n      if (tableNode === firstNode)\n        break\n    }\n     return tsv\n   }\n   compileTxt() {\n     return this.tsv\n   }\nplainTextParser\n description Use for plain text one liners and/or blocks of plain text. Will print in all output formats.\n cruxFromId\n extends abstractScrollParser\n catchAllParser plainTextLineParser\n catchAllCellType stringCell\n javascript\n  compile() {\n   return this.compileTxt()\n  }\n  compileTxt() {\n    return `${this.content ?? ""}${this.childrenToString()}`\n  }\nplainTextOnlyParser\n extends plainTextParser\n description Only prints its contents in text output.\n javascript\n  compile() {\n   return ""\n  }\nabstractAftertextAttributeParser\n cells keywordCell\n boolean isAttribute true\n javascript\n  get divAttributes() {\n   return `${this.firstWord}="${this.content}"`\n  }\n  compile() {\n   return ""\n  }\naftertextIdParser\n crux id\n description Provide an ID to be output in the generated HTML tag.\n extends abstractAftertextAttributeParser\n cells keywordCell htmlIdCell\n single\naftertextStyleParser\n crux style\n description Provide code for the generated HTML tag\'s "style" attribute.\n extends abstractAftertextAttributeParser\n cells keywordCell\n catchAllCellType cssAnyCell\naftertextHiddenParser\n crux hidden\n cells keywordCell\n description Do not compile this node to HTML.\n extends abstractAftertextAttributeParser\n single\naftertextTagParser\n cells keywordCell htmlTagCell\n description Override the HTML tag that the compiled node will use.\n crux tag\n javascript\n  compile() {\n   return ""\n  }\nabstractAftertextDirectiveParser\n cells keywordCell\n catchAllCellType stringCell\n javascript\n  isMarkup = true\n  compile() {\n   return ""\n  }\n  getErrors() {\n    const errors = super.getErrors()\n    if (!this.isMarkup || this.matchWholeLine) return errors\n    const inserts = this.getInserts(this.parent.originalTextPostLinkify)\n    // todo: make AbstractTreeError class exported by sdk to allow Parsers to define their own error types.\n    // todo: also need to be able to map lines back to their line in source (pre-imports)\n    if (!inserts.length)\n      errors.push({toObject: () => {return { message: `No match found for "${this.getLine()}".`}}})\n    return errors\n  }\n  get pattern() {\n   return this.getWordsFrom(1).join(" ")\n  }\n  get shouldMatchAll() {\n   return this.has("matchAll")\n  }\n  getMatches(text) {\n   const { pattern } = this\n   const escapedPattern = pattern.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, "\\\\$&")\n   return [...text.matchAll(new RegExp(escapedPattern, "g"))].map(match => {\n    const { index } = match\n    const endIndex = index + pattern.length\n    return [\n     { index, string: `<${this.openTag}${this.allAttributes}>`, endIndex },\n     { index: endIndex, endIndex, string: `</${this.closeTag}>` }\n    ]\n   })\n  }\n  getInserts(text) {\n   const matches = this.getMatches(text)\n   if (!matches.length) return false\n   if (this.shouldMatchAll) return matches.flat()\n   const match = this.getNode("match")\n   if (match)\n    return match.indexes\n     .map(index => matches[index])\n     .filter(i => i)\n     .flat()\n   return matches[0]\n  }\n  get allAttributes() {\n   const attr = this.attributes.join(" ")\n   return attr ? " " + attr : ""\n  }\n  get attributes() {\n   return []\n  }\n  get openTag() {\n   return this.tag\n  }\n  get closeTag() {\n   return this.tag\n  }\nabstractMarkupParser\n extends abstractAftertextDirectiveParser\n inScope abstractMarkupParameterParser\nboldParser\n cruxFromId\n description Bold the matching text.\n extends abstractMarkupParser\n javascript\n  tag = "b"\nitalicsParser\n cruxFromId\n description Italicize the matching text.\n extends abstractMarkupParser\n javascript\n  tag = "i"\nunderlineParser\n description Underline the matching text.\n cruxFromId\n extends abstractMarkupParser\n javascript\n  tag = "u"\naftertextCodeParser\n description Wrap the matching text in a <code> span.\n crux code\n extends abstractMarkupParser\n javascript\n  tag = "code"\nclassMarkupParser\n description Add a custom class to the parent element instead. If matching text provided, a span with the class will be added around the matching text.\n extends abstractMarkupParser\n cells keywordCell classNameCell\n crux class\n javascript\n  tag = "span"\n  get applyToParentElement() {\n   return this.words.length === 2\n  }\n  getInserts(text) {\n   // If no select text is added, set the class on the parent element.\n   if (this.applyToParentElement) return []\n   return super.getInserts(text)\n  }\n  get className() {\n   return this.getWord(1)\n  }\n  get attributes() {\n   return [`class="${this.className}"`]\n  }\n  get matchWholeLine() {\n    return this.applyToParentElement\n  }\n  get pattern() {\n   return this.matchWholeLine ? this.parent.content : this.getWordsFrom(2).join(" ")\n  }\nclassesMarkupParser\n extends classMarkupParser\n crux classes\n javascript\n  applyToParentElement = true\n  get className() {\n   return this.content\n  }\nhoverNoteParser\n description Add a caveat viewable on hover on matching text. When you want to be sure you\'ve thoroughly addressed obvious concerns but ones that don\'t warrant to distract from the main argument of the text.\n cruxFromId\n extends classMarkupParser\n catchAllParser lineOfTextParser\n cells keywordCell\n javascript\n  get pattern() {\n   return this.getWordsFrom(1).join(" ")\n  }\n  get attributes() {\n   return [`class="scrollHoverNote"`, `title="${this.hoverNoteText}"`]\n  }\n  get hoverNoteText() {\n   return this.childrenToString().replace(/\\n/g, " ")\n  }\naftertextStrikeParser\n crux strike\n extends abstractMarkupParser\n javascript\n  tag = "s"\nlinkParser\n extends abstractMarkupParser\n description Put the matching text in an <a> tag.\n cells keywordCell urlCell\n inScope linkTitleParser linkTargetParser commentParser\n programParser\n  description Anything here will be URI encoded and then appended to the link.\n  cruxFromId\n  cells keywordCell\n  catchAllParser programLinkParser\n  javascript\n   get encoded() {\n    return encodeURIComponent(this.childrenToString())\n   }\n cruxFromId\n javascript\n  tag = "a"\n  compileTxt() {\n    return this.root.file.ensureAbsoluteLink(this.link)\n  }\n  get link() {\n   const {baseLink} = this\n   if (this.has("program"))\n     return baseLink + this.getNode("program").encoded\n   return baseLink\n  }\n  get baseLink() {\n   const link = this.getWord(1)\n   const isAbsoluteLink = link.includes("://")\n   if (isAbsoluteLink) return link\n   const relativePath = this.parent.compileSettings?.relativePath || ""\n   return relativePath + link\n  }\n  get attributes() {\n   const attrs = [`href="${this.link}"`]\n   const options = ["title", "target"]\n   options.forEach(option => {\n    const node = this.getNode(option)\n    if (node) attrs.push(`${option}="${node.content}"`)\n   })\n   return attrs\n  }\n  get matchWholeLine() {\n    return this.getWordsFrom(this.patternStartsAtWord).length === 0\n  }\n  patternStartsAtWord = 2\n  get pattern() {\n   return this.matchWholeLine ? this.parent.originalText : this.getWordsFrom(this.patternStartsAtWord).join(" ")\n  }\nemailLinkParser\n description A mailto link\n crux email\n extends linkParser\n javascript\n  get attributes() {\n   return [`href="mailto:${this.link}"`]\n  }\nquickLinkParser\n pattern ^https?\\:\n extends linkParser\n cells urlCell\n javascript\n  get link() {\n   return this.firstWord\n  }\n  patternStartsAtWord = 1\nwrapsOnParser\n cruxFromId\n description Enable `code`, *bold*, and _italics_ rules.\n extends abstractAftertextDirectiveParser\n catchAllCellType wrapNameCell\n javascript\n  get shouldMatchAll() {\n   return true\n  }\n  get wraps() {\n    const wraps = [{delimiter: "`", tag: "code", exclusive: true, name: "code"},{delimiter: "*", tag: "strong", name: "bold"}, {delimiter: "_", tag: "em", name: "italics"}]\n    if (this.root.has("katex"))\n      wraps.unshift({delimiter: "$", tag: "span", attributes: \' class="scrollKatex"\', exclusive: true, name: "katex"})\n    if (this.content)\n      return wraps.filter(wrap => this.content.includes(wrap.name))\n    return wraps\n  }\n  getMatches(text) {\n   const exclusives = []\n   return this.wraps.map(wrap => this.runPattern(text, wrap, exclusives)).filter(i => i).flat()\n  }\n  runPattern(text, wrap, exclusives = []) {\n   const {delimiter, tag, attributes} = wrap\n   const escapedDelimiter = delimiter.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, "\\\\$&")\n   const pattern = new RegExp(`${escapedDelimiter}[^${escapedDelimiter}]+${escapedDelimiter}`, "g")\n   const delimiterLength = delimiter.length\n   return [...text.matchAll(pattern)].map(match => {\n    const { index } = match\n    const endIndex = index + match[0].length\n    // I\'m too lazy to clean up sdk to write a proper inline markup parser so doing this for now.\n    // The exclusive idea is to not try and apply bold or italic styles inside a TeX or code inline style.\n    // Note that the way this is currently implemented any TeX in an inline code will get rendered, but code\n    // inline of TeX will not. Seems like an okay tradeoff until a proper refactor and cleanup can be done.\n    if (exclusives.some(exclusive => index >= exclusive[0] && index <= exclusive[1]))\n      return undefined\n    if (wrap.exclusive)\n      exclusives.push([index, endIndex])\n    return [\n     { index, string: `<${tag + (attributes ? " " + attributes : "")}>`, endIndex, consumeStartCharacters: delimiterLength },\n     { index: endIndex, endIndex, string: `</${tag}>`, consumeEndCharacters: delimiterLength }\n    ]\n   }).filter(i => i)\n  }\nwrapParser\n cruxFromId\n cells keywordCell delimiterCell tagOrUrlCell\n catchAllCellType htmlAttributesCell\n extends wrapsOnParser\n description Define a custom wrap, for example "wrap _ em" would support: _italics_.\n javascript\n  getMatches(text) {\n   try {\n    const delimiter = this.getWord(1)\n    const tag = this.getWord(2)\n    const attributes = this.getWordsFrom(3).join(" ")\n    if (tag.startsWith("https:")) return this.runPattern(text, {delimiter, tag: "a", attributes: `href="${tag}"` + attributes})\n    return this.runPattern(text, {delimiter, tag, attributes})\n   } catch (err) {\n    console.error(err)\n    return []\n   }\n   // Note: doubling up doesn\'t work because of the consumption characters.\n  }\ndatelineParser\n cruxFromId\n description Gives your paragraph a dateline like "December 15, 2021 — The..."\n extends abstractAftertextDirectiveParser\n javascript\n  getInserts() {\n   const {day} = this\n   if (!day) return false\n   return [{ index: 0, string: `<span class="scrollDateline">${day} — </span>` }]\n  }\n  matchWholeLine = true\n  get day() {\n   let day = this.content || this.root.get("date") || this.root.file?.date\n   if (!day) return ""\n   try {\n    const dayjs = require("dayjs")\n    return dayjs(day).format(`MMMM D, YYYY`)\n   } catch (err) {\n    console.error(err)\n   }\n   return day || ""\n  }\ndayjsParser\n description Advanced directive that evals some Javascript code in an environment including "dayjs".\n cruxFromId\n extends abstractAftertextDirectiveParser\n javascript\n  getInserts() {\n   const dayjs = require("dayjs")\n   const days = eval(this.content)\n   const index = this.parent.originalTextPostLinkify.indexOf("days")\n   return [{ index, string: `${days} ` }]\n  }\nlinkifyParser\n description Use this to disable linkify on the text.\n extends abstractAftertextDirectiveParser\n cruxFromId\n cells keywordCell booleanCell\nabstractMarkupParameterParser\n cells keywordCell\n cruxFromId\nmatchAllParser\n description Use this to match all occurrences of the text.\n extends abstractMarkupParameterParser\nmatchParser\n catchAllCellType integerCell\n description Use this to specify which index(es) to match.\n javascript\n  get indexes() {\n   return this.getWordsFrom(1).map(num => parseInt(num))\n  }\n example\n  aftertext\n   hello ello ello\n   bold ello\n    match 0 2\n extends abstractMarkupParameterParser\nabstractHtmlAttributeParser\n javascript\n  compile() {\n   return ""\n  }\nlinkTargetParser\n extends abstractHtmlAttributeParser\n description If you want to set the target of the link. To "_blank", for example.\n crux target\n cells keywordCell anyCell\nblankLineParser\n description Blank lines compile to nothing in the HTML.\n cells blankCell\n javascript\n  compile() {\n   return this.parent.clearSectionStack()\n  }\n pattern ^$\n tags doNotSynthesize\nchatLineParser\n catchAllCellType anyCell\n catchAllParser chatLineParser\nlineOfCodeParser\n catchAllCellType codeCell\n catchAllParser lineOfCodeParser\ncommentLineParser\n catchAllCellType commentCell\ncssLineParser\n catchAllCellType cssAnyCell\n catchAllParser cssLineParser\nerrorParser\n baseParser errorParser\nlineOfTextParser\n catchAllCellType stringCell\n boolean isTextParser true\nhtmlLineParser\n catchAllCellType htmlAnyCell\n catchAllParser htmlLineParser\nstumpContentParser\n catchAllCellType anyCell\nlinkTitleParser\n description If you want to set the title of the link.\n crux title\n cells keywordCell\n catchAllCellType anyCell\n example\n  * This report showed the treatment had a big impact.\n   https://example.com/report This report.\n    title The average growth in the treatment group was 14.2x higher than the control group.\nprogramLinkParser\n catchAllCellType codeCell\nabstractLoopConfigParser\n cells keywordCell\n cruxFromId\n catchAllCellType stringCell\nabstractItemsProviderParser\n cells keywordCell\nloopLinesParser\n crux lines\n extends abstractItemsProviderParser\n description Iterate over the provided lines.\n catchAllParser loopLineParser\n loopLineParser\n  catchAllCellType stringCell\n javascript\n  get items() {\n   return this.map(node => node.asString)\n  }\nloopWordsParser\n crux words\n extends abstractItemsProviderParser\n catchAllCellType stringCell\n description Iterate over the provided words.\n javascript\n  get items() {\n   return this.getWordsFrom(1)\n  }\nloopGroupsParser\n crux groups\n extends abstractItemsProviderParser\n catchAllCellType groupNameWithOptionalFolderCell\n description Set this to iterate over scroll files in a folder. Provide both the folder and group name like this: [folder]/[groupName]\n javascript\n  get items() {\n   return this.root.file.getFilesInGroupsForEmbedding(this.getWordsFrom(1))\n  }\nabstractPointConfigParser\n // todo: scoped parsers should support abstract types\n cruxFromId\n cells keywordCell\n catchAllCellType stringCell\n single\nlatParser\n cells keywordCell floatCell\n cruxFromId\n single\nlongParser\n cells keywordCell floatCell\n cruxFromId\n single\nquoteLineParser\n catchAllCellType anyCell\n catchAllParser quoteLineParser\nreadingListItemParser\n cells urlCell\n catchAllCellType stringCell\n javascript\n  compile() {\n   const url = this.firstWord\n   const [title, author] = this.content.split(" by ")\n   return `<li><a href="${url}">${title ?? url}</a>${author ? ` by ${author}` : ""}</li>`\n  }\nscrollParser\n extensions scroll\n description Scroll is a language for scientists of all ages. Refine, share and collaborate on ideas.\n root\n inScope abstractScrollParser blankLineParser\n catchAllParser catchAllParagraphParser\n compilesTo html\n javascript\n  setFile(file) {\n   this.file = file\n   return this\n  }\n  compile(compileSettings) {\n    this.sectionStack = []\n    return this.map(child => child.compile(compileSettings)).filter(i => i).join("\\n") + this.clearSectionStack()\n  }\n  sectionStack = []\n  clearSectionStack() {\n   const result = this.sectionStack.join("")\n   this.sectionStack = []\n   return result\n  }\n  get hakonParser() {\n    if (this.isNodeJs())\n      return require("scrollsdk/products/hakon.nodejs.js")\n    return hakonParser\n  }\n  alreadyRequired = new Set()\n  compileEmbeddedVersion(compileSettings) {\n   this.sectionStack = []\n   return this.map(child => (child.compileEmbeddedVersion ? child.compileEmbeddedVersion(compileSettings) : child.compile(compileSettings)))\n     .filter(i => i)\n     .join("\\n")\n     .trim() + this.clearSectionStack()\n  }\n  get footnotes() {\n   if (this._footnotes === undefined) this._footnotes = this.filter(node => node.isFootnote)\n   return this._footnotes\n  }\n  file = {}\n  get permalink() {\n   return this.get("permalink") || this.file.permalink || ""\n  }\n example\n  # Hello world\n  ## This is Scroll\n  * It compiles to HTML.\n  \n  code\n   // You can add code as well.\n   print("Hello world")\nscriptLineParser\n catchAllCellType scriptAnyCell\n catchAllParser scriptLineParser\nstampFileParser\n catchAllCellType stringCell\n description Create a file.\n javascript\n  build(parentDir) {\n   const fs = require("fs")\n   const path = require("path")\n   const fullPath = path.join(parentDir, this.getLine())\n   this.root.file.log(`Creating file ${fullPath}`)\n   fs.mkdirSync(path.dirname(fullPath), {recursive: true})\n   const content = this.childrenToString()\n   fs.writeFileSync(fullPath, content, "utf8")\n   const isExecutable = content.startsWith("#!")\n   if (isExecutable) fs.chmodSync(fullPath, "755")\n  }\nstampFolderParser\n catchAllCellType stringCell\n description Create a folder.\n inScope stampFolderParser\n catchAllParser stampFileParser\n pattern \\/$\n javascript\n  build(parentDir) {\n   const fs = require("fs")\n   const path = require("path")\n   const newPath = path.join(parentDir, this.getLine())\n   this.root.file.log(`Creating folder ${newPath}`)\n   fs.mkdirSync(newPath, {recursive: true})\n   this.forEach(node => node.build(newPath))\n  }\nrowParser\n catchAllCellType stringCell\n javascript\n  toRow(columns, delimiter) {\n   const words = this.getLine().split(delimiter)\n   let str = ""\n   let column = 0\n   const columnCount = columns.length\n   while (column < columnCount) {\n    const col = columns[column]\n    column++\n    const content = (columnCount === column ? words.slice(columnCount - 1).join(" ") : words[column - 1]) ?? ""\n    if (col.isLink) continue\n    let tagged = content\n    const link = words[col.linkIndex]\n    if (col.linkIndex > -1 && link) tagged = `<a href="${link}">${content}</a>`\n    else if (content.match(/^https?\\:[^ ]+$/)) tagged = `<a href="${content}">${content}</a>`\n    str += `<td>${tagged}</td>\\n`\n   }\n   return str\n  }\nplainTextLineParser\n catchAllCellType stringCell\n catchAllParser plainTextLineParser\ntreeRowContentParser\n description Any blob content in a cell.\n cells stringCell\n catchAllCellType stringCell\ntreeRowColumnParser\n catchAllParser treeRowContentParser\n description A columnName value pair, or just a columnName if the value is a text blob.\n cells anyCell\n catchAllCellType stringCell\ntreeRowParser\n cells anyCell\n description The root node of a row.\n catchAllParser treeRowColumnParser\n javascript\n  toRow(columns) {\n   let str = ""\n   columns.forEach(col => {\n    const node = this.getNode(col.name)\n    if (col.isLink) return\n    if (!node) {\n     str += "<td></td>\\n"\n     return\n    }\n    const content = (node.length ? node.childrenToString() : node.content) ?? ""\n    let tagged = ""\n    const link = this.get(col.name + "Link")\n    if (col.linkIndex > -1 && link) tagged = `<a href="${link}">${content}</a>`\n    else if (node.length) tagged = `<pre>${content}</pre>`\n    else tagged = content\n    str += `<td>${tagged}</td>\\n`\n   })\n   return str\n  }'
}
