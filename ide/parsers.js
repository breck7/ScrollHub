const AppConstants = {"parsers":"buildCommandWordCell\n extends commandWordCell\n description Give build command words their own color.\n paint constant\nblankCell\nanyCell\nenumCell\n paint constant.language\nbooleanCell\n enum true false\n extends enumCell\nstringCell\n paint string\nwordCell\n paint string\n description A non-empty single word string.\n regex .+\ncolumnNameCell\n extends stringCell\nsemanticVersionCell\n paint string\n description A 3 part sem version string like 1.2.1\ndateCell\n paint string\nnumberCell\n paint constant.numeric\nintegerCell\n extends numberCell\n paint constant.numeric.integer\nfloatCell\n extends numberCell\n paint constant.numeric.float\npercentCell\n paint constant.numeric.float\n extends stringCell\n // todo: this currently extends from stringCell b/c scrollsdk needs to be fixed. seems like if extending from number then the hard coded number typescript regex takes precedence over a custom regex\ncountCell\n extends integerCell\nyearCell\n extends integerCell\ncommandWordCell\n description A word that indicates a certain parser to use.\n paint keyword\npreBuildCommandWordCell\n extends commandWordCell\n description Give build command words their own color.\n paint constant.character.escape\ncommentCell\n paint comment\ndelimiterCell\n description String to use as a delimiter.\n paint string\ncodeCell\n paint comment\nbulletPointCell\n description Any token used as a bullet point such as \"-\" or \"1.\" or \">\"\n paint keyword\ncomparisonCell\n enum < > <= >= = != includes doesNotInclude empty notEmpty\n paint constant\npersonNameCell\n extends stringCell\nurlCell\n paint constant.language\nabsoluteUrlCell\n paint constant.language\n regex (ftp|https?)://.+\nemailAddressCell\n extends stringCell\npermalinkCell\n paint string\n description A string that doesn't contain characters that might interfere with most filesystems. No slashes, for instance.\nfilePathCell\n extends stringCell\ntagOrUrlCell\n description An HTML tag or a url.\n paint constant.language\nhtmlAttributesCell\n paint comment\nhtmlTagCell\n paint constant.language\n enum div span p a img ul ol li h1 h2 h3 h4 h5 h6 header nav section article aside main footer input button form label select option textarea table tr td th tbody thead tfoot br hr meta link script style title code\nclassNameCell\n paint constant\nhtmlIdCell\n extends anyCell\ncssAnyCell\n extends anyCell\nhtmlAnyCell\n extends stringCell\ninlineMarkupNameCell\n description Options to turn on some inline markups.\n enum bold italics code katex none\nmeasureNameCell\n extends commandWordCell\n // A regex for column names for max compatibility with a broad range of data science tools:\n regex [a-zA-Z][a-zA-Z0-9]*\njavascriptCell\n extends stringCell\nmetaCommandWordCell\n extends commandWordCell\n description Give meta command words their own color.\n paint constant.numeric\n // Obviously this is not numeric. But I like the green color for now.\n   We need a better design to replace this \"paint\" concept\n   https://github.com/breck7/scrollsdk/issues/186\nscriptAnyCell\n extends anyCell\ntagCell\n extends permalinkCell\ntagWithOptionalFolderCell\n description A group name optionally combined with a folder path. Only used when referencing tags, not in posts.\n extends stringCell\nabstractScrollParser\n cells commandWordCell\n javascript\n  compileEmbeddedVersion(compileSettings) {\n   return this.compile(compileSettings)\n  }\n  compileTxt() {\n    return \"\"\n  }\n  getHtmlRequirements(compileSettings) {\n    const {requireOnce} = this\n    if (!requireOnce)\n      return \"\"\n    const set = compileSettings?.alreadyRequired || this.root.alreadyRequired\n    if (set.has(requireOnce))\n      return \"\"\n    \n    set.add(requireOnce)\n    return requireOnce + \"\\n\\n\"\n  }\nabstractAftertextParser\n description Text followed by markup commands.\n extends abstractScrollParser\n inScope abstractAftertextDirectiveParser abstractAftertextAttributeParser aftertextTagParser commentParser\n javascript\n  get markupInserts() {\n   const { originalTextPostLinkify } = this\n   return this.filter(node => node.isMarkup)\n    .map(node => node.getInserts(originalTextPostLinkify))\n    .filter(i => i)\n    .flat()\n  }\n  get originalText() {\n   return this.content ?? \"\"\n  }\n  get originalTextPostLinkify() {\n   const { originalText } = this\n   const shouldLinkify = this.get(\"linkify\") === \"false\" || originalText.includes(\"<a \") ? false : true\n   return shouldLinkify ? this.replaceNotes(Utils.linkify(originalText)) : originalText\n  }\n  replaceNotes(originalText) {\n   // Skip the replacements if there are no footnotes or the text has none.\n   if (!this.root.footnotes.length || !originalText.includes(\"^\")) return originalText\n   this.root.footnotes.forEach((note, index) => {\n    const needle = note.firstWord\n    const {linkBack} = note\n    if (originalText.includes(needle)) originalText = originalText.replace(new RegExp(\"\\\\\" + needle + \"\\\\b\"), `<a href=\"#${note.anchorId}\" class=\"scrollNoteLink\" id=\"${linkBack}\"><sup>${note.label}</sup></a>`)\n   })\n   return originalText\n  }\n  get text() {\n   const { originalTextPostLinkify, markupInserts } = this\n   let adjustment = 0\n   let newText = originalTextPostLinkify\n   // If multiple tags start at same index, the tag that closes first should start last. Otherwise HTML breaks.\n   markupInserts.sort((a, b) => (a.index === b.index ? b.endIndex - a.endIndex : a.index - b.index))\n   markupInserts.forEach(insertion => {\n    insertion.index += adjustment\n    const consumeStartCharacters = insertion.consumeStartCharacters ?? 0\n    const consumeEndCharacters = insertion.consumeEndCharacters ?? 0\n    newText = newText.slice(0, insertion.index - consumeEndCharacters) + insertion.string + newText.slice(insertion.index + consumeStartCharacters)\n    adjustment += insertion.string.length - consumeEndCharacters - consumeStartCharacters\n   })\n   return newText\n  }\n  tag = \"p\"\n  get className() {\n   if (this.get(\"classes\"))\n     return this.get(\"classes\")\n   const classLine = this.getNode(\"class\")\n   if (classLine && classLine.applyToParentElement) return classLine.content\n   return this.defaultClassName\n  }\n  defaultClassName = \"scrollParagraph\"\n  get isHidden() {\n    return this.has(\"hidden\")\n  }\n  compile(compileSettings) {\n   if (this.isHidden) return \"\"\n   this.compileSettings = compileSettings\n   const { className } = this\n   const classAttr = className ? `class=\"${this.className}\"` : \"\"\n   const tag = this.get(\"tag\") || this.tag\n   if (tag === \"none\") // Allow no tag for aftertext in tables\n     return this.text\n   return this.getHtmlRequirements(compileSettings) + `<${tag} ${this.divAttributes}${classAttr}>${this.text}</${tag}>`\n  }\n  get divAttributes() {\n   const attrs = this.filter(node => node.isAttribute)\n   return attrs.length ? attrs.map(node => node.divAttributes).join(\" \") + \" \" : \"\"\n  }\nparagraphParser\n // todo Perhaps rewrite this from scratch and move out of aftertext.\n extends abstractAftertextParser\n catchAllCellType stringCell\n description A paragraph.\n boolean suggestInAutocomplete false\n cruxFromId\n javascript\n  compile(compileSettings) {\n   if (this.isHidden) return \"\"\n   // Hacky, I know.\n   const newLine = this.has(\"inlineMarkupsOn\") ? undefined : this.appendLine(\"inlineMarkupsOn\")\n   const compiled = super.compile(compileSettings)\n   if (newLine)\n    newLine.destroy()\n   return compiled\n  }\n  compileTxt() {\n    const children = this.filter(node => node.compileTxt).map(node => node.compileTxt()).filter(i => i).join(\"\\n\")\n    const dateline = this.getNode(\"dateline\")\n    return (dateline ? dateline.day + \"\\n\\n\" : \"\") + (this.originalText || \"\") + (children ? \"\\n \" + children.replace(/\\n/g, \"\\n \") : \"\")\n  }\nauthorsParser\n // multiple authors delimited by \" and \"\n boolean isPopular true\n extends paragraphParser\n description Set author(s) name(s).\n example\n  authors Breck Yunits\n   https://breckyunits.com Breck Yunits\n // note: once we have mixins in Parsers, lets mixin the below from abstractTopLevelSingleMetaParser\n cells metaCommandWordCell\n javascript\n  isTopMatter = true\n  isSetterParser = true\n  compileHtmlForPrint() {\n    // hacky. todo: cleanup\n    const originalContent = this.content\n    this.setContent(`by ${originalContent}`)\n    const html = super.compile()\n    this.setContent(originalContent)\n    return html\n  }\n  compileTxtForPrint() {\n    return 'by ' + super.compileTxt()\n  }\n  compile() {\n   return \"\"\n  }\n  compileTxt() {\n    return \"\"\n  }\n  defaultClassName = \"scrollByLine\"\nblinkParser\n description Just for fun.\n extends paragraphParser\n example\n  blink Carpe diem!\n crux blink\n javascript\n  compile() {\n   return `<span class=\"scrollBlink\">${super.compile()}</span>\n    <script>setInterval(()=>{ Array.from(document.getElementsByClassName(\"scrollBlink\")).forEach(el => el.style.visibility = el.style.visibility === \"hidden\" ? \"visible\" : \"hidden\") }, 500)</script>`\n  }\nscrollButtonParser\n extends paragraphParser\n crux button\n description A button.\n example\n  button Click me\n javascript\n  defaultClassName = \"scrollButton\"\n  tag = \"button\"\ncatchAllParagraphParser\n description A paragraph.\n extends paragraphParser\n boolean suggestInAutocomplete false\n boolean isPopular true\n cells stringCell\n javascript\n  getErrors() {\n    const errors = super.getErrors() || []\n    return this.parent.has(\"testStrict\") ? errors.concat(this.makeError(`catchAllParagraphParser should not have any matches when testing with testStrict.`)) : errors\n  }\n  get originalText() {\n   return this.getLine() || \"\"\n  }\nscrollCenterParser\n crux center\n description A centered section.\n extends paragraphParser\n example\n  center\n  This paragraph is centered.\n javascript\n  compile() {\n   this.parent.sectionStack.push(\"</center>\")\n   return `<center>${super.compile()}`\n  }\n  compileTxt() {\n    return this.content\n  }\nabstractIndentableParagraphParser\n extends paragraphParser\n inScope abstractAftertextDirectiveParser abstractAftertextAttributeParser abstractIndentableParagraphParser\n javascript\n  compileChildren() {\n    return this.map(node => node.compile())\n     .join(\"\\n\")\n     .trim()\n  }\n  compile() {\n   return super.compile() + this.compileChildren()\n  }\n  compileTxt() {\n    return this.getWord(0) + \" \" + super.compileTxt()\n  }\nchecklistTodoParser\n extends abstractIndentableParagraphParser\n example\n  [] Get milk\n description A task todo.\n crux []\n string checked \n javascript\n  get text() {\n   return `<div style=\"text-indent:${(this.getIndentLevel() - 1) * 20}px;\"><input type=\"checkbox\" ${this.checked} id=\"${this.id}\"><label for=\"${this.id}\">` + super.text + `</label></div>`\n  }\n  get id() {\n   return this.get(\"id\") || \"item\" + this._getUid()\n  }\nchecklistDoneParser\n extends checklistTodoParser\n description A completed task.\n string checked checked\n crux [x]\n example\n  [x] get milk\nlistAftertextParser\n extends abstractIndentableParagraphParser\n example\n  - I had a _new_ thought.\n description A list item.\n crux -\n javascript\n  defaultClassName = \"\"\n  compile() {\n   const index = this.getIndex()\n   const parent = this.parent\n   const nodeClass = this.constructor\n   const isStartOfList = index === 0 || !(parent.nodeAt(index - 1) instanceof nodeClass)\n   const isEndOfList = parent.length === index + 1 || !(parent.nodeAt(index + 1) instanceof nodeClass)\n   const { listType } = this\n   return (isStartOfList ? `<${listType} ${this.attributes}>` : \"\") + `${super.compile()}` + (isEndOfList ? `</${listType}>` : \"\")\n  }\n  get attributes() {\n    return \"\"\n  }\n  tag = \"li\"\n  listType = \"ul\"\nabstractCustomListItemParser\n extends listAftertextParser\n javascript\n  get requireOnce() {\n    return `<style>\\n.${this.constructor.name} li::marker {content: \"${this.firstWord} \";}\\n</style>`\n  }\n  get attributes() {\n    return `class=\"${this.constructor.name}\"`\n  }\norderedListAftertextParser\n extends listAftertextParser\n description A list item.\n example\n  1. Hello world\n pattern ^\\d+\\. \n javascript\n  listType = \"ol\"\n  get attributes() { return ` start=\"${this.getWord(0)}\"`}\nquickQuoteParser\n crux >\n example\n  > The only thing we have to fear is fear itself. - FDR\n boolean isPopular true\n extends abstractIndentableParagraphParser\n description A quote.\n javascript\n  defaultClassName = \"scrollQuote\"\n  tag = \"blockquote\"\nscrollCounterParser\n description Just for fun.\n extends paragraphParser\n crux counter\n example\n  counter 4.5 Babies Born\n cells commandWordCell numberCell\n javascript\n  compile() {\n   const line = this.getLine()\n   const words = line.split(\" \")\n   words.shift() // drop the counter word\n   const perSecond = parseFloat(words.shift()) // get number\n   const increment = perSecond/10\n   const id = this._getUid()\n   this.setLine(`* <span id=\"counter${id}\" title=\"0\">0</span><script>setInterval(()=>{ const el = document.getElementById('counter${id}'); el.title = parseFloat(el.title) + ${increment}; el.textContent = Math.ceil(parseFloat(el.title)).toLocaleString()}, 100)</script> ` + words.join(\" \"))\n   const html = super.compile()\n   this.setLine(line)\n   return html\n  }\nexpanderParser\n cruxFromId\n description An collapsible HTML details tag.\n extends paragraphParser\n example\n  expander Knock Knock\n  Who's there?\n javascript\n  compile() {\n   this.parent.sectionStack.push(\"</details>\")\n   return `<details>${super.compile()}`\n  }\n  compileTxt() {\n    return this.content\n  }\n  tag = \"summary\"\n  defaultClassName = \"\"\nfootnoteDefinitionParser\n description A footnote. Can also be used as section notes.\n extends paragraphParser\n boolean isFootnote true\n pattern ^\\^.+$\n // We need to quickLinks back in scope because there is currently a bug in ScrollSDK/parsers where if a parser extending a parent class has a child parser defined, then any regex parsers in the parent class will not be tested unless explicitly included in scope again.\n inScope quickLinkParser\n labelParser\n  description If you want to show a custom label for a footnote. Default label is the note definition index.\n  cruxFromId\n  cells commandWordCell\n  catchAllCellType stringCell\n javascript\n  get divAttributes() {\n   return super.divAttributes + ` id=\"${this.anchorId}\"`\n  }\n  get anchorId() {\n   return `note${this.noteDefinitionIndex}`\n  }\n  get label() {\n   // In the future we could allow common practices like author name\n   return this.get(\"label\") || `[${this.noteDefinitionIndex}]`\n  }\n  get linkBack() {\n   return `noteUsage${this.noteDefinitionIndex}`\n  }\n  get text() {\n   return `<a class=\"scrollFootNoteUsageLink\" href=\"#noteUsage${this.noteDefinitionIndex}\">${this.label}</a> ${super.text}`\n  }\n  get noteDefinitionIndex() {\n   return this.parent.footnotes.indexOf(this) + 1\n  }\n  compileTxt() {\n    return this.getWord(0) + \": \" + super.compileTxt()\n  }\nabstractHeaderParser\n extends paragraphParser\n example\n  # Hello world\n javascript\n  compile(compileSettings) {\n   if (this.isHidden) return \"\"\n   if (this.parent.sectionStack)\n    this.parent.sectionStack.push(\"</div>\")\n   return `<div class=\"scrollSection\">` + super.compile(compileSettings)\n  }\n  compileTxt() {\n    const line = super.compileTxt()\n    return line + \"\\n\" + \"=\".repeat(line.length)\n  }\n  isHeader = true\nh1Parser\n description An html h1 tag.\n extends abstractHeaderParser\n crux #\n boolean isPopular true\n javascript\n  tag = \"h1\"\nh2Parser\n description An html h2 tag.\n extends abstractHeaderParser\n crux ##\n boolean isPopular true\n javascript\n  tag = \"h2\"\nh3Parser\n description An html h3 tag.\n extends abstractHeaderParser\n crux ###\n javascript\n  tag = \"h3\"\nh4Parser\n description An html h4 tag.\n extends abstractHeaderParser\n crux ####\n javascript\n  tag = \"h4\"\nscrollQuestionParser\n description A question.\n extends h4Parser\n crux ?\n example\n  ? Why is the sky blue?\n javascript\n  defaultClassName = \"scrollQuestion\"\nh5Parser\n description An html h5 tag.\n extends abstractHeaderParser\n crux #####\n javascript\n  tag = \"h5\"\nprintTitleParser\n description Print title.\n extends abstractHeaderParser\n boolean isPopular true\n example\n  title Eureka\n  printTitle\n cruxFromId\n javascript\n  compile(compileSettings) {\n   // Hacky, I know.\n   const {content} = this\n   if (content === undefined)\n    this.setContent(this.root.title)\n   const { permalink } = this.root\n   if (!permalink) {\n    this.setContent(content) // Restore it as it was.\n    return super.compile(compileSettings)\n   }\n   const newLine = this.appendLine(`link ${permalink}`)\n   const compiled = super.compile(compileSettings)\n   newLine.destroy()\n   this.setContent(content) // Restore it as it was.\n   return compiled\n  }\n  get originalText() {\n   return this.content ?? this.root.title ?? \"\"\n  }\n  defaultClassName = \"scrollTitle\"\n  tag = \"h1\"\ncaptionAftertextParser\n description An image caption.\n crux caption\n extends paragraphParser\n boolean isPopular true\nabstractMediaParser\n extends paragraphParser\n inScope scrollMediaLoopParser scrollAutoplayParser\n javascript\n  compileTxt() {\n    return \"\"\n  }\n  get filename() {\n    return this.getWord(1)\n  }\n  getAsHtmlAttribute(attr) {\n    if (!this.has(attr)) return \"\"\n    const value = this.get(attr)\n    return value ? `${attr}=\"${value}\"` : attr\n  }\n  getAsHtmlAttributes(list) {\n    return list.map(word => this.getAsHtmlAttribute(word)).filter(i => i).join(\" \")\n  }\n  compile() {\n    return `<${this.tag} src=\"${this.filename}\" controls ${this.getAsHtmlAttributes(\"width height loop autoplay\".split(\" \"))}></${this.tag}>`\n  }\nscrollSoundParser\n extends abstractMediaParser\n crux music\n description Play sound files.\n example\n  music sipOfCoffee.m4a\n javascript\n  compile() {\n    return `<audio controls ${this.getAsHtmlAttributes(\"loop autoplay\".split(\" \"))}><source src=\"${this.filename}\" type=\"audio/mpeg\"></audio>`\n  }\nscrollVideoParser\n extends abstractMediaParser\n crux video\n example\n  video spirit.mp4\n description Play video files.\n widthParser\n  cruxFromId\n  cells commandWordCell\n heightParser\n  cruxFromId\n  cells commandWordCell\n javascript\n  tag = \"video\"\nquickParagraphParser\n crux *\n extends paragraphParser\n description A paragraph.\n example\n  * I had a _new_ idea.\nthinColumnsParser\n extends abstractAftertextParser\n cruxFromId\n catchAllCellType integerCell\n description Thin columns.\n javascript\n  compileEmbeddedVersion() {\n   return \"\"\n  }\n  columnWidth = 35\n  columnGap = 20\n  compile() {\n   const {columnWidth, columnGap} = this\n   const maxColumns = parseInt(this.getWord(1) ?? 10)\n   const maxTotalWidth = maxColumns * columnWidth + (maxColumns - 1) * columnGap\n   // Starting the columns always first clears the section stack.\n   return this.parent.clearSectionStack() + `<div class=\"scrollColumns\" style=\"column-width:${columnWidth}ch;column-count:${maxColumns};max-width:${maxTotalWidth}ch;\">`\n  }\nwideColumnsParser\n extends thinColumnsParser\n description Wide columns.\n javascript\n  columnWidth = 90\nmediumColumnsParser\n extends thinColumnsParser\n description Medium width columns.\n javascript\n  columnWidth = 65\nendColumnsParser\n extends abstractAftertextParser\n cruxFromId\n description End columns.\n javascript\n  compile() {\n   return \"</div>\"\n  }\n  compileEmbeddedVersion() {\n   return \"\"\n  }\nabstractDinkusParser\n extends abstractAftertextParser\n boolean isDinkus true\n javascript\n  compile() {\n   return `<div class=\"dinkus\"><span>${this.dinkus}</span></div>`\n  }\n  compileTxt() {\n    return this.dinkus\n  }\n  get dinkus() {\n    return this.content || this.getLine()\n  }\nhorizontalRuleParser\n crux ---\n description A horizontal rule.\n extends abstractDinkusParser\n javascript\n  compile() {\n   return `<hr>`\n  }\nscrollDinkusParser\n crux ***\n description A dinkus. Breaks section.\n boolean isPopular true\n extends abstractDinkusParser\n javascript\n  dinkus = \"*\"\ncustomDinkusParser\n crux dinkus\n description A custom dinkus.\n extends abstractDinkusParser\nendOfPostDinkusParser\n extends abstractDinkusParser\n description End of post dinkus.\n boolean isPopular true\n crux ****\n javascript\n  dinkus = \"‚ÅÇ\"\nabstractIconButtonParser\n extends abstractAftertextParser\n cruxFromId\n javascript\n  compileEmbeddedVersion() {\n   return \"\"\n  }\n  compile() {\n    return `<style>.abstractIconButtonParser {position:absolute;top:0.25rem; }.abstractIconButtonParser svg {fill: rgba(204,204,204,.8);width:1.875rem;height:1.875rem; padding: 0 7px;} .abstractIconButtonParser:hover svg{fill: #333;}</style><a href=\"${this.link}\" class=\"doNotPrint abstractIconButtonParser\" style=\"${this.style}\">${this.svg}</a>`\n  }\ndownloadButtonParser\n description Link to download/WWS page.\n extends abstractIconButtonParser\n catchAllCellType urlCell\n string style position:relative;\n string svg <svg fill=\"#000000\" xmlns=\"http://www.w3.org/2000/svg\" width=\"800px\" height=\"800px\" viewBox=\"0 0 52 52\" enable-background=\"new 0 0 52 52\" xml:space=\"preserve\"><path d=\"M38.6,20.4c-1-6.5-6.7-11.5-13.5-11.5c-7.6,0-13.7,6.1-13.7,13.7c0,0.3,0,0.7,0.1,1c-5,0.4-8.9,4.6-8.9,9.6 c0,5.4,4.3,9.7,9.7,9.7h11.5c-0.8-0.8-8.1-8.1-8.1-8.1c-0.4-0.4-0.4-0.9,0-1.3l1.3-1.3c0.4-0.4,0.9-0.4,1.3,0l3.5,3.5 c0.4,0.4,1.1,0.1,1.1-0.4V21.8c0-0.4,0.5-0.9,1-0.9h1.9c0.5,0,0.9,0.4,0.9,0.9v13.4c0,0.6,0.8,0.8,1.1,0.4l3.5-3.5 c0.4-0.4,0.9-0.4,1.3,0l1.3,1.3c0.4,0.4,0.4,0.9,0,1.3L26,42.9h12.3v0c6.1-0.1,11-5.1,11-11.3C49.4,25.5,44.6,20.6,38.6,20.4z\"/></svg><!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->\n javascript\n  get link() {\n    return this.content\n  }\nemailButtonParser\n description Email button.\n extends abstractIconButtonParser\n catchAllCellType emailAddressCell\n // todo: should just be \"optionalCellType\"\n string style position:relative;\n string svg <svg viewBox=\"3 5 24 20\" width=\"24\" height=\"20\" xmlns=\"http://www.w3.org/2000/svg\"><g transform=\"matrix(1, 0, 0, 1, 0, -289.0625)\"><path style=\"opacity:1;stroke:none;stroke-width:0.49999997;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\" d=\"M 5 5 C 4.2955948 5 3.6803238 5.3628126 3.3242188 5.9101562 L 14.292969 16.878906 C 14.696939 17.282876 15.303061 17.282876 15.707031 16.878906 L 26.675781 5.9101562 C 26.319676 5.3628126 25.704405 5 25 5 L 5 5 z M 3 8.4140625 L 3 23 C 3 24.108 3.892 25 5 25 L 25 25 C 26.108 25 27 24.108 27 23 L 27 8.4140625 L 17.121094 18.292969 C 15.958108 19.455959 14.041892 19.455959 12.878906 18.292969 L 3 8.4140625 z \" transform=\"translate(0,289.0625)\" id=\"rect4592\"/></g></svg>\n javascript\n  get link() {\n    const email = this.content || this.parent.get(\"email\")\n    return email ? `mailto:${email}` : \"\"\n  }\nhomeButtonParser\n description Home button.\n extends abstractIconButtonParser\n catchAllCellType urlCell\n string style left:2rem;\n string svg <svg role=\"img\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M12.7166 3.79541C12.2835 3.49716 11.7165 3.49716 11.2834 3.79541L4.14336 8.7121C3.81027 8.94146 3.60747 9.31108 3.59247 9.70797C3.54064 11.0799 3.4857 13.4824 3.63658 15.1877C3.7504 16.4742 4.05336 18.1747 4.29944 19.4256C4.41371 20.0066 4.91937 20.4284 5.52037 20.4284H8.84433C8.98594 20.4284 9.10074 20.3111 9.10074 20.1665V15.9754C9.10074 14.9627 9.90433 14.1417 10.8956 14.1417H13.4091C14.4004 14.1417 15.204 14.9627 15.204 15.9754V20.1665C15.204 20.3111 15.3188 20.4284 15.4604 20.4284H18.4796C19.0806 20.4284 19.5863 20.0066 19.7006 19.4256C19.9466 18.1747 20.2496 16.4742 20.3634 15.1877C20.5143 13.4824 20.4594 11.0799 20.4075 9.70797C20.3925 9.31108 20.1897 8.94146 19.8566 8.7121L12.7166 3.79541ZM10.4235 2.49217C11.3764 1.83602 12.6236 1.83602 13.5765 2.49217L20.7165 7.40886C21.4457 7.91098 21.9104 8.73651 21.9448 9.64736C21.9966 11.0178 22.0564 13.5119 21.8956 15.3292C21.7738 16.7067 21.4561 18.4786 21.2089 19.7353C20.9461 21.0711 19.7924 22.0001 18.4796 22.0001H15.4604C14.4691 22.0001 13.6655 21.1791 13.6655 20.1665V15.9754C13.6655 15.8307 13.5507 15.7134 13.4091 15.7134H10.8956C10.754 15.7134 10.6392 15.8307 10.6392 15.9754V20.1665C10.6392 21.1791 9.83561 22.0001 8.84433 22.0001H5.52037C4.20761 22.0001 3.05389 21.0711 2.79113 19.7353C2.54392 18.4786 2.22624 16.7067 2.10437 15.3292C1.94358 13.5119 2.00338 11.0178 2.05515 9.64736C2.08957 8.73652 2.55427 7.91098 3.28346 7.40886L10.4235 2.49217Z\"/></svg>\n javascript\n  get link() {\n    return this.content || this.get(\"link\") || \"index.html\"\n  }\nviewSourceButtonParser\n description Print badge top right.\n extends abstractIconButtonParser\n string svg <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"92pt\" height=\"92pt\" viewBox=\"0 0 92 92\"><path d=\"M90.156 41.965 50.036 1.848a5.913 5.913 0 0 0-8.368 0l-8.332 8.332 10.566 10.566a7.03 7.03 0 0 1 7.23 1.684 7.043 7.043 0 0 1 1.673 7.277l10.183 10.184a7.026 7.026 0 0 1 7.278 1.672 7.04 7.04 0 0 1 0 9.957 7.045 7.045 0 0 1-9.961 0 7.038 7.038 0 0 1-1.532-7.66l-9.5-9.497V59.36a7.04 7.04 0 0 1 1.86 11.29 7.04 7.04 0 0 1-9.957 0 7.04 7.04 0 0 1 0-9.958 7.034 7.034 0 0 1 2.308-1.539V33.926a7.001 7.001 0 0 1-2.308-1.535 7.049 7.049 0 0 1-1.516-7.7L29.242 14.273 1.734 41.777a5.918 5.918 0 0 0 0 8.371L41.855 90.27a5.92 5.92 0 0 0 8.368 0l39.933-39.934a5.925 5.925 0 0 0 0-8.371\"/></svg>\n javascript\n  get link() {\n    return this.parent.file?.viewSourceUrl || \"\"\n  }\n  get style() {\n    return this.parent.findNodes(\"viewSourceButton\")[0] === this ? \"right:2rem;\": \"position:relative;\"\n  }\nloopParser\n extends abstractAftertextParser\n cells commandWordCell\n description Iterate over files+ to make HTML.\n cruxFromId\n inScope abstractItemsProviderParser\n joinParser\n  extends abstractLoopConfigParser\n  description HTML to use to join the items.\n limitParser\n  extends abstractLoopConfigParser\n  description HTML to use to join the items.\n javascriptParser\n  extends abstractLoopConfigParser\n  description Javascript to execute for each file in the loop.\n javascript\n  compile() {\n   const code = this.get(\"javascript\")\n   const joinWith = this.get(\"join\") ?? \"\"\n   try {\n    const limit = this.get(\"limit\")\n    let items = this.items\n    if (limit) items = items.slice(0, parseInt(limit))\n    return items.map((item, index) => eval(code)).join(joinWith)\n   } catch (err) {\n    console.error(err)\n    return \"\"\n   } finally {\n    this.teardown()\n   }\n  }\n  get items() {\n   const provider = this.getChildInstancesOfParserId(\"abstractItemsProviderParser\")[0]\n   return provider ? provider.items : []\n  }\n  teardown() {}\nloremIpsumParser\n extends abstractAftertextParser\n cruxFromId\n description Generate dummy text.\n catchAllCellType integerCell\n javascript\n  text = `Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.`\n  compile() {\n   return this.text.repeat(this.howMany)\n  }\n  get howMany() {\n    return this.getWord(1) ? parseInt(this.getWord(1)) : 1\n  }\nnickelbackIpsumParser\n extends loremIpsumParser\n javascript\n  text = `And one day, I‚Äôll be at the door. And lose your wings to fall in love? To the bottom of every bottle. I‚Äôm on the ledge of the eighteenth story. Why must the blind always lead the blind?`\nabstractTextLinkParser\n extends abstractAftertextParser\n cruxFromId\n javascript\n  compileEmbeddedVersion() {\n   return \"\"\n  }\n  compileTxt() {\n    return this.text\n  }\n  compile() {\n   return `<a class=\"abstractTextLinkParser\" href=\"${this.link}\">${this.text}</a>`\n  }\nscrollVersionLinkParser\n extends abstractTextLinkParser\n string link https://scroll.pub\n description Print Scroll version.\n javascript\n  get text() {\n    return `Built with Scroll v${this.parent.file?.SCROLL_VERSION || \"\"}`\n  }\nviewSourceLinkParser\n extends abstractTextLinkParser\n description Print \"View source\" link.\n string text View source\n javascript\n  get link() {\n    return this.parent.file?.viewSourceUrl || \"\"\n  }\nprintSnippetsParser\n // todo: why are we extending AT here and not loops? Is it for class/id etc?\n extends abstractAftertextParser\n cruxFromId\n cells commandWordCell\n catchAllCellType tagWithOptionalFolderCell\n description Prints snippets matching tag(s).\n example\n  printSnippets index\n javascript\n  makeSnippet(file, compileSettings) {\n    const {scrollProgram, endSnippetIndex} = file\n    if (endSnippetIndex === -1) return scrollProgram.compileEmbeddedVersion(compileSettings) + file.viewSourceHtml\n    const linkRelativeToCompileTarget = compileSettings.relativePath + file.permalink\n    const joinChar = \"\\n\"\n    const html = scrollProgram\n        .map((child, index) => (index >= endSnippetIndex ? \"\" : child.compileEmbeddedVersion ? child.compileEmbeddedVersion(compileSettings) : child.compile(compileSettings)))\n        .filter(i => i)\n        .join(joinChar)\n        .trim() +\n      `<a class=\"scrollContinueReadingLink\" href=\"${linkRelativeToCompileTarget}\">Continue reading...</a>`\n    return html\n  }\n  get files() {\n   const thisFile = this.parent.file\n   const files = this.parent.file.getFilesWithTagsForEmbedding(this.getWordsFrom(1), this.has(\"limit\") ? parseInt(this.get(\"limit\")) : undefined).filter(file => file.file !== thisFile)\n   // allow sortBy lastCommit Time\n   if (this.get(\"sortBy\") === \"commitTime\") {\n     return require(\"lodash\").sortBy(files, file => file.file.lastCommitTime).reverse()\n   }\n   return files\n  }\n  compile() {\n   const alreadyRequired = this.root.alreadyRequired\n   const snippets = this.files.map(file => {\n    const compileSettings = {relativePath: file.relativePath, alreadyRequired }\n    return `<div class=\"scrollSnippetContainer\">${this.makeSnippet(file.file, compileSettings)}</div>`\n    }).join(\"\\n\\n\")\n   return `<div class=\"scrollColumns\" style=\"column-width:35ch;\">${snippets}</div>`\n  }\n  compileTxt() {\n   return this.files.map(file =>  {\n    const title = file.file.title\n    const ruler = \"=\".repeat(title.length)\n    // Note: I tried to print the description here but the description generating code needs work.\n    return `${title}\\n${ruler}\\n${file.file.date}\\n${file.file.absoluteLink}`\n   }).join(\"\\n\\n\")\n  }\nprintFullSnippetsParser\n extends printSnippetsParser\n cruxFromId\n description Print full pages in group(s).\n javascript\n  makeSnippet(file, compileSettings) {\n   return file.scrollProgram.compileEmbeddedVersion(compileSettings) + file.viewSourceHtml\n  }\nprintRelatedParser\n description Print links to related posts.\n extends printSnippetsParser\n cruxFromId\n javascript\n  compile() {\n   const alreadyRequired = this.root.alreadyRequired\n   const list = this.files.map(fileWrapper => {\n    const {relativePath, file} = fileWrapper\n    const {title, permalink, year} = file\n    return `- ${title}${year ? \" (\" + year + \")\" : \"\"}\\n link ${relativePath + permalink}`\n    }).join(\"\\n\")\n    const items = this.parent.concat(list)\n    const html = items.map(item => item.compile()).join(\"\\n\")\n    items.forEach(item => item.destroy())\n   return html\n  }\nprintSourceStackParser\n // useful for debugging\n description Print compilation steps.\n extends abstractAftertextParser\n cruxFromId\n example\n  printOriginalSource\n javascript\n  get sources() {\n    const {file} = this.root\n    const passNames = [\"codeAtStart\", \"codeAfterImportPass\", \"codeAfterMacroPass\"]\n    let lastCode = \"\"\n    return passNames.map(name => {\n      let code = file[name]\n      if (lastCode === code)\n        code = \"[Unchanged]\"\n      lastCode = file[name]\n      return {\n      name,\n      code\n    }})\n  }\n  compile() {\n   return `<code class=\"scrollCodeBlock\">${this.compileTxt().replace(/\\</g, \"&lt;\")}</code>`\n  }\n  compileTxt() {\n   return this.sources.map((pass, index) => `Pass ${index + 1} - ${pass.name}\\n========\\n${pass.code}`).join(\"\\n\\n\\n\")\n  }\nabstractPrintMetaParser\n extends abstractScrollParser\n cruxFromId\nprintAuthorsParser\n description Prints author(s) byline.\n boolean isPopular true\n extends abstractPrintMetaParser\n // todo: we need pattern matching added to sdk to support having no params or a url and personNameCell\n catchAllCellType anyCell\n example\n  authors Breck Yunits\n   https://breckyunits.com\n  printAuthors\n javascript\n  compile() {\n   return this.parent.getNode(\"authors\")?.compileHtmlForPrint()\n  }\n  compileTxt() {\n    return this.parent.getNode(\"authors\")?.compileTxtForPrint()\n  }\nprintDateParser\n extends abstractPrintMetaParser\n // If not present computes the date from the file's ctime.\n description Print published date.\n boolean isPopular true\n javascript\n  compile() {\n   return `<div style=\"text-align: center;\" class=\"scrollDateline\">${this.day}</div>`\n  }\n  get day() {\n   let day = this.content || this.root.get(\"date\") || this.root.file?.date\n   if (!day) return \"\"\n   try {\n    const dayjs = require(\"dayjs\")\n    return dayjs(day).format(`MMMM D, YYYY`)\n   } catch (err) {\n    console.error(err)\n   }\n   return day || \"\"\n  }\n  compileTxt() {\n    return this.day\n  }\nprintFormatLinksParser\n description Prints links to other formats.\n extends abstractPrintMetaParser\n example\n  printFormatLinks\n javascript\n  compile() {\n   const permalink = this.root.file.permalink.replace(\".html\", \"\")\n   // hacky\n   const node = this.appendSibling(`HTML | TXT`, `class scrollDateline\\nlink ${permalink}.html HTML\\nlink ${permalink}.txt TXT\\nstyle text-align:center;`)\n   const html = node.compile()\n   node.destroy()\n   return html\n  }\n  compileTxt() {\n    const permalink = this.root.file.permalink.replace(\".html\", \"\")\n    return `HTML | TXT\\n link ${permalink}.html HTML\\n link ${permalink}.txt TXT`\n  }\nabstractBuildCommandParser\n extends abstractScrollParser\n cruxFromId\n cells buildCommandWordCell\n catchAllCellType filePathCell\n inScope slashCommentParser\n javascript\n  isTopMatter = true\n  compile() {\n   return \"\"\n  }\nloadConceptsParser\n // todo: clean this up. just add smarter imports with globs?\n // this currently removes any \"import\" statements.\n description Import all concepts in a folder.\n extends abstractBuildCommandParser\n cruxFromId\n cells preBuildCommandWordCell filePathCell\n javascript\n  build() {\n   const { Disk } = require(\"scrollsdk/products/Disk.node.js\")\n   const path = require(\"path\")\n   const {file} = this.parent\n   const folder = path.join(file.folderPath, this.getWord(1))\n   const ONE_BIG_FILE = Disk.getFiles(folder).filter(file => file.endsWith(\".scroll\")).map(Disk.read).filter(str => /^id /mg.test(str)).join(\"\\n\\n\").replace(/import .+/g, \"\")\n    this.parent.concat(ONE_BIG_FILE)\n   //console.log(ONE_BIG_FILE)\n  }\n  compile() {\n    return \"\"\n  }\nbuildConceptsParser\n cruxFromId\n description Write concepts to csv+ files.\n extends abstractBuildCommandParser\n sortByParser\n  cruxFromId\n  cells commandWordCell anyCell\nbuildCssParser\n description Compile to CSS file.\n extends abstractBuildCommandParser\nbuildCsvParser\n description Compile to CSV file.\n extends abstractBuildCommandParser\nfetchParser\n description Download URL to disk.\n extends abstractBuildCommandParser\n cruxFromId\n cells preBuildCommandWordCell urlCell\n example\n  fetch https://breckyunits.com/posts.csv\n  fetch https://breckyunits.com/posts.csv renamed.csv\n javascript\n  get url() {\n    return this.getWord(1)\n  }\n  get filename() {\n    return this.getWord(2) || new URL(this.url).pathname.split('/').pop()\n  }\n  get fullDiskPath() {\n    return require(\"path\").join(this.parent.file.folderPath, this.filename)\n  }\n  get exists() {\n    return this.isNodeJs() ? require(\"fs\").existsSync(this.fullDiskPath) : localStorage.getItem(this.filename)\n  }\n  async downloadToDisk() {\n    const { writeFile } = require('fs').promises\n    const response = await fetch(this.url)\n    const fileBuffer = await response.arrayBuffer()\n    await writeFile(this.fullDiskPath, Buffer.from(fileBuffer))\n  }\n  async downloadToLocalStorage() {\n    const response = await fetch(this.url)\n    const blob = await response.blob()\n    localStorage.setItem(this.filename, await blob.text())\n  }\n  async build() {\n   if (this.exists) return \"\" // do not fetch if already have a copy\n    await this.isNodeJs() ? this.downloadToDisk() : this.downloadToLocalStorage()\n  }\n  compile() {\n    return \"\"\n  }\nbuildHtmlParser\n description Compile to HTML file.\n extends abstractBuildCommandParser\n boolean isPopular true\nbuildMeasuresParser\n cruxFromId\n description Write measures to csv+ files.\n extends abstractBuildCommandParser\n sortByParser\n  cruxFromId\n  cells commandWordCell anyCell\nbuildRssParser\n description Write RSS file.\n extends abstractBuildCommandParser\nbuildJsParser\n description Compile to JS file.\n extends abstractBuildCommandParser\nbuildTxtParser\n description Compile to TXT file.\n extends abstractBuildCommandParser\n boolean isPopular true\nchatParser\n description A faux text chat conversation.\n catchAllParser chatLineParser\n cruxFromId\n extends abstractScrollParser\n example\n  chat\n   Hi\n   üëã\n javascript\n  compile() {\n   return this.map((line, index) => `<div style=\"text-align: ${index % 2 ? \"right\" : \"left\"};\" class=\"scrollChat ${index % 2 ? \"scrollChatRight\" : \"scrollChatLeft\"}\"><span>${line.asString}</span></div>`).join(\"\")\n  }\n  compileTxt() {\n    return this.childrenToString()\n  }\ncodeParser\n description A code block.\n catchAllParser lineOfCodeParser\n extends abstractScrollParser\n boolean isPopular true\n example\n  code\n   two = 1 + 1\n javascript\n  compile() {\n   return `<code class=\"scrollCodeBlock\">${this.childrenToString().replace(/\\</g, \"&lt;\")}</code>`\n  }\n  compileTxt() {\n    return this.childrenToString()\n  }\n cruxFromId\ncodeWithHeaderParser\n cruxFromId\n catchAllCellType stringCell\n extends codeParser\n example\n  codeWithHeader math.py\n   two = 1 + 1\n javascript\n  compile() {\n   return `<div class=\"codeWithHeader\"><div class=\"codeHeader\">${this.content}</div>${super.compile()}</div>`\n  }\ncodeWithLanguageParser\n description Use this to specify the language of the code block, such as csvCode or rustCode.\n extends codeParser\n pattern ^[a-zA-Z0-9_]+Code$\nabstractScrollWithRequirementsParser\n extends abstractScrollParser\n cruxFromId\n javascript\n  compile(compileSettings) {\n    return this.getHtmlRequirements(compileSettings) + this.compileInstance()\n  }\ncopyButtonsParser\n extends abstractScrollWithRequirementsParser\n description Copy code widget.\n javascript\n  compileInstance() {\n   return \"\"\n  }\n string requireOnce\n  <script>\n  document.addEventListener(\"DOMContentLoaded\", () => document.querySelectorAll(\".scrollCodeBlock\").forEach(block =>\n   {\n    if (!navigator.clipboard) return\n    const button = document.createElement(\"span\")\n    button.classList.add(\"scrollCopyButton\")\n    block.appendChild(button)\n    button.addEventListener(\"click\", async () => {\n      await navigator.clipboard.writeText(block.innerText)\n      button.classList.add(\"scrollCopiedButton\")\n    })\n   }\n  ))\n  </script>\nabstractTableVisualizationParser\n extends abstractScrollWithRequirementsParser\n boolean isTableVisualization true\n javascript\n  get columnNames() {\n    return this.parent.columnNames\n  }\nheatrixParser\n cruxFromId\n example\n  heatrix\n   '2007 '2008 '2009 '2010 '2011 '2012 '2013 '2014 '2015 '2016 '2017 '2018 '2019 '2020 '2021 '2022 '2023 '2024\n   4 11 23 37 3 14 12 0 0 0 5 1 2 11 15 10 12 56\n description A heatmap matrix data visualization.\n catchAllParser heatrixCatchAllParser\n extends abstractTableVisualizationParser\n javascript\n  compile() {\n   // A hacky but simple way to do this for now.\n   const advanced = new TreeNode(\"heatrixAdvanced\")\n   advanced.appendLineAndChildren(\"table\", \"\\n \" + this.tableData.replace(/\\n/g, \"\\n \"))\n   const node = this.appendSibling(\"heatrixAdvanced\", advanced.childrenToString())\n   const html = node.compile()\n   node.destroy()\n   return html\n  }\n  get tableData() {\n    const {coreTable} = this.parent\n    return coreTable ? new TreeNode(coreTable).asSsv : this.childrenToString()\n  }\nheatrixAdvancedParser\n cruxFromId\n catchAllParser heatrixCatchAllParser\n extends abstractTableVisualizationParser\n description Advanced heatrix.\n example\n  heatrix\n   table\n     \n    %h10; '2007 '2008 '2009\n     12 4 323\n   scale\n    #ebedf0 0\n    #c7e9c0 100\n    #a1d99b 400\n    #74c476 1600\n javascript\n  compile() {\n  class Heatrix {\n    static HeatrixId = 0\n    uid = Heatrix.HeatrixId++\n    constructor(program) {\n      const isDirective = word => /^(f|l|w|h)\\d+$/.test(word) || word === \"right\" || word === \"left\" || word.startsWith(\"http://\") || word.startsWith(\"https://\") || word.endsWith(\".html\")\n      const tree = new TreeNode(program)\n      this.program = tree\n      const generateColorBinningString = (data, colors) => {\n       const sortedData = [...data].sort((a, b) => a - b);\n       const n = sortedData.length;\n       const numBins = colors.length;\n       // Calculate the indices for each quantile\n       const indices = [];\n       for (let i = 1; i < numBins; i++) {\n         indices.push(Math.floor((i / numBins) * n));\n       }\n       // Get the quantile values and round them\n       const thresholds = indices.map(index => Math.round(sortedData[index]));\n       // Generate the string\n       let result = '';\n       colors.forEach((color, index) => {\n         const threshold = index === colors.length - 1 ? thresholds[index - 1] * 2 : thresholds[index];\n         result += `${color} ${threshold}\\n`;\n       });\n       return result.trim();\n      }\n      const buildScale = (table) => {\n        const numbers = table.split(\"\\n\").map(line => line.split(\" \")).flat().filter(word => !isDirective(word)).map(word => parseFloat(word)).filter(number => !isNaN(number))\n        const colors = ['#ebedf0', '#c7e9c0', '#a1d99b', '#74c476', '#41ab5d', '#238b45', '#005a32'];\n        numbers.unshift(0)\n        return generateColorBinningString(numbers, colors);\n      }\n      const table = tree.getNode(\"table\").childrenToString()\n      const scale = tree.getNode(\"scale\")?.childrenToString() || buildScale(table)\n      const thresholds = []\n      const colors = []\n      scale.split(\"\\n\").map((line) => {\n        const parts = line.split(\" \")\n        thresholds.push(parseFloat(parts[1]))\n        colors.push(parts[0])\n      })\n      const colorCount = colors.length\n      const colorFunction = (value) => {\n        if (isNaN(value)) return \"\" // #ebedf0\n        for (let index = 0; index < colorCount; index++) {\n          const threshold = thresholds[index]\n          if (value <= threshold) return colors[index]\n        }\n        return colors[colorCount - 1]\n      }\n      const directiveDelimiter = \";\"\n      const getSize = (directives, letter) =>\n        directives\n          .filter((directive) => directive.startsWith(letter))\n          .map((dir) => dir.replace(letter, \"\") + \"px\")[0] ?? \"\"\n      this.table = table.split(\"\\n\").map((line) =>\n        line\n          .trimEnd()\n          .split(\" \")\n          .map((cell) => {\n            const words = cell.split(directiveDelimiter).filter((word) => !isDirective(word)).join(\"\")\n            const directivesInThisCell = cell\n              .split(directiveDelimiter)\n              .filter(isDirective)\n            const value = parseFloat(words)\n            const label = words.includes(\"'\") ? words.split(\"'\")[1] : words\n            const alignment = directivesInThisCell.includes(\"right\")\n              ? \"right\"\n              : directivesInThisCell.includes(\"left\")\n              ? \"left\"\n              : \"\"\n            const color = colorFunction(value)\n            const width = getSize(directivesInThisCell, \"w\")\n            const height = getSize(directivesInThisCell, \"h\")\n            const fontSize = getSize(directivesInThisCell, \"f\")\n            const lineHeight = getSize(directivesInThisCell, \"l\") || height\n            const link = directivesInThisCell.filter(i => i.startsWith(\"http\") || i.endsWith(\".html\"))[0]\n            const style = {\n              \"background-color\": color,\n              width,\n              height,\n              \"font-size\": fontSize,\n              \"line-height\": lineHeight,\n              \"text-align\": alignment,\n            }\n            Object.keys(style).filter(key => !style[key]).forEach((key) => delete style[key])\n            return {\n              value,\n              label,\n              style,\n              link,\n            }\n          })\n      )\n    }\n    get html() {\n      const { program } = this\n      const cssId = `#heatrix${this.uid}`\n      const defaultWidth = \"40px\"\n      const defaultHeight = \"40px\"\n      const fontSize = \"10px\"\n      const lineHeight = defaultHeight\n      const style = `<style>\n      .heatrixContainer {\n        margin: auto;\n      }.heatrixRow {white-space: nowrap;}\n  ${cssId} .heatrixCell {\n    font-family: arial;\n    border-radius: 2px;\n    border: 1px solid transparent;\n    display: inline-block;\n    margin: 1px;\n    text-align: center;\n    vertical-align: middle;\n    overflow: hidden;\n    text-overflow: ellipsis;\n  }\n  .heatrixCell a {\n    color: black;\n  }\n  ${cssId} .heatrixCell{\n   width: ${defaultWidth};\n   height: ${defaultHeight};\n   font-size: ${fontSize};\n   line-height: ${lineHeight};\n  }\n  </style>`\n      const firstRow = this.table[0]\n      return (\n        `<div class=\"heatrixContainer\" id=\"heatrix${this.uid}\">${style}` +\n        this.table\n          .map((row, rowIndex) => {\n            if (!rowIndex) return \"\"\n            const rowStyle = row[0].style\n            return `<div class=\"heatrixRow heatrixRow${rowIndex}\">${row\n              .map((cell, columnIndex) => {\n                if (!columnIndex) return \"\"\n                const columnStyle = firstRow[columnIndex]?.style || {}\n                let { value, label, style, link } = cell\n                const extendedStyle = Object.assign(\n                  {},\n                  rowStyle,\n                  columnStyle,\n                  style\n                )\n                const inlineStyle = Object.keys(extendedStyle)\n                  .map((key) => `${key}:${extendedStyle[key]};`)\n                  .join(\"\")\n                let valueClass = value ? \" valueCell\" : \"\"\n                const href = link ? ` href=\"${link}\"` : \"\"\n                return `<div class=\"heatrixCell heatrixColumn${columnIndex}${valueClass}\" style=\"${inlineStyle}\"><a title=\"${label}\" ${href}>${label}</a></div>`\n              })\n              .join(\"\")}</div>`\n          })\n          .join(\"\\n\") +\n        \"</div>\"\n      ).replace(/\\n/g, \"\")\n    }\n  }\n    return new Heatrix(this.childrenToString().trim()).html\n  }\nabstractPlotParser\n // Observablehq\n extends abstractTableVisualizationParser\n string copyFromExternal d3.js plot.js\n string requireOnce\n  <script src=\"d3.js\"></script>\n  <script src=\"plot.js\"></script>\n example\n  plot\n inScope abstractColumnNameParser\n javascript\n  compileInstance() {\n   const id = \"plot\" + this._getUid()\n   return `<div id=\"${id}\"></div><script>\n   {\n    let loadChart = async () => {\n    const data = ${this.dataCode}\n    const get = (col, index ) => col !== \"undefined\" ? col : (index === undefined ? undefined : Object.keys(data[0])[index])\n    document.querySelector(\"#${id}\").append(Plot.plot(${this.plotOptions}))\n    }\n    loadChart()\n    }\n    </script>`\n  }\n  get marks() {\n    // just for testing purposes\n    return `Plot.rectY({length: 10000}, Plot.binX({y: \"count\"}, {x: d3.randomNormal()}))`\n  }\n  get dataCode() {\n    const {coreTable} = this.parent\n    return `d3.csvParse(\\`${new TreeNode(coreTable).asCsv}\\`, d3.autoType)`\n  }\n  get plotOptions() {\n    return `{\n      title: \"${this.get(\"title\") || \"\"}\",\n      subtitle: \"${this.get(\"subtitle\") || \"\"}\",\n      caption: \"${this.get(\"caption\") || \"\"}\",\n      symbol: {legend: ${this.has(\"symbol\")}},\n      color: {legend: ${this.has(\"fill\")}},\n      grid: ${this.get(\"grid\") !== \"false\"},\n      marks: [${this.marks}],\n    }`\n  }\nscatterplotParser\n extends abstractPlotParser\n description Scatterplot Widget.\n // todo: make copyFromExternal work with inheritance\n string copyFromExternal d3.js plot.js\n javascript\n  get marks() {\n    const x = this.get(\"x\")\n    const y = this.get(\"y\")\n    const text = this.get(\"label\")\n    return `Plot.dot(data, {\n      x: get(\"${x}\", 0),\n      y: get(\"${y}\", 1),\n      r: get(\"${this.get(\"radius\")}\"),\n      fill: get(\"${this.get(\"fill\")}\"),\n      tip: true,\n      symbol: get(\"${this.get(\"symbol\")}\")} ), Plot.text(data, {x: get(\"${x}\",0), y: get(\"${y}\", 1), text: \"${text}\", dy: -6, lineAnchor: \"bottom\"})`\n  }\nsparklineParser\n description Sparkline widget.\n extends abstractTableVisualizationParser\n example\n  sparkline 1 2 3 4 5\n string copyFromExternal sparkline.js\n string requireOnce <script src=\"sparkline.js\"></script>\n catchAllCellType numberCell\n // we need pattern matching\n inScope scrollYParser\n javascript\n  compileInstance() {\n   const id = \"spark\" + this._getUid()\n   const {columnValues} = this\n   const start = this.has(\"start\") ? parseInt(this.get(\"start\")) : 0\n   const width = this.get(\"width\") || 100\n   const height = this.get(\"height\") || 30\n   const lineColor = this.get(\"color\") || \"black\"\n   return `<span id=\"${id}\"></span><script>new Sparkline(document.getElementById(\"${id}\"), {dotRadius: 0, width: ${width}, height: ${height}, lineColor: \"${lineColor}\", tooltip: (value,index) => ${start} + index + \": \" + value}).draw(${JSON.stringify(columnValues)})</script>`\n  }\n  get columnValues() {\n    if (this.content)\n      return this.content.split(\" \").map(str => parseFloat(str))\n    const {coreTable} = this.parent\n    if (coreTable) {\n      const columnName = this.get(\"y\") || Object.keys(coreTable[0]).find(key => typeof coreTable[0][key] === 'number')\n      return coreTable.map(row => row[columnName])\n    }\n  }\nprintTableParser\n cruxFromId\n description Print table.\n extends abstractTableVisualizationParser\n javascript\n  get tableHeader() {\n   return this.columns.filter(col => !col.isLink).map(column => `<th>${column.name}</th>\\n`)\n  }\n  get columnNames() {\n   return this.parent.columnNames\n  }\n  get columns() {\n   const {columnNames} = this\n   return columnNames.map((name, index) => {\n    const isLink = name.endsWith(\"Link\")\n    const linkIndex = columnNames.indexOf(name + \"Link\")\n    return {\n     name,\n     isLink,\n     linkIndex\n    }\n   })\n  }\n  toRow(row) {\n    const {columns} = this\n    const words = columns.map(col => row[col.name])\n   let str = \"\"\n   let column = 0\n   const columnCount = columns.length\n   while (column < columnCount) {\n    const col = columns[column]\n    column++\n    const content = ((columnCount === column ? words.slice(columnCount - 1).join(\" \") : words[column - 1]) ?? \"\").toString()\n    if (col.isLink) continue\n    let tagged = content\n    const link = words[col.linkIndex]\n    if (col.linkIndex > -1 && link) tagged = `<a href=\"${link}\">${content}</a>`\n    else if (content.match(/^https?\\:[^ ]+$/)) tagged = `<a href=\"${content}\">${content}</a>`\n    str += `<td>${tagged}</td>\\n`\n   }\n   return str\n  }\n  get tableBody() {\n   return this.parent.coreTable\n    .map(row => `<tr>${this.toRow(row)}</tr>`)\n    .join(\"\\n\")\n  }\n  compile() {\n   return `<table id=\"table${this._getUid()}\" class=\"scrollTable\">\n   <thead><tr>${this.tableHeader.join(\"\\n\")}</tr></thead>\n   <tbody>${this.tableBody}</tbody>\n   </table>\n   <script>\n   document.querySelector('#table${this._getUid()}').addEventListener('click', e => {\n    if (window.getSelection().toString() || e.target.closest('a') || !e.target.closest('tbody')) return;\n    e.currentTarget.classList.toggle('expandedTable');\n   });\n   </script>`\n  }\n  compileTxt() {\n    return this.parent.delimitedData || new TreeNode(this.parent.coreTable).asCsv\n  }\nkatexParser\n extends abstractScrollWithRequirementsParser\n catchAllCellType codeCell\n catchAllParser lineOfCodeParser\n example\n  katex\n   \\text{E} = \\text{T} / \\text{A}!\n description KaTex widget for typeset math.\n string copyFromExternal katex.min.css katex.min.js\n string requireOnce\n  <link rel=\"stylesheet\" href=\"katex.min.css\">\n  <script defer src=\"katex.min.js\"></script>\n  <script>\n  document.addEventListener(\"DOMContentLoaded\", () => document.querySelectorAll(\".scrollKatex\").forEach(el =>\n   {\n    katex.render(el.innerText, el, {\n        throwOnError: false\n    });\n   }\n  ))\n  </script>\n javascript\n  compileInstance() {\n   const id = this._getUid()\n   const content = this.content === undefined ? \"\" : this.content\n   return `<div class=\"scrollKatex\" id=\"${id}\">${content + this.childrenToString()}</div>`\n  }\n  compileTxt() {\n    return ( this.content ? this.content : \"\" )+ this.childrenToString()\n  }\nmapParser\n inScope latParser longParser\n zoomParser\n  cells commandWordCell integerCell\n  cruxFromId\n  single\n heightParser\n  cells commandWordCell floatCell\n  cruxFromId\n  single\n pointParser\n  cells commandWordCell\n  inScope latParser longParser\n  cruxFromId\n  titleParser\n   extends abstractPointConfigParser\n  descriptionParser\n   extends abstractPointConfigParser\n extends abstractScrollWithRequirementsParser\n description Map widget.\n string copyFromExternal leaflet.css leaflet.js\n string requireOnce\n  <link rel=\"stylesheet\" href=\"leaflet.css\">\n  <script src=\"leaflet.js\"></script>\n javascript\n  compileInstance() {\n   const height = 500\n   const id = this._getUid()\n   return `<div id=\"map${id}\" style=\"height: ${height}px;\"></div>\n  <script>\n   {\n    const lat = ${this.get(\"lat\") ?? 37.8}\n    const long = ${this.get(\"long\") ?? 4}\n    const zoomLevel = ${this.get(\"zoom\") ?? 4}\n    const points = ${JSON.stringify(this.findNodes(\"point\").map(node => node.toObject()))}\n    const map = L.map(\"map${id}\").setView([lat, long], zoomLevel)\n    L.tileLayer(\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\", {\n     attribution: '<a href=\"https://www.openstreetmap.org/\">OpenStreetMap</a>',\n     maxZoom: 18\n    }).addTo(map)\n    points.forEach(point => {\n     L.marker([point.lat, point.long])\n      .addTo(map)\n      .bindPopup(\"<b>\" +point.title + \"</b><br />\" + point.description)\n    })\n   }\n  </script>`\n  }\nhelpfulNotFoundParser\n extends abstractScrollWithRequirementsParser\n catchAllCellType filePathCell\n string copyFromExternal helpfulNotFound.js\n description Helpful not found widget.\n javascript\n  compileInstance() {\n   return `<style>#helpfulNotFound{margin: 100px 0;}</style><h1 id=\"helpfulNotFound\"></h1><script defer src=\"/helpfulNotFound.js\"></script><script>document.addEventListener(\"DOMContentLoaded\", () => new NotFoundApp('${this.content}'))</script>`\n  }\nslideshowParser\n // Left and right arrows navigate.\n description Slideshow widget. *** delimits slides.\n extends abstractScrollWithRequirementsParser\n string copyFromExternal jquery-3.7.1.min.js slideshow.js\n example\n  slideshow\n  Why did the cow cross the road?\n  ***\n  Because it wanted to go to the MOOOO-vies.\n  ***\n  THE END\n  ****\n javascript\n  compile() {\n   return `<style>html {font-size: var(--base-font-size, 28px);} body {margin: auto; width: 500px;}.slideshowNav{text-align: center; margin-bottom:20px; font-size: 24px;color: rgba(204,204,204,.8);} a{text-decoration: none; color: rgba(204,204,204,.8);}</style><script defer src=\"jquery-3.7.1.min.js\"></script><div class=\"slideshowNav\"></div><script defer src=\"slideshow.js\"></script>`\n  }\ntableSearchParser\n extends abstractScrollWithRequirementsParser\n string copyFromExternal jquery-3.7.1.min.js datatables.css datatables.min.js tableSearch.js\n string requireOnce\n  <script defer src=\"jquery-3.7.1.min.js\"></script>\n  <style>.dt-search{font-family: \"SF Pro\", \"Helvetica Neue\", \"Segoe UI\", \"Arial\";}</style>\n  <link rel=\"stylesheet\" href=\"datatables.css\">\n  <script defer src=\"datatables.min.js\"></script>\n  <script defer src=\"tableSearch.js\"></script>\n // adds to all tables on page\n description Table search and sort widget.\n javascript\n  compileInstance() {\n   return \"\"\n  }\nabstractCommentParser\n description Prints nothing.\n catchAllCellType commentCell\n cells commentCell\n extends abstractScrollParser\n baseParser blobParser\n javascript\n  compile() {\n   return ``\n  }\n catchAllParser commentLineParser\ncommentParser\n extends abstractCommentParser\n cruxFromId\nslashCommentParser\n extends commentParser\n crux //\n boolean isPopular true\n description A comment. Prints nothing.\ncounterpointParser\n description A counterpoint. Prints nothing.\n extends commentParser\n crux !\nthanksToParser\n description Acknowledge reviewers. Prints nothing.\n extends abstractCommentParser\n cruxFromId\nprintConceptsParser\n description Print concepts.\n cruxFromId\n extends abstractScrollParser\n javascript\n   compile() {\n   // A hacky but simple way to do this for now.\n   const node = this.appendSibling(\"table\")\n    node.appendLine(\"delimiter \t\")\n    node.appendLine(\"printTable\")\n    const dataNode = node.appendLine(\"data\")\n    dataNode.setChildren(this.parent.file.compileConcepts(\"concepts.tsv\", this.get(\"sortBy\")))\n   const html = node.compile()\n   node.destroy()\n   return html\n   }\ncssParser\n extends abstractScrollParser\n description A style tag.\n cruxFromId\n catchAllParser cssLineParser\n catchAllCellType cssAnyCell\n javascript\n  compile() {\n   return `<style>${this.css}</style>`\n  }\n  get css() {\n    return this.content ?? this.childrenToString()\n  }\n  compileCss() {\n    return this.css\n  }\nabstractPostLoopParser\n description Do something with all posts. Takes an optional list of folder/group names.\n extends abstractScrollParser\n cruxFromId\n cells commandWordCell\n catchAllCellType tagWithOptionalFolderCell\n javascript\n  get files() {\n   return this.root.file.getFilesWithTagsForEmbedding(this.getWordsFrom(1))\n  }\nprintFeedParser\n description Print group to RSS.\n extends abstractPostLoopParser\n example\n  printFeed index\n  printFeed cars/index\n  buildRss feed.xml\n javascript\n  compile() {\n   const dayjs = require(\"dayjs\")\n   const file = this.root.file\n   const files = this.files.map(file => file.file)\n   const { title, baseUrl, description } = file\n   return `<?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?>\n  <rss version=\"2.0\">\n  <channel>\n   <title>${title}</title>\n   <link>${baseUrl}</link>\n   <description>${description}</description>\n   <lastBuildDate>${dayjs().format(\"ddd, DD MMM YYYY HH:mm:ss ZZ\")}</lastBuildDate>\n   <language>en-us</language>\n  ${files.map(file => file.toRss()).join(\"\\n\")}\n  </channel>\n  </rss>`\n  }\n  compileTxt() {\n    return this.compile()\n  }\nprintCsvParser\n description Print group metadata to CSV.\n extends printFeedParser\n example\n  printCsv index\n  buildTxt posts.csv\n javascript\n  compile() {\n   const file = this.root.file\n   const files = file.getFilesWithTagsForEmbedding(this.getWordsFrom(1)).map(file => file.file)\n   const header = file.csvFields\n   return `${header.join(\",\")}\\n${files.map(file => file.toCsv()).join(\"\\n\")}`\n  }\nprintSourceParser\n description Print source for files in group(s).\n extends printFeedParser\n example\n  printSource index\n  buildTxt source.txt\n javascript\n  compile() {\n   const file = this.root.file\n   const files = file.getFilesWithTagsForEmbedding(this.getWordsFrom(1)).map(file => file.file)\n   return `${files.map(file => file.filePath + \"\\n \" + file.codeAtStart.replace(/\\n/g, \"\\n \") ).join(\"\\n\")}`\n  }\nprintSearchTableParser\n description Prints files to HTML table.\n extends abstractPostLoopParser\n example\n  printSearchTable\n  tableSearch\n javascript\n  compile() {\n   const file = this.root.file\n   const files = this.files\n   const data = files.map(file => file.file.toSearchTsvRow(file.relativePath)).join(\"\\n\")\n   // A hacky but simple way to do this for now.\n     const node = this.appendSibling(\"table\")\n    node.appendLine(\"delimiter \t\")\n    node.appendLine(\"printTable\")\n    const dataNode = node.appendLine(\"data\")\n    dataNode.setChildren(\"title titleLink text date wordCount minutes\".replace(/ /g, \"\\t\") + \"\\n\" + data)\n   const html = node.compile()\n   node.destroy()\n   return html\n  }\nprintSiteMapParser\n extends abstractPostLoopParser\n description Print text sitemap.\n example\n  baseUrl http://test.com\n  printSiteMap\n javascript\n  compile() {\n   const file = this.root.file\n   const { baseUrl } = file\n   return this.files.map(file => baseUrl + file.relativePath + file.file.permalink).join(\"\\n\")\n  }\n  compileTxt() {\n    return this.compile()\n  }\nscrollDashboardParser\n description Key stats in large font.\n catchAllParser lineOfCodeParser\n crux dashboard\n extends abstractScrollParser\n example\n  dashboard\n   #2 Popularity\n   30 Years Old\n   $456 Revenue\n javascript\n  get tableBody() {\n   const items = this.topDownArray\n   let str = \"\"\n   for (let i = 0; i < items.length; i = i + 3) {\n    str += this.makeRow(items.slice(i, i + 3))\n   }\n   return str\n  }\n  makeRow(items) {\n   return `<tr>` + items.map(node => `<td>${node.firstWord}<span>${node.content}</span></td>`).join(\"\\n\") + `</tr>\\n`\n  }\n  compile() {\n   return `<table class=\"scrollDashboard\">${this.tableBody}</table>`\n  }\n  compileTxt() {\n    return this.childrenToString()\n  }\nabstractTopLevelSingleMetaParser\n description Use these keywords once per file.\n extends abstractScrollParser\n inScope slashCommentParser\n cruxFromId\n cells metaCommandWordCell\n javascript\n  isTopMatter = true\n  isSetterParser = true\n  compile() {\n   return \"\"\n  }\ndateParser\n catchAllCellType dateCell\n description Set published date.\n extends abstractTopLevelSingleMetaParser\n boolean isPopular true\n example\n  date 1/11/2019\n  printDate\n  Hello world\n   dateline\nsiteOwnerEmailParser\n description Set email address for site contact.\n extends abstractTopLevelSingleMetaParser\n crux email\n cells metaCommandWordCell emailAddressCell\nimportOnlyParser\n // This line will be not be imported into the importing file.\n description Don't build this file.\n cruxFromId\n cells preBuildCommandWordCell\n extends abstractTopLevelSingleMetaParser\n javascript\n  compile() {\n   return \"\"\n  }\ninlineMarkupsParser\n description Set global inline markups.\n extends abstractTopLevelSingleMetaParser\n cruxFromId\n example\n  inlineMarkups\n   * \n    // Disable * for bold\n   _ u\n    // Make _ underline\nabstractUrlSettingParser\n extends abstractTopLevelSingleMetaParser\n cells metaCommandWordCell urlCell\n cruxFromId\ncanonicalUrlParser\n description Override canonical URL.\n extends abstractUrlSettingParser\nopenGraphImageParser\n // https://ogp.me/\n // If not defined, Scroll will try to generate it's own using the first image tag on your page.\n description Override Open Graph Image.\n extends abstractUrlSettingParser\nbaseUrlParser\n description Required for RSS and OpenGraph.\n extends abstractUrlSettingParser\nrssFeedUrlParser\n description Set RSS feed URL.\n extends abstractUrlSettingParser\nviewSourceBaseUrlParser\n description Override source link baseUrl.\n extends abstractUrlSettingParser\nhtmlLangParser\n cells metaCommandWordCell stringCell\n // for the <html lang=\"\"> tag. If not specified will be \"en\". See https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/lang\n description Override HTML lang attribute.\n extends abstractTopLevelSingleMetaParser\nopenGraphDescriptionParser\n catchAllCellType stringCell\n crux description\n description Meta tag description.\n extends abstractTopLevelSingleMetaParser\npermalinkParser\n description Override output filename.\n extends abstractTopLevelSingleMetaParser\n cells metaCommandWordCell permalinkCell\nscrollTagsParser\n crux tags\n description Set tags.\n example\n  tags All\n extends abstractTopLevelSingleMetaParser\n catchAllCellType tagCell\ntestStrictParser\n description Make catchAllParagraphParser = error.\n extends abstractTopLevelSingleMetaParser\npageTitleParser\n catchAllCellType personNameCell\n crux title\n description Set title.\n example\n  title Eureka\n  printTitle\n extends abstractTopLevelSingleMetaParser\n boolean isPopular true\nviewSourceUrlParser\n catchAllCellType urlCell\n description Override source link.\n extends abstractTopLevelSingleMetaParser\nbelowAsCodeParser\n description Print code below.\n extends abstractScrollParser\n catchAllCellType integerCell\n cruxFromId\n javascript\n  method = \"next\"\n  get code() {\n   const { method } = this\n   let code = \"\"\n   \n   let nodes = []\n   let next = this[method]\n   let {howMany} = this\n   while (howMany) {\n    nodes.push(next)\n    next = next[method]\n    howMany--\n   }\n   if (this.reverse) nodes.reverse()\n   return nodes.map(node => node.asString).join(\"\\n\")\n  }\n  reverse = false\n  compile() {\n   return `<code class=\"scrollCodeBlock\">${this.code.replace(/\\</g, \"&lt;\")}</code>`\n  }\n  get howMany() {\n    let howMany = parseInt(this.getWord(1))\n   if (!howMany || isNaN(howMany)) howMany = 1\n   return howMany\n  }\nbelowAsCodeUntilParser\n description Print code above until match.\n extends belowAsCodeParser\n catchAllCellType anyCell\n example\n  belowAsCode\n  counter 1 second\n javascript\n  get howMany() {\n    let howMany = 1\n    const query = this.content\n    let node = this.next\n    while (node !== this) {\n      if (node.getLine().startsWith(query))\n        return howMany\n      node = node.next\n      howMany++\n    }\n    return howMany\n  }\naboveAsCodeParser\n description Print code above.\n example\n  counter 1 second\n  aboveAsCode\n extends belowAsCodeParser\n javascript\n  method = \"previous\"\n  reverse = true\nabstractThemeCssParser\n description Extend this to create a Scroll CSS theme.\n extends abstractScrollParser\n inScope themeTagsParser\n cruxFromId\n catchAllCellType stringCell\n string scrollStyles\n  figure\n   margin 0\n   padding 0\n  .dropcap:first-letter\n   font-size 3rem\n   line-height .9em\n   margin-right .125rem\n   display block\n   float left\n  .dinkus\n   text-align center\n   padding 1rem\n   span\n    vertical-align sub\n  details\n   margin-top 10px\n  summary\n   font-family \"SF Pro\", \"Helvetica Neue\", \"Segoe UI\", \"Arial\"\n   cursor pointer\n  .scrollCaptionedFigure\n   display block\n   break-inside avoid\n   max-width 100%\n   text-align center\n   img\n    max-width 100%\n    height auto\n    margin-top .1875rem\n   figcaption\n    font-family \"SF Pro\", \"Helvetica Neue\", \"Segoe UI\", \"Arial\"\n    font-size .8rem\n    .scrollParagraph\n     margin-top 0\n  .scrollCodeBlock\n   overflow auto\n   font-size .8rem\n   hyphens none\n   white-space pre\n   break-inside avoid\n   display block\n   margin .5rem 0\n   padding .5rem\n   border-radius 0\n   position relative\n  .codeWithHeader\n   break-inside avoid-column\n   margin 10px 0\n  .codeHeader\n   font-size 80%\n   text-align center\n   background rgba(224, 224, 224, 0.4)\n   border 1px solid rgba(204, 204, 204, 0.8)\n   border-bottom 0\n   margin-bottom -7px\n   padding 4px 2px\n   border-top-left-radius 3px\n   border-top-right-radius 3px\n  .scrollCodeBlock:hover\n   .scrollCopyButton\n    opacity .5\n   .scrollCopyButton:hover\n    opacity .8\n   .scrollCopyButton:active\n    opacity 1\n  .scrollCopyButton\n   position absolute\n   top .125rem\n   right .125rem\n   font-size .875rem\n   cursor pointer\n   opacity 0\n  .scrollCopyButton::after\n   content \"[ ]\"\n  .scrollCopiedButton::after\n   content \"[‚úì]\"\n javascript\n  compile() {\n   return `<style>\\n${this.css}\\n</style>`\n  }\n  compileTxt() {\n    return \"\"\n  }\n  compileCss() {\n    return this.css\n  }\n  compileEmbeddedVersion() {\n   return \"\"\n  }\n  get scrollCss() {\n    const hakonParser = this.root.hakonParser\n    return new hakonParser(this.scrollStyles).compile()\n  }\ngazetteCssParser\n description Default Scroll theme CSS.\n extends abstractThemeCssParser\n javascript\n  get css() {\n    if (this.constructor._cachedCss)\n      return this.constructor._cachedCss\n    const hakonParser = this.root.hakonParser\n    this.constructor._cachedCss = this.scrollCss + new hakonParser([this.hakonReset, this.hakonStandardStyles].join(\"\\n\")).compile()\n    return this.constructor._cachedCss\n  }\n // CSS Reset\n string hakonReset\n  html,body,div,span,p,ol,ul,li,table,figure\n   margin 0\n   padding 0\n   border 0\n   vertical-align baseline\n   border-spacing 0\n  ol,ul\n   padding-left 1rem\n  li\n   margin-top .4rem\n   line-height 1.4\n  a\n   text-decoration-color transparent\n   color #36c\n  a:hover\n   text-decoration-color initial\n  .scrollButton\n   background-color rgba(10,92,202,0.8)\n   border-radius 6px\n   color white\n   padding 10px 20px\n   display inline-block\n   border 0\n   cursor pointer\n   a\n    color white\n   &:hover\n    background-color rgb(10,92,202,0.9)\n   &:active\n    background-color rgb(10,92,202,1)\n  sup,sub\n   vertical-align baseline\n   position relative\n   top -.375rem\n  sub\n   top .375rem\n  html\n   padding .25rem\n   background-color rgb(244,244,244)\n   font-family Exchange,Georgia,serif\n   color #000\n   font-size var(--base-font-size, 16px)\n   hyphens auto\n  p\n   margin-top .4rem\n   line-height 1.4rem\n  .scrollQuote\n   break-inside avoid\n   display block\n   margin .5rem 0\n   padding .5rem\n   background rgba(204,204,204,.5)\n   white-space pre-line\n   border-left .5rem solid rgba(204,204,204,.8)\n  code\n   font-size .9rem\n   background-color rgba(204,204,204,.5)\n   padding .125rem .25rem\n   border-radius .25rem\n // Styles for Scroll standard tags\n string hakonStandardStyles\n  comment Main body of both pages is similar\n  .scrollParagraph\n   text-align justify\n  center\n   .scrollParagraph\n    text-align center\n  .scrollColumns\n   column-count auto\n   column-fill balance\n   column-width 35ch\n   column-gap 1.5rem\n   padding-left 1.25rem\n   padding-right 1.25rem\n   margin auto\n  comment On group pages add some spacing around files\n  .scrollSnippetContainer\n   padding 1ch 0\n   break-inside avoid\n   text-align justify\n  h1,h2,h3,h4\n   margin .625rem 0\n  h1\n   font-size 1.25rem\n  h2\n   font-size 1.125rem\n  h3,h4\n   font-size 1rem\n  h1.scrollTitle\n   text-align center\n   margin auto\n   margin-bottom .15625rem\n   margin-top 0\n   font-size 1.75rem\n   comment On narrow browsers like phones make sure the title doesn't overlap with the icons buttons in top left and right.\n   max-width calc(100vw - 2 * (1.5625rem + 1.875rem))\n   a\n    color #000\n  .scrollDateline\n   font-style italic\n   line-height 1.4rem\n   comment Decrease font size to deemphasize dateline but keep the line height the same to not cause different line spacing.\n   font-size .75rem\n  .scrollSection\n   break-inside avoid\n   h1,h2,h3,h4\n    text-align center\n  h4.scrollQuestion\n   text-align left\n   margin 1.4rem 0 0 0\n  .scrollSection:first-child\n   h1,h2,h3,h4\n    margin-top 0\n   h4.scrollQuestion\n    margin-top 0\n  .scrollNoteLink\n   opacity .4\n   text-decoration none\n   &:hover\n    opacity 1\n  .scrollFootNoteUsageLink\n   opacity .7\n   text-decoration none\n   &:hover\n    opacity 1\n  \n  .scrollHoverNote\n   text-decoration underline dashed 1px rgba(0,0,0,.1)\n   cursor default\n  \n  .scrollCodeBlock\n   border-left .5rem solid rgba(204,204,204,.8)\n  \n  .scrollTable\n   table-layout fixed\n   font-family \"SF Pro\", \"Helvetica Neue\", \"Segoe UI\", \"Arial\"\n   margin .5rem 0\n   overflow hidden\n   font-size .8rem\n   width 100%\n   hyphens none\n   border 1px solid rgba(224,224,224,.8)\n   td,th\n    padding .1875rem\n    overflow hidden\n    white-space nowrap\n   th\n    text-transform capitalize\n    border-bottom 2px solid rgba(0,0,0,.6)\n    text-align left\n   td\n    cursor zoom-in\n   tr:nth-child(even)\n    background rgba(224,224,224,.6)\n  .scrollTable\n   pre\n    white-space nowrap\n    overflow hidden\n    margin 0\n  .scrollTable.expandedTable\n   pre\n    white-space unset\n    overflow unset\n   table-layout unset\n   background white\n   position relative\n   z-index 10\n   overflow unset\n   td,th\n    overflow unset\n    white-space unset\n   td\n    cursor zoom-out\n  \n  .scrollByLine\n   font-size .875rem\n   font-style italic\n   margin .25rem 0\n   text-align center\n  \n  comment Subtle \"Article Source\" link\n  a.abstractTextLinkParser\n   text-align center\n   display block\n   margin .5em auto\n   font-family Verdana\n   font-weight 100\n   color rgba(204,204,204,.5)\n   &:hover\n    color #333\n  \n  .scrollContinueReadingLink\n   display block\n   text-align center\n  \n  .scrollDashboard\n   width 100%\n   font-size 1.875rem\n   text-align center\n   font-weight bold\n   break-inside avoid\n   margin-top .5rem\n   margin-bottom .5rem\n   td\n    width 33.3%\n    border 1px solid #e8e8e8\n   span\n    font-size 1.25rem\n    display block\n  .scrollChat\n   span\n    font-family Verdana\n    margin-top .3125rem\n    padding .3125rem 1.25rem\n    border-radius .9375rem\n    display inline-block\n  .scrollChatLeft\n   span\n    background rgba(204,204,204, .5)\n  .scrollChatRight\n   span\n    color white\n    background rgb(0,132,255)\n  .scrollYouTubeHolder\n   position relative\n   width 100%\n   height 0\n   padding-bottom 56.25%\n  .scrollYouTubeEmbed\n   position absolute\n   top 0\n   left 0\n   width 100%\n   height 100%\ntufteCssParser\n // https://github.com/edwardtufte/tufte-css\n description Theme from Tufte CSS.\n extends abstractThemeCssParser\n javascript\n  get css() {\n    return this.scrollCss + this.tufteCss\n  }\n  tufteCss = `html {\n     font-size: 15px;\n  }\n   body {\n       width: 87.5%;\n       margin-left: auto;\n       margin-right: auto;\n       padding-left: 12.5%;\n       font-family: Palatino, \"Palatino Linotype\", \"Palatino LT STD\", \"Book Antiqua\", Georgia, serif;\n       background-color: #fffff8;\n       color: #111;\n       max-width: 1400px;\n       counter-reset: sidenote-counter;\n  }\n  /* Adds dark mode */\n   @media (prefers-color-scheme: dark) {\n       body {\n           background-color: #151515;\n           color: #ddd;\n      }\n  }\n   h1 {\n       font-weight: 400;\n       margin-top: 3rem;\n       margin-bottom: 1.5rem;\n       font-size: 2.4rem;\n       line-height: 1;\n  }\n  .scrollTitle a { text-decoration: none; font-size: 3.2rem;}\n  .scrollParagraph { text-align: justify; hyphens: auto;}\n  a.scrollNoteLink { text-decoration: none;}\n   h2 {\n       font-style: italic;\n       font-weight: 400;\n       margin-top: 2.1rem;\n       margin-bottom: 1.4rem;\n       font-size: 2.2rem;\n       line-height: 1;\n  }\n   h3 {\n       font-style: italic;\n       font-weight: 400;\n       font-size: 1.7rem;\n       margin-top: 2rem;\n       margin-bottom: 1.4rem;\n       line-height: 1;\n  }\n   hr {\n       display: block;\n       height: 1px;\n       width: 55%;\n       border: 0;\n       border-top: 1px solid #ccc;\n       margin: 1em 0;\n       padding: 0;\n  }\n   p.subtitle {\n       font-style: italic;\n       margin-top: 1rem;\n       margin-bottom: 1rem;\n       font-size: 1.8rem;\n       display: block;\n       line-height: 1;\n  }\n   .numeral {\n       font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif;\n  }\n   .danger {\n       color: red;\n  }\n   article {\n       padding: 5rem 0rem;\n  }\n   section {\n       padding-top: 1rem;\n       padding-bottom: 1rem;\n  }\n   p, dl, ol, ul {\n       font-size: 1.4rem;\n       line-height: 2rem;\n  }\n   p {\n       margin-top: 1.4rem;\n       margin-bottom: 1.4rem;\n       padding-right: 0;\n       vertical-align: baseline;\n  }\n  /* Chapter Epigraphs */\n   div.epigraph {\n       margin: 5em 0;\n  }\n   div.epigraph > blockquote {\n       margin-top: 3em;\n       margin-bottom: 3em;\n  }\n   div.epigraph > blockquote, div.epigraph > blockquote > p {\n       font-style: italic;\n  }\n   div.epigraph > blockquote > footer {\n       font-style: normal;\n  }\n   div.epigraph > blockquote > footer > cite {\n       font-style: italic;\n  }\n  /* end chapter epigraphs styles */\n   blockquote {\n       font-size: 1.4rem;\n  }\n   blockquote p {\n       width: 55%;\n       margin-right: 40px;\n  }\n   blockquote footer {\n       width: 55%;\n       font-size: 1.1rem;\n       text-align: right;\n  }\n   section > p, section > footer, section > table {\n       width: 55%;\n  }\n  /* 50 + 5 == 55, to be the same width as paragraph */\n   section > dl, section > ol, section > ul {\n       width: 50%;\n       -webkit-padding-start: 5%;\n  }\n   dt:not(:first-child), li:not(:first-child) {\n       margin-top: 0.25rem;\n  }\n  /* Links: replicate underline that clears descenders */\n   a:link, a:visited {\n       color: inherit;\n  }\n  /* Sidenotes, margin notes, figures, captions */\n   img {\n       max-width: 100%;\n  }\n   .sidenote, .marginnote {\n       float: right;\n       clear: right;\n       margin-right: -60%;\n       width: 50%;\n       margin-top: 0.3rem;\n       margin-bottom: 0;\n       font-size: 1.1rem;\n       line-height: 1.3;\n       vertical-align: baseline;\n       position: relative;\n  }\n   .sidenote-number {\n       counter-increment: sidenote-counter;\n  }\n   .sidenote-number:after, .sidenote:before {\n       font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif;\n       position: relative;\n       vertical-align: baseline;\n  }\n   .sidenote-number:after {\n       content: counter(sidenote-counter);\n       font-size: 1rem;\n       top: -0.5rem;\n       left: 0.1rem;\n  }\n   .sidenote:before {\n       content: counter(sidenote-counter) \" \";\n       font-size: 1rem;\n       top: -0.5rem;\n  }\n   blockquote .sidenote, blockquote .marginnote {\n       margin-right: -82%;\n       min-width: 59%;\n       text-align: left;\n  }\n   div.fullwidth, table.fullwidth {\n       width: 100%;\n  }\n   div.table-wrapper {\n       overflow-x: auto;\n       font-family: \"Trebuchet MS\", \"Gill Sans\", \"Gill Sans MT\", sans-serif;\n  }\n   .sans {\n       font-family: \"Gill Sans\", \"Gill Sans MT\", Calibri, sans-serif;\n       letter-spacing: 0.03em;\n  }\n   code, pre > code {\n       font-family: Consolas, \"Liberation Mono\", Menlo, Courier, monospace;\n       font-size: 1rem;\n       line-height: 1.42;\n       -webkit-text-size-adjust: 100%;\n      /* Prevent adjustments of font size after orientation changes in iOS. See https://github.com/edwardtufte/tufte-css/issues/81#issuecomment-261953409 */\n  }\n   .sans > code {\n       font-size: 1.2rem;\n  }\n   h1 > code, h2 > code, h3 > code {\n       font-size: 0.8em;\n  }\n   .marginnote > code, .sidenote > code {\n       font-size: 1rem;\n  }\n   pre > code {\n       font-size: 0.9rem;\n       width: 52.5%;\n       margin-left: 2.5%;\n       overflow-x: auto;\n       display: block;\n  }\n   pre.fullwidth > code {\n       width: 90%;\n  }\n   .fullwidth {\n       max-width: 90%;\n       clear: both;\n  }\n   span.newthought {\n       font-variant: small-caps;\n       font-size: 1.2em;\n  }\n   input.margin-toggle {\n       display: none;\n  }\n   label.sidenote-number {\n       display: inline-block;\n       max-height: 2rem;\n      /* should be less than or equal to paragraph line-height */\n  }\n   label.margin-toggle:not(.sidenote-number) {\n       display: none;\n  }\n   .iframe-wrapper {\n       position: relative;\n       padding-bottom: 56.25%;\n      /* 16:9 */\n       padding-top: 25px;\n       height: 0;\n  }\n   .iframe-wrapper iframe {\n       position: absolute;\n       top: 0;\n       left: 0;\n       width: 100%;\n       height: 100%;\n  }\n   @media (max-width: 760px) {\n       body {\n           width: 84%;\n           padding-left: 8%;\n           padding-right: 8%;\n      }\n       hr, section > p, section > footer, section > table {\n           width: 100%;\n      }\n       pre > code {\n           width: 97%;\n      }\n       section > dl, section > ol, section > ul {\n           width: 90%;\n      }\n       blockquote {\n           margin-left: 1.5em;\n           margin-right: 0em;\n      }\n       blockquote p, blockquote footer {\n           width: 100%;\n      }\n       label.margin-toggle:not(.sidenote-number) {\n           display: inline;\n      }\n       .sidenote, .marginnote {\n           display: none;\n      }\n       .margin-toggle:checked + .sidenote, .margin-toggle:checked + .marginnote {\n           display: block;\n           float: left;\n           left: 1rem;\n           clear: both;\n           width: 95%;\n           margin: 1rem 2.5%;\n           vertical-align: baseline;\n           position: relative;\n      }\n       label {\n           cursor: pointer;\n      }\n       div.table-wrapper, table {\n           width: 85%;\n      }\n       img {\n           width: 100%;\n      }\n  }`\nabstractHtmlParser\n extends abstractScrollParser\n catchAllParser htmlLineParser\n catchAllCellType htmlAnyCell\n javascript\n  compile() {\n   return `${this.content ?? \"\"}${this.childrenToString()}`\n  }\n  compileTxt() {\n    return \"\"\n  }\nhtmlParser\n extends abstractHtmlParser\n description HTML one liners or blocks.\n cruxFromId\nhtmlInlineParser\n extends abstractHtmlParser\n cells htmlAnyCell\n pattern ^<\n description Inline HTML.\n boolean isPopular true\n javascript\n  compile() {\n   return `${this.getLine() ?? \"\"}${this.childrenToString()}`\n  }\nscrollBrParser\n crux br\n description A break.\n extends abstractScrollParser\n catchAllCellType integerCell\n javascript\n  compile() {\n   return `<br>`.repeat(parseInt(this.getWord(1) || 1))\n  }\nstumpParser\n cruxFromId\n extends abstractScrollParser\n description Compile Stump to HTML.\n catchAllParser stumpContentParser\n javascript\n  compile() {\n   const file = this.parent.file\n   return file.compileStumpCode(this.childrenToString())\n  }\nstumpNoSnippetParser\n // todo: make noSnippets an aftertext directive?\n extends stumpParser\n description Compile Stump unless snippet.\n cruxFromId\n javascript\n  compileEmbeddedVersion() {\n   return \"\"\n  }\nabstractCaptionedParser\n extends abstractScrollParser\n cells commandWordCell urlCell\n inScope captionAftertextParser slashCommentParser\n cruxFromId\n javascript\n  compile(compileSettings) {\n   const caption = this.getNode(\"caption\")\n   const captionFig = caption ? `<figcaption>${caption.compile()}</figcaption>` : \"\"\n   const {figureWidth} = this\n   const widthStyle = figureWidth ? `width:${figureWidth}px; margin: auto;` : \"\"\n   const float = this.has(\"float\") ? `margin: 20px; float: ${this.get(\"float\")};` : \"\"\n   return `<figure class=\"scrollCaptionedFigure\" style=\"${widthStyle + float}\">${this.getFigureContent(compileSettings)}${captionFig}</figure>`\n  }\n  get figureWidth() {\n    return this.get(\"width\")\n  }\nimageParser\n description An img tag.\n boolean isPopular true\n extends abstractCaptionedParser\n example\n  image screenshot.png\n   caption A caption.\n inScope classMarkupParser aftertextIdParser linkParser linkTargetParser\n openGraphParser\n  description Add this line to make this the open graph image.\n  cruxFromId\n  cells commandWordCell\n javascript\n  get dimensions() {\n    const width = this.get(\"width\")\n    const height = this.get(\"height\")\n    if (width || height)\n      return {width, height}\n    if (!this.isNodeJs())\n      return {}\n    const src = this.filename\n    // If its a local image, get the dimensions and put them in the HTML\n    // to avoid flicker\n   if (src.startsWith(\"http:\") || src.startsWith(\"https:\")) return {}\n   const file = this.root.file\n    if (this._dimensions)\n      return this._dimensions\n    try {\n     const sizeOf = require(\"image-size\")\n     const path = require(\"path\")\n     const fullImagePath = path.join(file.folderPath, src)\n     this._dimensions = sizeOf(fullImagePath)\n     return this._dimensions\n    } catch (err) {\n     console.error(err)\n    }\n    return {}\n  }\n  get figureWidth() {\n    return this.dimensions.width\n  }\n  get filename() {\n    return this.getWord(1)\n  }\n  getFigureContent(compileSettings) {\n   const file = this.root.file\n   const linkRelativeToCompileTarget = (compileSettings ? (compileSettings.relativePath ?? \"\") : \"\") + this.filename\n   const {width, height} = this.dimensions\n   let dimensionAttributes = width || height  ? `width=\"${width}\" height=\"${height}\" ` : \"\"\n   // Todo: can we reuse more code from aftertext?\n   const className = this.has(\"class\") ? ` class=\"${this.get(\"class\")}\" ` : \"\"\n   const id = this.has(\"id\") ? ` id=\"${this.get(\"id\")}\" ` : \"\"\n   const clickLink = this.get(\"link\") || linkRelativeToCompileTarget\n   const target = this.has(\"target\") ? this.get(\"target\") : (this.has(\"link\") ? \"\" : \"_blank\")\n   return `<a href=\"${clickLink}\" target=\"${target}\" ${className} ${id}><img src=\"${linkRelativeToCompileTarget}\" ${dimensionAttributes}loading=\"lazy\"></a>`\n  }\n  compileTxt() {\n    const children = this.filter(node => node.compileTxt).map(node => node.compileTxt()).filter(i => i).join(\"\\n\")\n    return  \"[Image Omitted]\" + (children ? \"\\n \" + children.replace(/\\n/g, \"\\n \") : \"\")\n  }\nyouTubeParser\n extends abstractCaptionedParser\n // Include the YouTube embed URL such as https://www.youtube.com/embed/CYPYZnVQoLg\n description A YouTube video widget.\n example\n  youTube https://www.youtube.com/watch?v=lO8blNtYYBA\n javascript\n  getFigureContent() {\n   const url = this.getWord(1).replace(\"youtube.com/watch?v=\", \"youtube.com/embed/\")\n   return `<div class=\"scrollYouTubeHolder\"><iframe class=\"scrollYouTubeEmbed\" src=\"${url}\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe></div>`\n  }\nimportParser\n description Import a file.\n cruxFromId\n boolean isPopular true\n cells preBuildCommandWordCell\n extends abstractScrollParser\n catchAllCellType filePathCell\n javascript\n  compile() {\n   return \"\"\n  }\n example\n  import header.scroll\nscrollLeftRightButtonsParser\n crux leftRightButtons\n description Previous and next nav buttons.\n extends abstractScrollParser\n javascript\n  compileEmbeddedVersion() {\n   return \"\"\n  }\n  compile() {\n    const file = this.parent.file\n    const { linkToPrevious, linkToNext } = file\n    if (!linkToPrevious) return \"\"\n    const style = `a.keyboardNav {display:block;position:absolute;top:0.25rem; color: rgba(204,204,204,.8); font-size: 1.875rem; line-height: 1.7rem;}a.keyboardNav:hover{color: #333;text-decoration: none;}`\n    return `<style>${style}</style><a class=\"keyboardNav doNotPrint\" style=\"left:.5rem;\" href=\"${linkToPrevious}\">&lt;</a><a class=\"keyboardNav doNotPrint\" style=\"right:.5rem;\" href=\"${linkToPrevious}\">&gt;</a>`\n  }\nkeyboardNavParser\n description Make left and right navigate files.\n extends abstractScrollParser\n cruxFromId\n catchAllCellType urlCell\n javascript\n  compileEmbeddedVersion() {\n   return \"\"\n  }\n  compile() {\n   const file = this.root.file\n   const linkToPrevious = this.getWord(1) ?? file.linkToPrevious\n   const linkToNext = this.getWord(2) ?? file.linkToNext\n   const script = `<script>document.addEventListener('keydown', function(event) {\n    if (document.activeElement !== document.body) return\n    if (event.altKey || event.ctrlKey || event.metaKey || event.shiftKey) return // dont interfere with keyboard back button shortcut\n    const getLinks = () => document.getElementsByClassName(\"scrollKeyboardNav\")[0].getElementsByTagName(\"a\")\n    if (event.key === \"ArrowLeft\")\n      getLinks()[0].click()\n    else if (event.key === \"ArrowRight\")\n      getLinks()[1].click()\n   });</script>`\n   return `<div class=\"scrollKeyboardNav\" style=\"display:none;\"><a href=\"${linkToPrevious}\">${linkToPrevious}</a> ¬∑ ${file.permalink} ¬∑ <a href=\"${linkToNext}\">${linkToNext}</a>${script}</div>`\n  }\nprintUsageStatsParser\n // todo: if we include the word \"Parser\" in a crux, bad things seem to happen.\n description Parser usage stats for folder.\n extends abstractScrollParser\n cruxFromId\n javascript\n  get stats() {\n   const input = this.root.file.allScrollFiles.map(file => file.parserIds.join(\"\\n\")).join(\"\\n\")\n   const result = input.split('\\n').reduce((acc, word) => (acc[word] = (acc[word] || 0) + 1, acc), {})\n   return \"parserId uses\\n\" + Object.entries(result).map(([word, count]) => `${word} ${count}`).join('\\n')\n  }\n  compile() {\n    // A hacky but simple way to do this for now.\n   const node = this.appendSibling(\"table\")\n   node.appendLine(\"delimiter  \")\n   node.appendLine(\"printTable\")\n   const dataNode = node.appendLine(\"data\")\n    dataNode.setChildren(this.stats)\n   const html = node.compile()\n   node.destroy()\n   return html\n  }\n  compileTxt() {\n    return this.stats\n  }\nprintScrollLeetSheetParser\n description Print Scroll parser leet sheet.\n extends abstractScrollParser\n cruxFromId\n javascript\n  get parsersToDocument() {\n    const clone = this.root.clone()\n    clone.setChildren(\"\")\n    const words = clone.getAutocompleteResultsAt(0,0).matches.map(a => a.text)\n    words.push(\"blankline\") // manually add blank line\n    words.push(\"Catch All Paragraph.\") // manually add catch all paragraph\n    words.push(\"<h></h>\") // manually add html\n    words.sort()\n    clone.setChildren(words.join(\"\\n\").replace(/blankline/, \"\")) // insert blank line in right spot\n    return clone\n  }\n  sortDocs(docs) {\n    return docs.map(node => {\n      const {definition} = node\n      const {id, description, isPopular, examples} = definition\n      return {id: definition.cruxIfAny || id, description, isPopular, examples}\n     }).sort((a, b) => a.id.localeCompare(b.id))\n  }\n  makeLink(examples, crux) {\n    // if (!examples.length) console.log(crux) // find nodes that need docs\n    const example = examples.length ? examples[0].childrenToString() : crux\n    const base = `https://try.scroll.pub/`\n    const tree = new TreeNode()\n    tree.appendLineAndChildren(\"scroll\", \"gazetteCss\\n\" + example)\n    return base + \"#\" + encodeURIComponent(tree.asString)\n  }\n  docToHtml(doc) {\n   const css = `#scrollLeetSheet {color: grey;} #scrollLeetSheet a {color: #3498db; }`\n   return `<style>${css}</style><div id=\"scrollLeetSheet\">` + doc.map(obj => `<div><a href=\"${this.makeLink(obj.examples, obj.id)}\">${obj.isPopular ? \"<b>\" : \"\"}${obj.id}</a> ${obj.description}${obj.isPopular ? \"</b>\" : \"\"}</div>`).join(\"\\n\") + \"</div>\"\n  }\n  compile() {\n    return this.docToHtml(this.sortDocs(this.parsersToDocument))\n  }\n  compileTxt() {\n   return this.sortDocs(this.parsersToDocument).map(obj => `${obj.id} - ${obj.description}`).join(\"\\n\")\n  }\n  get lodash() {\n    return require(\"lodash\")\n  }\n  compileCsv() {\n    const rows = this.sortDocs(this.parsersToDocument).map(obj => {\n      const {id, isPopular, description} = obj\n      return {\n        id,\n        isPopular,\n        description\n      }\n    })\n    return new TreeNode(this.lodash.sortBy(rows, \"isPopular\")).asCsv\n  }\nprintparsersLeetSheetParser\n // todo: fix parse bug when word Parser appears in parserId\n extends printScrollLeetSheetParser\n description Parsers leetsheet.\n javascript\n  compile() {\n    return \"<p><b>Line Parsers</b> match lines and parse them.</p><br>\" + this.docToHtml(this.sortDocs(this.parsersToDocument)) + \"<p><b>Cell Parsers</b> parse words in a line.</p><br>\" + this.docToHtml(this.sortDocs(this.cellParsersToDocument))\n  }\n  makeLink() {\n    return \"\"\n  }\n  get cellParsersToDocument() {\n    const parsersParser = require(\"scrollsdk/products/parsers.nodejs.js\")\n    const clone = new parsersParser(\"anyCell\\n \").clone()\n    const parserNode = clone.getNode(\"anyCell\")\n    const words = clone.getAutocompleteResultsAt(1,1).matches.map(a => a.text)\n    words.sort()\n    parserNode.setChildren(words.join(\"\\n\"))\n    return parserNode\n  }\n  get parsersToDocument() {\n    const parsersParser = require(\"scrollsdk/products/parsers.nodejs.js\")\n    const clone = new parsersParser(\"latinParser\\n \").clone()\n    const parserNode = clone.getNode(\"latinParser\")\n    const words = clone.getAutocompleteResultsAt(1,1).matches.map(a => a.text)\n    words.sort()\n    parserNode.setChildren(words.join(\"\\n\"))\n    return parserNode\n  }\nprintMeasuresParser\n description Print measure stats.\n cruxFromId\n extends abstractScrollParser\n javascript\n   compile() {\n   // A hacky but simple way to do this for now.\n      const node = this.appendSibling(\"table\")\n    node.appendLine(\"delimiter \t\")\n    node.appendLine(\"printTable\")\n    const dataNode = node.appendLine(\"data\")\n    dataNode.setChildren(this.parent.file.compileMeasures(\"tsv\"))\n   const html = node.compile()\n   node.destroy()\n   return html\n   }\nabstractMeasureParser\n cells measureNameCell\n cruxFromId\n boolean isMeasure true\n float sortIndex 1.9\n boolean isComputed false\n string typeForCsvDocs unspecified\n extends abstractScrollParser\n javascript\n  compileEmbeddedVersion() {\n   return \"\"\n  }\n  compile() {\n   return \"\"\n  }\n  get measureValue() {\n    return this.content ?? \"\"\n  }\n  get measureName() {\n    return this.getFirstWordPath().replace(/ /g, \"_\")\n  }\nabstractWordMeasureParser\n description A measure that contains a single word.\n cells measureNameCell wordCell\n string typeForCsvDocs word\n extends abstractMeasureParser\nabstractUrlMeasureParser\n string typeForCsvDocs url\n cells measureNameCell urlCell\n extends abstractWordMeasureParser\nabstractStringMeasureParser\n string typeForCsvDocs string\n catchAllCellType stringCell\n extends abstractMeasureParser\nabstractIdParser\n crux id\n description What is the ID of this concept?\n extends abstractStringMeasureParser\n float sortIndex 1\n boolean isMeasureRequired true\n boolean isConceptDelimiter true\n javascript\n  getErrors() {\n    const errors = super.getErrors()\n    let requiredMeasureNames = this.parent.file.measures.filter(measure => measure.isMeasureRequired).map(measure => measure.Name).filter(name => name !== \"id\")\n    if (!requiredMeasureNames.length) return errors\n    let next = this.next\n    while (requiredMeasureNames.length && next.firstWord !== \"id\" && next.getIndex() !== 0) {\n      requiredMeasureNames = requiredMeasureNames.filter(i => i !== next.firstWord)\n      next = next.next\n    }\n    requiredMeasureNames.forEach(name =>\n      errors.push(this.makeError(`Concept \"${this.content}\" is missing required measure \"${name}\".`))\n    )\n    return errors\n  }\nabstractNumericMeasureParser\n string typeForCsvDocs number\n extends abstractMeasureParser\n javascript\n  get measureValue() {\n    const {content} = this\n    return content === undefined ? \"\" : parseFloat(content)\n  }\nabstractIntegerMeasureParser\n string typeForCsvDocs integer\n cells measureNameCell integerCell\n extends abstractNumericMeasureParser\nabstractFloatMeasureParser\n cells measureNameCell floatCell\n extends abstractNumericMeasureParser\nabstractPercentageMeasureParser\n cells measureNameCell percentCell\n extends abstractNumericMeasureParser\n javascript\n  get measureValue() {\n    const {content} = this\n    return content === undefined ? \"\" : parseFloat(content)\n  }\nabstractEnumMeasureParser\n string typeForCsvDocs enum\n cells measureNameCell enumCell\n extends abstractMeasureParser\nabstractBooleanMeasureParser\n string typeForCsvDocs boolean\n cells measureNameCell booleanCell\n extends abstractMeasureParser\n javascript\n  get measureValue() {\n    const {content} = this\n    return content === undefined ? \"\" : content == \"true\"\n  }\nmetaTagsParser\n cruxFromId\n extends abstractScrollParser\n description Print meta tags including title.\n javascript\n  compileEmbeddedVersion() {\n   return \"\"\n  }\n  compile() {\n   const { file } = this.parent\n   const { title, description, openGraphImage, SCROLL_VERSION, canonicalUrl } = file\n   const rssFeedUrl = this.parent.get(\"rssFeedUrl\")\n   let rssTag = \"\"\n   if (rssFeedUrl)\n    rssTag = `<link rel=\"alternate\" type=\"application/rss+xml\" title=\"${title}\" href=\"${rssFeedUrl}\">`\n   // todo: cleanup the head/body stuff.\n   return `<head>\n   <meta charset=\"utf-8\">\n   <title>${title}</title>\n   <script>/* This HTML was generated by üìú Scroll v${SCROLL_VERSION}. https://scroll.pub */</script>\n   <style>@media print {.doNotPrint {display: none !important;}}</style>\n   <link rel=\"canonical\" href=\"${canonicalUrl}\">\n   <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n   <meta name=\"description\" content=\"${description}\">\n   <meta name=\"generator\" content=\"Scroll v${SCROLL_VERSION}\">\n   <meta property=\"og:title\" content=\"${title}\">\n   <meta property=\"og:description\" content=\"${description}\">\n   <meta property=\"og:image\" content=\"${openGraphImage}\">\n   ${rssTag}\n   <meta name=\"twitter:card\" content=\"summary_large_image\">\n  </head>\n  <body>`\n  }\nscrollParserDefinitionParser\n extends abstractScrollParser\n // todo Figure out best pattern for merging Scroll and Parsers?\n pattern ^[a-zA-Z0-9_]+Parser$\n description Define your own Parsers.\n baseParser blobParser\n javascript\n  compile() {\n   return \"\"\n  }\nquoteParser\n cruxFromId\n description A quote.\n catchAllParser quoteLineParser\n extends abstractScrollParser\n javascript\n  compile() {\n   return `<blockquote class=\"scrollQuote\">${this.childrenToString()}</blockquote>`\n  }\n  compileTxt() {\n    return this.childrenToString()\n  }\nredirectToParser\n description HTML redirect tag.\n extends abstractScrollParser\n cells commandWordCell urlCell\n cruxFromId\n example\n  redirectTo https://scroll.pub/releaseNotes.html\n javascript\n  compile() {\n   return `<meta http-equiv=\"Refresh\" content=\"0; url='${this.getWord(1)}'\" />`\n  }\nabstractVariableParser\n extends abstractScrollParser\n catchAllCellType stringCell\n cells preBuildCommandWordCell\n cruxFromId\n javascript\n  isTopMatter = true\n  compile() {\n   return \"\"\n  }\nreplaceParser\n description Replace this with that.\n extends abstractVariableParser\n baseParser blobParser\n example\n  replace YEAR 2022\nreplaceJsParser\n description Replace this with evaled JS.\n extends replaceParser\n catchAllCellType javascriptCell\n example\n  replaceJs SUM 1+1\n  * 1+1 = SUM\nreplaceNodejsParser\n description Replace with evaled Node.JS.\n extends abstractVariableParser\n catchAllCellType javascriptCell\n baseParser blobParser\n example\n  replaceNodejs\n   module.exports = {SCORE : 1 + 2}\n  * The score is SCORE\nscriptParser\n extends abstractScrollParser\n description Print script tag.\n cruxFromId\n catchAllParser scriptLineParser\n catchAllCellType scriptAnyCell\n javascript\n  compile() {\n   return `<script>${this.scriptContent}</script>`\n  }\n  get scriptContent() {\n    return this.content ?? this.childrenToString()\n  }\n  compileJs() {\n    return this.scriptContent\n  }\nendSnippetParser\n description Cut for snippet here.\n extends abstractScrollParser\n cruxFromId\n javascript\n  compile() {\n   return \"\"\n  }\nstampParser\n description Expand project template to disk.\n extends abstractScrollParser\n inScope stampFolderParser\n catchAllParser stampFileParser\n example\n  stamp\n   .gitignore\n    *.html\n   readme.scroll\n    # Hello world\n    <script src=\"scripts/nested/hello.js\"></script>\n   scripts/\n    nested/\n     hello.js\n      console.log(\"Hello world\")\n cruxFromId\n cells preBuildCommandWordCell\n javascript\n  build() {\n    const dir = this.root.file.folderPath\n    this.forEach(node => node.build(dir))\n  }\nscrollTableParser\n description A table.\n crux table\n example\n  table\n   printTable\n   data\n    year,count\n    1900,10\n    2000,122\n    2020,23\n extends abstractScrollParser\n catchAllCellType filePathCell\n inScope scrollTableDataParser scrollTableDelimiterParser abstractTableVisualizationParser abstractTableTransformParser h1Parser h2Parser scrollQuestionParser\n javascript\n  get visualizations() {\n    return this.topDownArray.filter(node => node.isTableVisualization || node.isHeader)\n  }\n  compile(compileSettings) {\n   return this.visualizations.map(node => node.compile(compileSettings))\n     .join(\"\\n\")\n     .trim()\n  }\n  compileTxt() {\n    return this.visualizations.map(node => node.compileTxt())\n     .join(\"\\n\")\n     .trim()\n  }\n  get delimiter() {\n    const {filename} = this\n    let delimiter = \"\"\n    if (filename) {\n      const extension = filename.split(\".\").pop()\n      if (extension === \"json\") delimiter = \"json\"\n      if (extension === \"tree\") delimiter = \"tree\"\n      if (extension === \"csv\") delimiter = \",\"\n      if (extension === \"tsv\") delimiter = \"\\t\"\n    }\n    if (this.get(\"delimiter\"))\n      delimiter = this.get(\"delimiter\")\n    else {\n      const header = this.delimitedData.split(\"\\n\")[0]\n      if (header.includes(\"\\t\"))\n        delimiter = \"\\t\"\n      else if (header.includes(\",\"))\n       delimiter = \",\"\n      else\n       delimiter = \" \"\n    }\n    return delimiter\n  }\n  get filename() {\n    return this.content\n  }\n  get fileFromDisk() {\n    const path = require(\"path\")\n    const fs = require(\"fs\")\n    return fs.readFileSync(path.join(this.parent.file.folderPath, this.filename), \"utf8\")\n  }\n  get fileFromLocalStorage() {\n    return localStorage.getItem(this.filename) || \"\"\n  }\n  get fileContent() {\n    return this.isNodeJs() ? this.fileFromDisk : this.fileFromLocalStorage\n  }\n  get delimitedData() {\n    // json csv tsv\n    if (this.filename)\n      return this.fileContent\n    \n    return this.getNode(\"data\")?.childrenToString() || \"\"\n  }\n  _coreTable\n  get coreTable() {\n    if (this._coreTable) return this._coreTable\n    const {delimiter, delimitedData} = this\n    if (delimiter === \"json\")\n       this._coreTable = JSON.parse(delimitedData)\n    else if (delimiter === \"tree\") {\n       const d3lib = typeof d3 === \"undefined\" ? require('d3') : d3\n       this._coreTable = d3lib.dsvFormat(\",\").parse(new TreeNode(delimitedData).asCsv, d3lib.autoType)\n    } else {\n      const d3lib = typeof d3 === \"undefined\" ? require('d3') : d3\n      this._coreTable = d3lib.dsvFormat(delimiter).parse(delimitedData, d3lib.autoType)\n    }\n    this._columnNames = this._coreTable.columns\n    delete this._coreTable.columns\n    return this._coreTable\n  }\n  get columnNames() {\n    // init coreTable to set columns\n    const coreTable = this.coreTable\n    return this._columnNames\n  }\nplainTextParser\n description Plain text oneliner or block.\n cruxFromId\n extends abstractScrollParser\n catchAllParser plainTextLineParser\n catchAllCellType stringCell\n javascript\n  compile() {\n   return this.compileTxt()\n  }\n  compileTxt() {\n    return `${this.content ?? \"\"}${this.childrenToString()}`\n  }\nplainTextOnlyParser\n extends plainTextParser\n description Only print for buildTxt.\n javascript\n  compile() {\n   return \"\"\n  }\nabstractAftertextAttributeParser\n cells commandWordCell\n boolean isAttribute true\n javascript\n  get divAttributes() {\n   return `${this.firstWord}=\"${this.content}\"`\n  }\n  compile() {\n   return \"\"\n  }\naftertextIdParser\n crux id\n description Provide an ID to be output in the generated HTML tag.\n extends abstractAftertextAttributeParser\n cells commandWordCell htmlIdCell\n single\naftertextStyleParser\n crux style\n description Provide code for the generated HTML tag's \"style\" attribute.\n extends abstractAftertextAttributeParser\n cells commandWordCell\n catchAllCellType cssAnyCell\naftertextHiddenParser\n crux hidden\n cells commandWordCell\n description Do not compile this node to HTML.\n extends abstractAftertextAttributeParser\n single\naftertextTagParser\n cells commandWordCell htmlTagCell\n description Override the HTML tag that the compiled node will use.\n crux tag\n javascript\n  compile() {\n   return \"\"\n  }\nabstractAftertextDirectiveParser\n cells commandWordCell\n catchAllCellType stringCell\n javascript\n  isMarkup = true\n  compile() {\n   return \"\"\n  }\n  getErrors() {\n    const errors = super.getErrors()\n    if (!this.isMarkup || this.matchWholeLine) return errors\n    const inserts = this.getInserts(this.parent.originalTextPostLinkify)\n    // todo: make AbstractTreeError class exported by sdk to allow Parsers to define their own error types.\n    // todo: also need to be able to map lines back to their line in source (pre-imports)\n    if (!inserts.length)\n     errors.push(this.makeError(`No match found for \"${this.getLine()}\".`))\n    return errors\n  }\n  get pattern() {\n   return this.getWordsFrom(1).join(\" \")\n  }\n  get shouldMatchAll() {\n   return this.has(\"matchAll\")\n  }\n  getMatches(text) {\n   const { pattern } = this\n   const escapedPattern = pattern.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\")\n   return [...text.matchAll(new RegExp(escapedPattern, \"g\"))].map(match => {\n    const { index } = match\n    const endIndex = index + pattern.length\n    return [\n     { index, string: `<${this.openTag}${this.allAttributes}>`, endIndex },\n     { index: endIndex, endIndex, string: `</${this.closeTag}>` }\n    ]\n   })\n  }\n  getInserts(text) {\n   const matches = this.getMatches(text)\n   if (!matches.length) return false\n   if (this.shouldMatchAll) return matches.flat()\n   const match = this.getNode(\"match\")\n   if (match)\n    return match.indexes\n     .map(index => matches[index])\n     .filter(i => i)\n     .flat()\n   return matches[0]\n  }\n  get allAttributes() {\n   const attr = this.attributes.join(\" \")\n   return attr ? \" \" + attr : \"\"\n  }\n  get attributes() {\n   return []\n  }\n  get openTag() {\n   return this.tag\n  }\n  get closeTag() {\n   return this.tag\n  }\nabstractMarkupParser\n extends abstractAftertextDirectiveParser\n inScope abstractMarkupParameterParser\n javascript\n  get matchWholeLine() {\n    return this.getWordsFrom(this.patternStartsAtWord).length === 0\n  }\n  get pattern() {\n   return this.matchWholeLine ? this.parent.originalText : this.getWordsFrom(this.patternStartsAtWord).join(\" \")\n  }\n  patternStartsAtWord = 1\nboldParser\n cruxFromId\n description Bold matching text.\n extends abstractMarkupParser\n javascript\n  tag = \"b\"\nitalicsParser\n cruxFromId\n description Italicize matching text.\n extends abstractMarkupParser\n javascript\n  tag = \"i\"\nunderlineParser\n description Underline matching text.\n cruxFromId\n extends abstractMarkupParser\n javascript\n  tag = \"u\"\nafterTextCenterParser\n description Center paragraph.\n crux center\n extends abstractMarkupParser\n javascript\n  tag = \"center\"\naftertextCodeParser\n description Wrap matching text in code span.\n crux code\n extends abstractMarkupParser\n javascript\n  tag = \"code\"\naftertextStrikeParser\n description Wrap matching text in s span.\n crux strike\n extends abstractMarkupParser\n javascript\n  tag = \"s\"\nclassMarkupParser\n description Add a custom class to the parent element instead. If matching text provided, a span with the class will be added around the matching text.\n extends abstractMarkupParser\n cells commandWordCell classNameCell\n crux class\n javascript\n  tag = \"span\"\n  get applyToParentElement() {\n   return this.words.length === 2\n  }\n  getInserts(text) {\n   // If no select text is added, set the class on the parent element.\n   if (this.applyToParentElement) return []\n   return super.getInserts(text)\n  }\n  get className() {\n   return this.getWord(1)\n  }\n  get attributes() {\n   return [`class=\"${this.className}\"`]\n  }\n  get matchWholeLine() {\n    return this.applyToParentElement\n  }\n  get pattern() {\n   return this.matchWholeLine ? this.parent.content : this.getWordsFrom(2).join(\" \")\n  }\nclassesMarkupParser\n extends classMarkupParser\n crux classes\n javascript\n  applyToParentElement = true\n  get className() {\n   return this.content\n  }\nhoverNoteParser\n description Add a caveat viewable on hover on matching text. When you want to be sure you've thoroughly addressed obvious concerns but ones that don't warrant to distract from the main argument of the text.\n cruxFromId\n extends classMarkupParser\n catchAllParser lineOfTextParser\n cells commandWordCell\n javascript\n  get pattern() {\n   return this.getWordsFrom(1).join(\" \")\n  }\n  get attributes() {\n   return [`class=\"scrollHoverNote\"`, `title=\"${this.hoverNoteText}\"`]\n  }\n  get hoverNoteText() {\n   return this.childrenToString().replace(/\\n/g, \" \")\n  }\nlinkParser\n extends abstractMarkupParser\n description Put the matching text in an <a> tag.\n cells commandWordCell urlCell\n inScope linkTitleParser linkTargetParser commentParser\n programParser\n  description Anything here will be URI encoded and then appended to the link.\n  cruxFromId\n  cells commandWordCell\n  catchAllParser programLinkParser\n  javascript\n   get encoded() {\n    return encodeURIComponent(this.childrenToString())\n   }\n cruxFromId\n javascript\n  tag = \"a\"\n  compileTxt() {\n    return this.root.file.ensureAbsoluteLink(this.link) + \" \" + this.pattern\n  }\n  get link() {\n   const {baseLink} = this\n   if (this.has(\"program\"))\n     return baseLink + this.getNode(\"program\").encoded\n   return baseLink\n  }\n  get baseLink() {\n   const link = this.getWord(1)\n   const isAbsoluteLink = link.includes(\"://\")\n   if (isAbsoluteLink) return link\n   const relativePath = this.parent.compileSettings?.relativePath || \"\"\n   return relativePath + link\n  }\n  get attributes() {\n   const attrs = [`href=\"${this.link}\"`]\n   const options = [\"title\", \"target\"]\n   options.forEach(option => {\n    const node = this.getNode(option)\n    if (node) attrs.push(`${option}=\"${node.content}\"`)\n   })\n   return attrs\n  }\n  patternStartsAtWord = 2\nemailLinkParser\n description A mailto link\n crux email\n extends linkParser\n javascript\n  get attributes() {\n   return [`href=\"mailto:${this.link}\"`]\n  }\nquickLinkParser\n pattern ^https?\\:\n extends linkParser\n cells urlCell\n javascript\n  get link() {\n   return this.firstWord\n  }\n  patternStartsAtWord = 1\ndatelineParser\n cruxFromId\n description Gives your paragraph a dateline like \"December 15, 2021 ‚Äî The...\"\n extends abstractAftertextDirectiveParser\n javascript\n  getInserts() {\n   const {day} = this\n   if (!day) return false\n   return [{ index: 0, string: `<span class=\"scrollDateline\">${day} ‚Äî </span>` }]\n  }\n  matchWholeLine = true\n  get day() {\n   let day = this.content || this.root.get(\"date\") || this.root.file?.date\n   if (!day) return \"\"\n   try {\n    const dayjs = require(\"dayjs\")\n    return dayjs(day).format(`MMMM D, YYYY`)\n   } catch (err) {\n    console.error(err)\n   }\n   return day || \"\"\n  }\ndayjsParser\n description Advanced directive that evals some Javascript code in an environment including \"dayjs\".\n cruxFromId\n extends abstractAftertextDirectiveParser\n javascript\n  getInserts() {\n   const dayjs = require(\"dayjs\")\n   const days = eval(this.content)\n   const index = this.parent.originalTextPostLinkify.indexOf(\"days\")\n   return [{ index, string: `${days} ` }]\n  }\ninlineMarkupsOnParser\n cruxFromId\n description Enable these inline markups only.\n example\n  Hello *world*!\n   inlineMarkupsOn bold\n extends abstractAftertextDirectiveParser\n catchAllCellType inlineMarkupNameCell\n javascript\n  get shouldMatchAll() {\n   return true\n  }\n  get markups() {\n    const {root} = this\n    let markups = [{delimiter: \"`\", tag: \"code\", exclusive: true, name: \"code\"},{delimiter: \"*\", tag: \"strong\", name: \"bold\"}, {delimiter: \"_\", tag: \"em\", name: \"italics\"}]\n    // only add katex markup if the root doc has katex.\n    if (root.has(\"katex\"))\n      markups.unshift({delimiter: \"$\", tag: \"span\", attributes: ' class=\"scrollKatex\"', exclusive: true, name: \"katex\"})\n    if (this.content)\n      return markups.filter(markup => this.content.includes(markup.name))\n    if (root.has(\"inlineMarkups\")) {\n      root.getNode(\"inlineMarkups\").forEach(markup => {\n        const delimiter = markup.getWord(0)\n        const tag = markup.getWord(1)\n        // todo: add support for providing custom functions for inline markups?\n        // for example, !2+2! could run eval, or :about: could search a link map.\n        const attributes = markup.getWordsFrom(2).join(\" \")\n        markups = markups.filter(mu => mu.delimiter !== delimiter) // Remove any overridden markups\n        if (tag)\n          markups.push({delimiter, tag, attributes})\n      })\n    }\n    return markups\n  }\n  matchWholeLine = true\n  getMatches(text) {\n   const exclusives = []\n   return this.markups.map(markup => this.applyMarkup(text, markup, exclusives)).filter(i => i).flat()\n  }\n  applyMarkup(text, markup, exclusives = []) {\n   const {delimiter, tag, attributes} = markup\n   const escapedDelimiter = delimiter.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\")\n   const pattern = new RegExp(`${escapedDelimiter}[^${escapedDelimiter}]+${escapedDelimiter}`, \"g\")\n   const delimiterLength = delimiter.length\n   return [...text.matchAll(pattern)].map(match => {\n    const { index } = match\n    const endIndex = index + match[0].length\n    // I'm too lazy to clean up sdk to write a proper inline markup parser so doing this for now.\n    // The exclusive idea is to not try and apply bold or italic styles inside a TeX or code inline style.\n    // Note that the way this is currently implemented any TeX in an inline code will get rendered, but code\n    // inline of TeX will not. Seems like an okay tradeoff until a proper refactor and cleanup can be done.\n    if (exclusives.some(exclusive => index >= exclusive[0] && index <= exclusive[1]))\n      return undefined\n    if (markup.exclusive)\n      exclusives.push([index, endIndex])\n    return [\n     { index, string: `<${tag + (attributes ? \" \" + attributes : \"\")}>`, endIndex, consumeStartCharacters: delimiterLength },\n     { index: endIndex, endIndex, string: `</${tag}>`, consumeEndCharacters: delimiterLength }\n    ]\n   }).filter(i => i)\n  }\ninlineMarkupParser\n cruxFromId\n cells commandWordCell delimiterCell tagOrUrlCell\n catchAllCellType htmlAttributesCell\n extends inlineMarkupsOnParser\n description Custom inline markup. for\n example\n  @This@ will be in italics.\n   inlineMarkup @ em\n javascript\n  getMatches(text) {\n   try {\n    const delimiter = this.getWord(1)\n    const tag = this.getWord(2)\n    const attributes = this.getWordsFrom(3).join(\" \")\n    return this.applyMarkup(text, {delimiter, tag, attributes})\n   } catch (err) {\n    console.error(err)\n    return []\n   }\n   // Note: doubling up doesn't work because of the consumption characters.\n  }\nlinkifyParser\n description Use this to disable linkify on the text.\n extends abstractAftertextDirectiveParser\n cruxFromId\n cells commandWordCell booleanCell\nabstractMarkupParameterParser\n cells commandWordCell\n cruxFromId\nmatchAllParser\n description Use this to match all occurrences of the text.\n extends abstractMarkupParameterParser\nmatchParser\n catchAllCellType integerCell\n description Use this to specify which index(es) to match.\n javascript\n  get indexes() {\n   return this.getWordsFrom(1).map(num => parseInt(num))\n  }\n example\n  aftertext\n   hello ello ello\n   bold ello\n    match 0 2\n extends abstractMarkupParameterParser\nabstractHtmlAttributeParser\n javascript\n  compile() {\n   return \"\"\n  }\nlinkTargetParser\n extends abstractHtmlAttributeParser\n description If you want to set the target of the link. To \"_blank\", for example.\n crux target\n cells commandWordCell anyCell\nblankLineParser\n description Print nothing. Break section.\n cells blankCell\n boolean isPopular true\n javascript\n  compile() {\n   return this.parent.clearSectionStack()\n  }\n pattern ^$\n tags doNotSynthesize\nchatLineParser\n catchAllCellType anyCell\n catchAllParser chatLineParser\nlineOfCodeParser\n catchAllCellType codeCell\n catchAllParser lineOfCodeParser\ncommentLineParser\n catchAllCellType commentCell\ncssLineParser\n catchAllCellType cssAnyCell\n catchAllParser cssLineParser\nerrorParser\n baseParser errorParser\nabstractTableTransformParser\n cells commandWordCell\n inScope abstractTableVisualizationParser abstractTableTransformParser h1Parser h2Parser scrollQuestionParser\n javascript\n  get coreTable() {\n    return this.parent.coreTable\n  }\n  get columnNames() {\n    return this.parent.columnNames\n  }\n  getRunTimeEnumOptions(cell) {\n   if (cell.cellTypeId === \"columnNameCell\")\n      return this.parent.columnNames\n   return super.getRunTimeEnumOptions(cell)\n  }\n  getRunTimeEnumOptionsForValidation(cell) {\n    if (cell.cellTypeId === \"columnNameCell\")\n      return this.parent.columnNames.concat(this.parent.columnNames.map(c => \"-\" + c)) // Add reverse names\n   return super.getRunTimeEnumOptions(cell)\n  }\nscrollGroupByParser\n catchAllCellType columnNameCell\n extends abstractTableTransformParser\n description Combine rows with matching values into groups.\n example\n  tables posts.csv\n   groupBy year\n    printTable\n crux groupBy\n javascript\n  get coreTable() {\n    if (this._coreTable) return this._coreTable\n   const groupByColNames = this.getWordsFrom(1)\n   const {coreTable} = this.parent\n   if (!groupByColNames.length) return coreTable\n   const newCols = [].map(reduceNode => {\n    return {\n     source: reduceNode.getWord(1),\n     reduction: reduceNode.getWord(2),\n     name: reduceNode.getWord(3) || reduceNode.getWordsFrom(1).join(\"_\")\n    }\n   })\n   // Pivot is shorthand for group and reduce?\n   const makePivotTable = (rows, groupByColumnNames, inputColumnNames, newCols) => {\n     const colMap = {}\n     inputColumnNames.forEach((col) => (colMap[col] = true))\n     const groupByCols = groupByColumnNames.filter((col) => colMap[col])\n     return new PivotTable(rows, inputColumnNames.map(c => {return {name: c}}), newCols).getNewRows(groupByCols)\n   }\n   class PivotTable {\n     constructor(rows, inputColumns, outputColumns) {\n       this._columns = {}\n       this._rows = rows\n       inputColumns.forEach((col) => (this._columns[col.name] = col))\n       outputColumns.forEach((col) => (this._columns[col.name] = col))\n     }\n     _getGroups(allRows, groupByColNames) {\n       const rowsInGroups = new Map()\n       allRows.forEach((row) => {\n         const groupKey = groupByColNames.map((col) => row[col]?.toString().replace(/ /g, \"\") || \"\").join(\" \")\n         if (!rowsInGroups.has(groupKey)) rowsInGroups.set(groupKey, [])\n         rowsInGroups.get(groupKey).push(row)\n       })\n       return rowsInGroups\n     }\n     getNewRows(groupByCols) {\n       // make new trees\n       const rowsInGroups = this._getGroups(this._rows, groupByCols)\n       // Any column in the group should be reused by the children\n       const columns = [\n         {\n           name: \"count\",\n           type: \"number\",\n           min: 0,\n         },\n       ]\n       groupByCols.forEach((colName) => columns.push(this._columns[colName]))\n       const colsToReduce = Object.values(this._columns).filter((col) => !!col.reduction)\n       colsToReduce.forEach((col) => columns.push(col))\n       // for each group\n       const rows = []\n       const totalGroups = rowsInGroups.size\n       for (let [groupId, group] of rowsInGroups) {\n         const firstRow = group[0]\n         const newRow = {}\n         groupByCols.forEach((col) =>\n           newRow[col] = firstRow ? firstRow[col] : 0\n         )\n         newRow.count = group.length\n         // todo: add more reductions? count, stddev, median, variance.\n         colsToReduce.forEach((col) => {\n           const sourceColName = col.source\n           const values = group.map((row) => row[sourceColName]).filter((val) => typeof val === \"number\" && !isNaN(val))\n           const reduction = col.reduction\n           let reducedValue = firstRow[sourceColName]\n           if (reduction === \"sum\") reducedValue = values.reduce((prev, current) => prev + current, 0)\n           if (reduction === \"max\") reducedValue = Math.max(...values)\n           if (reduction === \"min\") reducedValue = Math.min(...values)\n           if (reduction === \"mean\") reducedValue = values.reduce((prev, current) => prev + current, 0) / values.length\n           newRow[col.name] = reducedValue\n         })\n         rows.push(newRow)\n       }\n       // todo: add tests. figure out this api better.\n       Object.values(columns).forEach((col) => {\n         // For pivot columns, remove the source and reduction info for now. Treat things as immutable.\n         delete col.source\n         delete col.reduction\n       })\n       return {\n         rows,\n         columns,\n       }\n     }\n   }\n   const pivotTable = makePivotTable(coreTable, groupByColNames, this.parent.columnNames, newCols)\n   this._coreTable = pivotTable.rows\n   this._columnNames = pivotTable.columns.map(col => col.name)\n   return pivotTable.rows\n  }\n  get columnNames() {\n    const {coreTable} = this\n    return this._columnNames || this.parent.columnNames\n  }\nscrollWhereParser\n extends abstractTableTransformParser\n description Filter rows by condition.\n crux where\n cells commandWordCell columnNameCell comparisonCell wordCell\n example\n  table iris.csv\n   where Species = setosa\n javascript\n  get coreTable() {\n   // todo: use cells here.\n   const columnName = this.getWord(1)\n   const operator = this.getWord(2)\n   let untypedScalarValue = this.getWord(3)\n   const typedValue = isNaN(parseFloat(untypedScalarValue)) ? untypedScalarValue : parseFloat(untypedScalarValue)\n   const coreTable = this.parent.coreTable\n   if (!columnName || !operator || untypedScalarValue === undefined) return coreTable\n    const filterFn = row => {\n      const cell = row[columnName]\n      const typedCell = cell\n      if (operator === \"=\") return typedValue === typedCell\n      else if (operator === \"!=\") return typedValue !== typedCell\n      else if (operator === \"includes\") return typedCell !== undefined && typedCell.includes(typedValue)\n      else if (operator === \"doesNotInclude\") return typedCell === undefined || !typedCell.includes(typedValue)\n      else if (operator === \">\") return typedCell > typedValue\n      else if (operator === \"<\") return typedCell < typedValue\n      else if (operator === \">=\") return typedCell >= typedValue\n      else if (operator === \"<=\") return typedCell <= typedValue\n      else if (operator === \"empty\") return cell === \"\" || cell === undefined\n      else if (operator === \"notEmpty\") return !(cell === \"\" || cell === undefined)\n    }\n   return coreTable.filter(filterFn)\n  }\nscrollSelectParser\n catchAllCellType columnNameCell\n extends abstractTableTransformParser\n description Drop all columns except these.\n example\n  tables\n   data\n    name,year,count\n    index,2022,2\n    about,2023,4\n   select name year\n    printTable\n crux select\n javascript\n  get coreTable() {\n   const {coreTable} = this.parent\n   const {columnNames} = this\n   if (!columnNames.length) return coreTable\n   return coreTable.map(row => Object.fromEntries(columnNames.map(colName => [colName, row[colName]])))\n  }\n  get columnNames() {\n    return this.getWordsFrom(1)\n  }\nscrollReverseParser\n extends abstractTableTransformParser\n description Reverse rows.\n crux reverse\n javascript\n  get coreTable() {\n   return this.parent.coreTable.slice().reverse()\n  }\nscrollTransposeParser\n extends abstractTableTransformParser\n description Tranpose table.\n crux transpose\n javascript\n  get coreTable() {\n   // todo: we need to switch to column based coreTable, instead of row based\n   const transpose = arr => Object.keys(arr[0]).map(key => [key, ...arr.map(row => row[key])]);\n   return transpose(this.parent.coreTable)\n  }\nscrollImputeParser\n extends abstractTableTransformParser\n description Impute missing values of a columm.\n cells commandWordCell columnNameCell\n crux impute\n javascript\n  get coreTable() {\n   const {lodash, columnName} = this\n   const sorted = lodash.orderBy(this.parent.coreTable.slice(), columnName)\n   // ascending\n   const imputed = []\n   let lastInserted = sorted[0][columnName]\n   sorted.forEach(row => {\n    const measuredTime = row[columnName]\n    while (measuredTime > lastInserted + 1) {\n      lastInserted++\n      // synthesize rows\n      const imputedRow = {}\n      imputedRow[columnName] = lastInserted\n      imputedRow.count = 0\n      imputed.push(imputedRow)\n    }\n    lastInserted = measuredTime\n    imputed.push(row)\n   })\n   return imputed\n  }\n  get columnName() {\n    return this.getWord(1)\n  }\n  get lodash() {\n    return this.isNodeJs() ? require(\"lodash\") : lodash\n  }\nscrollOrderByParser\n extends abstractTableTransformParser\n description Sort rows by column(s).\n catchAllCellType columnNameCell\n crux orderBy\n javascript\n  get coreTable() {\n    const makeLodashOrderByParams = str => {\n    const part1 = str.split(\" \")\n    const part2 = part1.map(col => (col.startsWith(\"-\") ? \"desc\" : \"asc\"))\n    return [part1.map(col => col.replace(/^\\-/, \"\")), part2]\n   }\n   const orderBy = makeLodashOrderByParams(this.content)\n   return this.lodash.orderBy(this.parent.coreTable.slice(), orderBy[0], orderBy[1])\n  }\n  get lodash() {\n    return this.isNodeJs() ? require(\"lodash\") : lodash\n  }\nscrollRenameParser\n // todo: add support in Parsers for tuple catch alls\n  catchAllCellType columnNameCell wordCell\n catchAllCellType wordCell\n extends abstractTableTransformParser\n description Rename columns.\n example\n  tables\n   data\n    name,year,count\n    index,2022,2\n   rename name Name year Year\n    printTable\n crux rename\n javascript\n  get coreTable() {\n   const {coreTable} = this.parent\n   const {renameMap} = this\n   if (!Object.keys(renameMap).length) return coreTable\n   return coreTable.map(row => {\n      const newRow = {}\n      Object.keys(row).forEach(key => {\n        const name = renameMap[key] || key\n        newRow[name] = row[key]\n      })\n      return newRow\n   })\n  }\n  get renameMap() {\n    const map = {}\n    const pairs = this.getWordsFrom(1)\n    let oldName\n    while (oldName = pairs.shift()) {\n      map[oldName] = pairs.shift()\n    }\n    return map\n  }\n  _renamed\n  get columnNames() {\n   if (this._renamed)\n     return this._renamed\n    const {renameMap} = this\n    this._renamed = this.parent.columnNames.map(name => renameMap[name] || name )\n    return this._renamed\n  }\nheatrixCatchAllParser\n // todo Fill this out\n catchAllCellType stringCell\nlineOfTextParser\n catchAllCellType stringCell\n boolean isTextParser true\nhtmlLineParser\n catchAllCellType htmlAnyCell\n catchAllParser htmlLineParser\nstumpContentParser\n catchAllCellType anyCell\nlinkTitleParser\n description If you want to set the title of the link.\n crux title\n cells commandWordCell\n catchAllCellType anyCell\n example\n  * This report showed the treatment had a big impact.\n   https://example.com/report This report.\n    title The average growth in the treatment group was 14.2x higher than the control group.\nprogramLinkParser\n catchAllCellType codeCell\nabstractLoopConfigParser\n cells commandWordCell\n cruxFromId\n catchAllCellType stringCell\nabstractItemsProviderParser\n cells commandWordCell\nloopLinesParser\n crux lines\n extends abstractItemsProviderParser\n description Iterate over the provided lines.\n catchAllParser loopLineParser\n loopLineParser\n  catchAllCellType stringCell\n javascript\n  get items() {\n   return this.map(node => node.asString)\n  }\nloopWordsParser\n crux words\n extends abstractItemsProviderParser\n catchAllCellType stringCell\n description Iterate over the provided words.\n javascript\n  get items() {\n   return this.getWordsFrom(1)\n  }\nloopTagsParser\n crux tags\n extends abstractItemsProviderParser\n catchAllCellType tagWithOptionalFolderCell\n description Set this to iterate over scroll files in a folder. Provide both the folder and group name like this: [folder]/[tag]\n javascript\n  get items() {\n   return this.root.file.getFilesWithTagsForEmbedding(this.getWordsFrom(1))\n  }\nabstractPointConfigParser\n // todo: scoped parsers should support abstract types\n cruxFromId\n cells commandWordCell\n catchAllCellType stringCell\n single\nlatParser\n cells commandWordCell floatCell\n cruxFromId\n single\nlongParser\n cells commandWordCell floatCell\n cruxFromId\n single\nscrollMediaLoopParser\n crux loop\n cells commandWordCell\nscrollAutoplayParser\n crux autoplay\n cells commandWordCell\nabstractColumnNameParser\n cells commandWordCell columnNameCell\n javascript\n  getRunTimeEnumOptions(cell) {\n   if (cell.cellTypeId === \"columnNameCell\")\n      return this.parent.columnNames\n   return super.getRunTimeEnumOptions(cell)\n  }\nscrollRadiusParser\n crux radius\n extends abstractColumnNameParser\nscrollSymbolParser\n crux symbol\n extends abstractColumnNameParser\nscrollFillParser\n crux fill\n extends abstractColumnNameParser\nscrollLabelParser\n crux label\n extends abstractColumnNameParser\nscrollXParser\n crux x\n extends abstractColumnNameParser\nscrollYParser\n crux y\n extends abstractColumnNameParser\nquoteLineParser\n catchAllCellType anyCell\n catchAllParser quoteLineParser\nscrollParser\n extensions scroll\n description Scroll is a language for scientists of all ages. Refine, share and collaborate on ideas.\n root\n inScope abstractScrollParser blankLineParser\n catchAllParser catchAllParagraphParser\n compilesTo html\n javascript\n  setFile(file) {\n   this.file = file\n   return this\n  }\n  compile(compileSettings) {\n    this.sectionStack = []\n    return this.map(child => child.compile(compileSettings)).filter(i => i).join(\"\\n\") + this.clearSectionStack()\n  }\n  sectionStack = []\n  clearSectionStack() {\n   const result = this.sectionStack.join(\"\")\n   this.sectionStack = []\n   return result\n  }\n  get hakonParser() {\n    if (this.isNodeJs())\n      return require(\"scrollsdk/products/hakon.nodejs.js\")\n    return hakonParser\n  }\n  alreadyRequired = new Set()\n  compileEmbeddedVersion(compileSettings) {\n   this.sectionStack = []\n   return this.map(child => (child.compileEmbeddedVersion ? child.compileEmbeddedVersion(compileSettings) : child.compile(compileSettings)))\n     .filter(i => i)\n     .join(\"\\n\")\n     .trim() + this.clearSectionStack()\n  }\n  get footnotes() {\n   if (this._footnotes === undefined) this._footnotes = this.filter(node => node.isFootnote)\n   return this._footnotes\n  }\n  file = {}\n  get title() {\n    return this.file.title || this.get(\"title\")\n  }\n  get permalink() {\n   return this.get(\"permalink\") || this.file.permalink || \"\"\n  }\n example\n  # Hello world\n  ## This is Scroll\n  * It compiles to HTML.\n  \n  code\n   // You can add code as well.\n   print(\"Hello world\")\nscriptLineParser\n catchAllCellType scriptAnyCell\n catchAllParser scriptLineParser\nstampFileParser\n catchAllCellType stringCell\n description Create a file.\n javascript\n  build(parentDir) {\n   const fs = require(\"fs\")\n   const path = require(\"path\")\n   const fullPath = path.join(parentDir, this.getLine())\n   this.root.file.log(`Creating file ${fullPath}`)\n   fs.mkdirSync(path.dirname(fullPath), {recursive: true})\n   const content = this.childrenToString()\n   fs.writeFileSync(fullPath, content, \"utf8\")\n   const isExecutable = content.startsWith(\"#!\")\n   if (isExecutable) fs.chmodSync(fullPath, \"755\")\n  }\nstampFolderParser\n catchAllCellType stringCell\n description Create a folder.\n inScope stampFolderParser\n catchAllParser stampFileParser\n pattern \\/$\n javascript\n  build(parentDir) {\n   const fs = require(\"fs\")\n   const path = require(\"path\")\n   const newPath = path.join(parentDir, this.getLine())\n   this.root.file.log(`Creating folder ${newPath}`)\n   fs.mkdirSync(newPath, {recursive: true})\n   this.forEach(node => node.build(newPath))\n  }\nscrollTableDataParser\n crux data\n description Table from inline delimited data.\n catchAllCellType anyCell\n baseParser blobParser\nscrollTableDelimiterParser\n description Set the delimiter.\n crux delimiter\n cells commandWordCell stringCell\n javascript\n  compile() {\n    return \"\"\n  }\nplainTextLineParser\n catchAllCellType stringCell\n catchAllParser plainTextLineParser"}